/**
 * ============================================
 * GENERADOR DE FICHAS ZX SPECTRUM - v2.0
 * ============================================
 * 
 * PARTE 1: CONSTANTES, MENÚS Y FUNCIÓN PRINCIPAL
 * 
 * Este archivo contiene:
 * - Configuración global
 * - Menús de Google Sheets
 * - Función principal de preview de fichas
 * 
 * ============================================
 */
// =====================================
// IGDB CONFIG — RELLENAR CON TUS DATOS
// =====================================
const IGDB_CLIENT_ID = '690ect4klrsg9vr5g2vaub27wjjo5i';
const IGDB_ACCESS_TOKEN = '2a2pcx8h9e36umavdk8eikzi1pr8ic';


// ============================================
// CONSTANTES GLOBALES
// ============================================

const FALLBACK_COVER_URL = 'https://raw.githubusercontent.com/Lesbeziers/MI-COLECCION-DE-VIDEOJUEGOS/main/assets/img/CaratulaNoDisponible.png';

// ============================================
// BLOQUE NUEVO v3.0: MOTOR IGDB GENÉRICO
// ============================================
// ============================================
// BLOQUE NUEVO v3.0: MOTOR IGDB GENÉRICO
// ============================================
// INSTRUCCIONES: 
// 1. Copia este bloque COMPLETO
// 2. Pégalo en tu script DESPUÉS de las constantes (IGDB_CLIENT_ID, etc.)
//    y ANTES de la función onOpen()
// 3. Reemplaza la función onOpen() existente con la nueva versión de abajo
// ============================================

// ============================================
// HELPERS DE CONFIGURACIÓN DE PLATAFORMA
// ============================================

/**
 * Lee CONFIG_PLATAFORMAS y devuelve la configuración para una hoja de datos.
 * Usa lectura por cabeceras (no por índices).
 */
function getPlatformConfigByDataSheet_(sheetName) {
  const ss = SpreadsheetApp.getActive();
  const configSheet = ss.getSheetByName('CONFIG_PLATAFORMAS');
  
  if (!configSheet) {
    Logger.log('[CONFIG] ERROR: No se encuentra la hoja CONFIG_PLATAFORMAS');
    return null;
  }
  
  const lastRow = configSheet.getLastRow();
  const lastCol = configSheet.getLastColumn();
  
  if (lastRow < 2 || lastCol < 1) {
    Logger.log('[CONFIG] ERROR: CONFIG_PLATAFORMAS está vacía o sin datos');
    return null;
  }
  
  const headers = configSheet.getRange(1, 1, 1, lastCol).getValues()[0];
  
  const colIdx = {};
  headers.forEach((h, i) => {
    const key = String(h || '').trim().toUpperCase();
    if (key) colIdx[key] = i;
  });
  
  const requiredCols = ['PLATFORM_KEY', 'DATA_SHEET', 'SOURCE_TYPE'];
  for (const col of requiredCols) {
    if (colIdx[col] === undefined) {
      Logger.log('[CONFIG] ERROR: Falta columna requerida: ' + col);
      return null;
    }
  }
  
  const data = configSheet.getRange(2, 1, lastRow - 1, lastCol).getValues();
  const targetSheet = String(sheetName || '').trim().toUpperCase();
  
  for (const row of data) {
    const dataSheetVal = String(row[colIdx['DATA_SHEET']] || '').trim().toUpperCase();
    
    if (dataSheetVal === targetSheet) {
      const config = {
        platformKey: String(row[colIdx['PLATFORM_KEY']] || '').trim(),
        dataSheet: String(row[colIdx['DATA_SHEET']] || '').trim(),
        listSheet: colIdx['LIST_SHEET'] !== undefined ? String(row[colIdx['LIST_SHEET']] || '').trim() : '',
        sourceType: String(row[colIdx['SOURCE_TYPE']] || '').trim().toUpperCase(),
        igdbPlatformId: null,
        coverLayout: colIdx['COVER_LAYOUT'] !== undefined ? String(row[colIdx['COVER_LAYOUT']] || '').trim() : '',
        extraFieldsRaw: colIdx['EXTRA_FIELDS'] !== undefined ? String(row[colIdx['EXTRA_FIELDS']] || '').trim() : '',
        nombreVisible: colIdx['NOMBRE_VISIBLE'] !== undefined ? String(row[colIdx['NOMBRE_VISIBLE']] || '').trim() : ''
      };
      
      if (colIdx['IGDB_PLATFORM_ID'] !== undefined) {
        const rawId = row[colIdx['IGDB_PLATFORM_ID']];
        if (rawId !== null && rawId !== '' && !isNaN(Number(rawId))) {
          config.igdbPlatformId = parseInt(Number(rawId), 10);
        }
      }
      
      Logger.log('[CONFIG] Configuración encontrada para "' + sheetName + '": ' + JSON.stringify(config));
      return config;
    }
  }
  
  Logger.log('[CONFIG] AVISO: No se encontró configuración para hoja "' + sheetName + '"');
  return null;
}

/**
 * Obtiene la configuración de la plataforma basándose en la hoja activa.
 */
function getActivePlatformConfig_() {
  const sh = SpreadsheetApp.getActiveSheet();
  if (!sh) {
    Logger.log('[CONFIG] ERROR: No hay hoja activa');
    return null;
  }
  return getPlatformConfigByDataSheet_(sh.getName().trim());
}

// ============================================
// MOTOR IGDB GENÉRICO
// ============================================

/**
 * Motor IGDB genérico para buscar datos de un juego.
 * Reutilizable por PS3, SWITCH y futuras plataformas IGDB.
 */
function fetchIGDB_(igdbPlatformId, titulo, igdbUrl, anioHoja, nombrePlataforma) {
  const platformName = nombrePlataforma || ('Plataforma IGDB #' + igdbPlatformId);
  
  const EDITION_TERMS = [
    'remastered', 'remaster', 'remake', 'remade',
    'definitive edition', 'definitive',
    'game of the year', 'goty', 'goty edition',
    'ultimate edition', 'ultimate',
    'complete edition', 'complete',
    'directors cut', 'director\'s cut',
    'extended edition', 'extended',
    'enhanced edition', 'enhanced',
    'special edition', 'special',
    'gold edition', 'gold',
    'platinum', 'platinum edition',
    'hd', 'hd edition', 'hd collection',
    'collection', 'anthology',
    'deluxe', 'deluxe edition',
    'legendary edition', 'legendary'
  ];
  
  const PART_TERMS = [
    'part ii', 'part 2', 'part two',
    'part iii', 'part 3', 'part three',
    'part iv', 'part 4', 'part four',
    'ii', 'iii', 'iv', 'v', 'vi', 'vii', 'viii', 'ix', 'x',
    '2', '3', '4', '5', '6', '7', '8', '9', '10'
  ];
  
  const emptyResult = {
    plataforma: platformName,
    titulo: titulo || 'Juego',
    anio: '????',
    generoAnchors: [],
    subgeneroAnchors: [],
    publisherAnchors: [],
    desarrolladorAnchors: [],
    autorAnchors: [],
    contributorsAnchors: [],
    jugadoresAnchors: [],
    controlesAnchors: [],
    versionAnchors: [],
    distribuidorasAnchors: [],
    ratingDisplay: '',
    caratula: '',
    screenshots: [],
    imagenesAdicionales: [],
    mapa: '',
    instrucciones: '',
    video: '',
    revistas: [],
    sinopsis: '',
    argumento: ''
  };

  const titleStr = String(titulo || '').trim();
  const linkStr = String(igdbUrl || '').trim();
  const desiredYear = parseInt(String(anioHoja || '').trim(), 10);
  const hasDesiredYear = !isNaN(desiredYear);

  if (!titleStr && !linkStr) {
    Logger.log('[IGDB] Sin título ni link. Abortando.');
    return emptyResult;
  }

  function getYearFromGame_(game) {
    if (!game || !game.first_release_date) return null;
    const d = new Date(game.first_release_date * 1000);
    const y = d.getFullYear();
    return isNaN(y) ? null : y;
  }

  function parseIgdbLink_(url) {
    if (!url) return { id: null, slug: null };
    try {
      const m = String(url).match(/igdb\.com\/games\/([^/?#]+)/i);
      if (!m) return { id: null, slug: null };
      const part = m[1];
      const idMatch = part.match(/^(\d+)-/);
      let id = null, slug = null;
      if (idMatch) {
        id = parseInt(idMatch[1], 10);
        slug = part.substring(idMatch[0].length) || null;
      } else {
        slug = part || null;
      }
      if (isNaN(id)) id = null;
      return { id: id, slug: slug };
    } catch (e) {
      return { id: null, slug: null };
    }
  }

  function normalizeToBaseTitle_(text) {
    if (!text) return '';
    let s = String(text).toLowerCase().trim();
    s = s.normalize('NFD').replace(/[\u0300-\u036f]/g, '');
    s = s.replace(/[^a-z0-9\s]/g, ' ');
    EDITION_TERMS.forEach(function(term) {
      var re = new RegExp('\\b' + term.replace(/[.*+?^${}()|[\]\\]/g, '\\$&') + '\\b', 'gi');
      s = s.replace(re, ' ');
    });
    PART_TERMS.forEach(function(term) {
      var re = new RegExp('\\s+' + term.replace(/[.*+?^${}()|[\]\\]/g, '\\$&') + '(?:\\s+|$)', 'gi');
      s = s.replace(re, ' ');
    });
    return s.replace(/\s+/g, ' ').trim();
  }

  function containsPartTerms_(text) {
    if (!text) return false;
    var lower = String(text).toLowerCase();
    var partPatterns = [
      /\bpart\s*(ii|iii|iv|v|vi|vii|viii|ix|x|2|3|4|5|6|7|8|9|10)\b/i,
      /\b(ii|iii|iv|v|vi|vii|viii|ix|x)\s*$/i,
      /\s+(2|3|4|5|6|7|8|9|10)\s*$/
    ];
    for (var i = 0; i < partPatterns.length; i++) {
      if (partPatterns[i].test(lower)) return true;
    }
    return false;
  }

  function containsEditionTerms_(text) {
    if (!text) return false;
    var lower = String(text).toLowerCase();
    for (var i = 0; i < EDITION_TERMS.length; i++) {
      var term = EDITION_TERMS[i];
      var re = new RegExp('\\b' + term.replace(/[.*+?^${}()|[\]\\]/g, '\\$&') + '\\b', 'i');
      if (re.test(lower)) return true;
    }
    return false;
  }

  function hasPlatform_(game, platformId) {
    if (!game || !Array.isArray(game.platforms)) return false;
    return game.platforms.some(function(p) {
      return p === platformId || (p && p.id === platformId);
    });
  }

  function gameToResult_(game) {
    var gameYear = getYearFromGame_(game);
    var anio = gameYear ? String(gameYear) : '????';

    var generoAnchors = [];
    if (Array.isArray(game.genres)) {
      game.genres.forEach(function(g) {
        if (g && g.name) generoAnchors.push({ text: g.name, href: '' });
      });
    }

    var subgeneroAnchors = [];
    if (Array.isArray(game.themes)) {
      game.themes.forEach(function(t) {
        if (t && t.name) subgeneroAnchors.push({ text: t.name, href: '' });
      });
    }

    var jugadoresAnchors = [];
    if (Array.isArray(game.game_modes)) {
      game.game_modes.forEach(function(m) {
        if (m && m.name) jugadoresAnchors.push({ text: m.name, href: '' });
      });
    }

    var publisherAnchors = [];
    var desarrolladorAnchors = [];
    if (Array.isArray(game.involved_companies)) {
      game.involved_companies.forEach(function(ic) {
        if (ic && ic.company && ic.company.name) {
          var companyName = ic.company.name;
          if (ic.publisher) publisherAnchors.push({ text: companyName, href: '' });
          if (ic.developer) desarrolladorAnchors.push({ text: companyName, href: '' });
        }
      });
    }

    var caratula = '';
    if (game.cover && game.cover.image_id) {
      caratula = 'https://images.igdb.com/igdb/image/upload/t_1080p/' + game.cover.image_id + '.jpg';
    }

    var screenshots = [];
    if (Array.isArray(game.screenshots)) {
      game.screenshots.slice(0, 4).forEach(function(s) {
        if (s && s.image_id) {
          screenshots.push('https://images.igdb.com/igdb/image/upload/t_1080p/' + s.image_id + '.jpg');
        }
      });
    }

var videoUrl = '';
    if (Array.isArray(game.videos) && game.videos.length > 0) {
      game.videos.forEach(function(v) {
        if (v && v.video_id && !videoUrl) {
          videoUrl = 'https://www.youtube.com/watch?v=' + v.video_id;
        }
      });
    }

    // Rating con fallback: primero critic, luego user, luego juego padre
    Logger.log('[IGDB DEBUG] aggregated_rating: ' + game.aggregated_rating + ', rating: ' + game.rating + ', version_parent: ' + game.version_parent);
    var ratingValue = null;
    if (typeof game.aggregated_rating === 'number' && !isNaN(game.aggregated_rating)) {
      ratingValue = Math.round(game.aggregated_rating);
    } else if (typeof game.rating === 'number' && !isNaN(game.rating)) {
      ratingValue = Math.round(game.rating);
} else {
      Logger.log('[IGDB] Sin rating local, buscando por nombre...');
      ratingValue = fetchRatingByName_(game.name);
    }

    return {
      plataforma: platformName,
      titulo: game.name || titulo,
      anio: anio,
      generoAnchors: generoAnchors,
      subgeneroAnchors: subgeneroAnchors,
      publisherAnchors: publisherAnchors,
      desarrolladorAnchors: desarrolladorAnchors,
      autorAnchors: [],
      contributorsAnchors: [],
      jugadoresAnchors: jugadoresAnchors,
      controlesAnchors: [],
      versionAnchors: [],
      distribuidorasAnchors: [],
ratingDisplay: ratingValue !== null ? ratingValue + '/100' : '',
      caratula: caratula,
      screenshots: screenshots,
      imagenesAdicionales: [],
      mapa: '',
      instrucciones: '',
      video: videoUrl,
      revistas: [],
      sinopsis: game.summary || '',
      argumento: game.storyline || ''
    };
  }
function fetchRatingByName_(gameName) {
    if (!gameName) return null;
    var query = 'fields name, aggregated_rating, rating; search "' + gameName.replace(/"/g, '\\"') + '"; where aggregated_rating != null | rating != null; limit 5;';
    var endpoint = 'https://api.igdb.com/v4/games';
    var options = {
      method: 'post',
      headers: {
        'Client-ID': IGDB_CLIENT_ID,
        'Authorization': 'Bearer ' + IGDB_ACCESS_TOKEN,
        'Content-Type': 'text/plain'
      },
      payload: query,
      muteHttpExceptions: true
    };
    try {
      var response = UrlFetchApp.fetch(endpoint, options);
      if (response.getResponseCode() !== 200) return null;
      var results = JSON.parse(response.getContentText());
      if (Array.isArray(results) && results.length > 0) {
        for (var i = 0; i < results.length; i++) {
          var g = results[i];
          Logger.log('[IGDB] Fallback rating encontrado en "' + g.name + '": aggregated=' + g.aggregated_rating + ', user=' + g.rating);
          if (typeof g.aggregated_rating === 'number' && !isNaN(g.aggregated_rating)) {
            return Math.round(g.aggregated_rating);
          } else if (typeof g.rating === 'number' && !isNaN(g.rating)) {
            return Math.round(g.rating);
          }
        }
      }
    } catch (e) {
      Logger.log('[IGDB] Error buscando rating por nombre: ' + e);
    }
    return null;
  }
  function executeIgdbQuery_(query) {
    var endpoint = 'https://api.igdb.com/v4/games';
    var options = {
      method: 'post',
      headers: {
        'Client-ID': IGDB_CLIENT_ID,
        'Authorization': 'Bearer ' + IGDB_ACCESS_TOKEN,
        'Content-Type': 'text/plain'
      },
      payload: query,
      muteHttpExceptions: true
    };
    var response = UrlFetchApp.fetch(endpoint, options);
    if (response.getResponseCode() !== 200) {
      Logger.log('[IGDB] Error HTTP ' + response.getResponseCode());
      return null;
    }
    var results = JSON.parse(response.getContentText());
    return Array.isArray(results) ? results : null;
  }

  try {
var fieldsBlock =
      'fields name, slug, first_release_date, aggregated_rating, rating, version_parent, ' +
      'genres.name, themes.name, game_modes.name, ' +
      'involved_companies.company.name, involved_companies.developer, involved_companies.publisher, ' +
      'cover.image_id, screenshots.image_id, videos.video_id, summary, storyline, platforms;';

    if (linkStr) {
      var parsedLink = parseIgdbLink_(linkStr);
      var query = null;
      if (parsedLink.id) {
        query = fieldsBlock + ' where id = ' + parsedLink.id + '; limit 1;';
      } else if (parsedLink.slug) {
        query = fieldsBlock + ' where slug = "' + parsedLink.slug.replace(/"/g, '\\"') + '"; limit 1;';
      }
      if (query) {
        var results = executeIgdbQuery_(query);
        if (results && results.length > 0) {
          Logger.log('[IGDB] Juego encontrado por URL: ' + results[0].name);
          return gameToResult_(results[0]);
        }
      }
    }

    if (!titleStr) return emptyResult;

    var searchQuery = fieldsBlock + ' search "' + titleStr.replace(/"/g, '\\"') + '"; limit 20;';
    Logger.log('[IGDB] Buscando: "' + titleStr + '" (plataforma: ' + igdbPlatformId + ')');
    
    var results = executeIgdbQuery_(searchQuery);
    if (!results || results.length === 0) return emptyResult;

    var candidates = results.slice();
    var sheetBaseTitle = normalizeToBaseTitle_(titleStr);
    var sheetHasPartTerms = containsPartTerms_(titleStr);
    var sheetHasEditionTerms = containsEditionTerms_(titleStr);

    // Filtro familia
    var familyFiltered = candidates.filter(function(g) {
      return normalizeToBaseTitle_(g.name) === sheetBaseTitle;
    });
    if (familyFiltered.length > 0) candidates = familyFiltered;

    // Filtro año
    if (hasDesiredYear && candidates.length > 1) {
      var yearFiltered = candidates.filter(function(g) {
        return getYearFromGame_(g) === desiredYear;
      });
      if (yearFiltered.length > 0) candidates = yearFiltered;
    }

    // Filtro plataforma
    if (candidates.length > 1 && igdbPlatformId) {
      var platformFiltered = candidates.filter(function(g) {
        return hasPlatform_(g, igdbPlatformId);
      });
      if (platformFiltered.length > 0) candidates = platformFiltered;
    }

    // Filtro variantes
    var beforeVariantFilter = candidates.slice();
    if (candidates.length > 1 && !sheetHasPartTerms) {
      var noPartFiltered = candidates.filter(function(g) { return !containsPartTerms_(g.name); });
      if (noPartFiltered.length > 0) candidates = noPartFiltered;
    }
    if (candidates.length > 1 && !sheetHasEditionTerms) {
      var noEditionFiltered = candidates.filter(function(g) { return !containsEditionTerms_(g.name); });
      if (noEditionFiltered.length > 0) candidates = noEditionFiltered;
    }
    if (candidates.length === 0) candidates = beforeVariantFilter;

    // Desempate por antigüedad
    if (candidates.length > 1) {
      candidates.sort(function(a, b) {
        return (getYearFromGame_(a) || 9999) - (getYearFromGame_(b) || 9999);
      });
    }

    Logger.log('[IGDB] Seleccionado: ' + candidates[0].name + ' (ID: ' + candidates[0].id + ')');
    return gameToResult_(candidates[0]);

  } catch (e) {
    Logger.log('[IGDB] Excepción: ' + e);
    return emptyResult;
  }
}

// ============================================
// ENTRY POINT: ACTUALIZAR DESDE IGDB (FILA ACTUAL)
// ============================================

// ============================================
// CAMBIO 2: NUEVA FUNCIÓN menuActualizarFilaActual()
// (Reemplaza la función menuActualizarFilaActual existente)
// Ahora incluye la generación de ficha lateral como ZX Spectrum
// ============================================

function menuActualizarFilaActual() {
  const ui = SpreadsheetApp.getUi();
  const sh = SpreadsheetApp.getActiveSheet();
  const row = sh.getActiveCell() ? sh.getActiveCell().getRow() : 0;
  
  if (!row || row === 1) {
    return uiAlert_('Selecciona una fila con datos (no la cabecera).');
  }
  
  const cfg = getActivePlatformConfig_();
  
  if (!cfg) {
    return uiAlert_('La hoja "' + sh.getName() + '" no está configurada en CONFIG_PLATAFORMAS.\n\nHojas válidas: PS3, SWITCH, ZX_SPECTRUM');
  }
  
  Logger.log('[MENU] Plataforma: ' + cfg.platformKey + ' (SOURCE_TYPE=' + cfg.sourceType + ')');
  
  // ============================================
  // FLUJO IGDB (PS3, SWITCH, futuras plataformas)
  // ============================================
  if (cfg.sourceType === 'IGDB') {
    if (!cfg.igdbPlatformId) {
      return uiAlert_('Error: La plataforma "' + cfg.platformKey + '" no tiene IGDB_PLATFORM_ID configurado.');
    }
    
    const headers = sh.getRange(1, 1, 1, Math.max(1, sh.getLastColumn())).getValues()[0];
    
    const normalizeHeader = (s) => String(s || '').trim().toUpperCase()
      .normalize('NFD').replace(/[\u0300-\u036f]/g, '').replace(/\s+/g, '_');
    
    const get = (h) => {
      let i = headers.indexOf(h);
      if (i > -1) return sh.getRange(row, i + 1).getValue();
      const hNorm = normalizeHeader(h);
      for (let j = 0; j < headers.length; j++) {
        if (normalizeHeader(headers[j]) === hNorm) return sh.getRange(row, j + 1).getValue();
      }
      return '';
    };
    
    // ====================================
    // LEER TÍTULO Y URL
    // ====================================
    const titulo = get('TÍTULO') || get('TITULO');
    if (!titulo) return uiAlert_('Falta el campo "TÍTULO" / "TITULO" en la fila.');
    
    const igdbUrl = get('IGDB_URL') || '';
    const anioHoja = String(get('AÑO') || '').trim();
    
    Logger.log('[IGDB] Título: ' + titulo + ' | IGDB_URL: ' + igdbUrl);
    
    // ====================================
    // LEER COLUMNAS MANUALES (varían por plataforma)
    // ====================================
    const prefijo = cfg.platformKey; // PS3, SWITCH, etc.
    const columnasManual = {
      ubicacion: String(get(prefijo + '_UBICACION') || '').trim(),
      tipoFormato: String(get(prefijo + '_TIPO_FORMATO') || '').trim(),
      favorito: String(get('FAVORITO') || '').trim(),
      terminado: String(get('TERMINADO') || '').trim(),
      masInfo: String(get('MAS_INFO') || ''),
      formato: '',
      zx2a: '',
      tspec: ''
    };
    
    // ====================================
    // LEER VALORES EXISTENTES EN LA HOJA
    // ====================================
    const videoHoja = String(get('VIDEO') || '').trim();
    const argumentoHoja = String(get('ARGUMENTO') || '');
    const sinopsisHoja = String(get('SINOPSIS') || '');
    const caratulaHoja = String(get('CARÁTULA') || get('CARATULA') || '').trim();
    const screenshotsHoja = String(get('SCREENSHOTS') || '').trim();
    const anioHoja_existente = String(get('AÑO') || '').trim();
    const generoHoja = String(get('GÉNERO') || get('GENERO') || '').trim();
    const subgeneroHoja = String(get('SUBGÉNERO') || get('SUBGENERO') || '').trim();
    const publisherHoja = String(get('PUBLISHER') || '').trim();
    const desarrolladorHoja = String(get('DESARROLLADOR') || get('DESARROLLO') || '').trim();
    const jugadoresHoja = String(get('JUGADORES') || '').trim();
    const controlesHoja = String(get('CONTROLES') || '').trim();
    const versionHoja = String(get('VERSIÓN') || get('VERSION') || '').trim();
    const distribuidorasHoja = String(get('DISTRIBUIDORAS') || '').trim();
    const puntuacionHoja = String(get('PUNTUACIÓN') || get('PUNTUACION') || '').trim();
    
    // ====================================
    // OBTENER DATOS DE IGDB
    // ====================================
    const nombrePlataforma = cfg.nombreVisible || cfg.platformKey;
    const data = fetchIGDB_(cfg.igdbPlatformId, titulo, igdbUrl, anioHoja, nombrePlataforma);
    
    // ====================================
    // RESPETAR VALORES EXISTENTES EN LA HOJA
    // ====================================
    if (videoHoja) {
      data.video = videoHoja;
      Logger.log('[IGDB] Video manual respetado');
    }
    
    if (caratulaHoja) {
      data.caratula = caratulaHoja;
      Logger.log('[IGDB] Carátula manual respetada');
    }
    
    if (screenshotsHoja) {
      data.screenshots = screenshotsHoja.split(',').map(s => s.trim()).filter(Boolean);
      Logger.log('[IGDB] Screenshots manuales respetados');
    }
    
    if (anioHoja_existente) {
      data.anio = anioHoja_existente;
      Logger.log('[IGDB] Año manual respetado');
    }
    
    if (generoHoja) {
      data.generoAnchors = [{text: generoHoja, href: ''}];
      Logger.log('[IGDB] Género manual respetado');
    }
    
    if (subgeneroHoja) {
      data.subgeneroAnchors = [{text: subgeneroHoja, href: ''}];
      Logger.log('[IGDB] Subgénero manual respetado');
    }
    
    if (publisherHoja) {
      data.publisherAnchors = [{text: publisherHoja, href: ''}];
      Logger.log('[IGDB] Publisher manual respetado');
    }
    
    if (desarrolladorHoja) {
      data.desarrolladorAnchors = [{text: desarrolladorHoja, href: ''}];
      Logger.log('[IGDB] Desarrollador manual respetado');
    }
    
    if (jugadoresHoja) {
      data.jugadoresAnchors = [{text: jugadoresHoja, href: ''}];
      Logger.log('[IGDB] Jugadores manual respetado');
    }
    
    if (controlesHoja) {
      data.controlesAnchors = [{text: controlesHoja, href: ''}];
      Logger.log('[IGDB] Controles manual respetado');
    }
    
    if (versionHoja) {
      data.versionAnchors = [{text: versionHoja, href: ''}];
      Logger.log('[IGDB] Versión manual respetada');
    }
    
    if (distribuidorasHoja) {
      data.distribuidorasAnchors = [{text: distribuidorasHoja, href: ''}];
      Logger.log('[IGDB] Distribuidoras manual respetado');
    }
    
    if (puntuacionHoja) {
      data.ratingDisplay = puntuacionHoja;
      Logger.log('[IGDB] Puntuación manual respetada');
    }
    
    // ====================================
    // TRADUCIR SINOPSIS Y ARGUMENTO
    // ====================================
    if (sinopsisHoja.trim()) {
      data.sinopsis = sinopsisHoja;
      Logger.log('[IGDB] Sinopsis manual respetada');
    } else if (data.sinopsis && data.sinopsis.trim()) {
      Logger.log('[IGDB] Traduciendo sinopsis...');
      data.sinopsis = translateTextToSpanish_(data.sinopsis);
    }
    
    if (argumentoHoja.trim()) {
      data.argumento = argumentoHoja;
      Logger.log('[IGDB] Argumento manual respetado');
    } else if (data.argumento && data.argumento.trim()) {
      Logger.log('[IGDB] Traduciendo argumento...');
      data.argumento = translateTextToSpanish_(data.argumento);
    }
    
    // ====================================
    // ESCRIBIR DATOS EN LA HOJA
    // ====================================
    writeBackIGDBRowFromData_(sh, row, headers, data);
    
    // ====================================
    // GENERAR FICHA LATERAL (SIDEBAR)
    // ====================================
const html = buildPreviewHtml_(titulo, nombrePlataforma, igdbUrl, data, columnasManual, data.sinopsis);
Logger.log('[DEBUG] HTML length: ' + (html ? html.length : 'NULL'));
Logger.log('[DEBUG] HTML preview: ' + (html ? html.substring(0, 500) : 'NULL'));
SpreadsheetApp.getUi().showSidebar(HtmlService.createHtmlOutput(html).setTitle('Ficha ' + cfg.platformKey));
    
    return;
  }
  
  // ============================================
  // FLUJO ZX SPECTRUM - Redirigir al menú ZX SP
  // ============================================
  if (cfg.sourceType === 'ZX_SC') {
    ui.alert('ZX Spectrum', 
      'Para ZX Spectrum usa el menú "ZX SP > Vista previa de ficha".\n\nLa columna de URL para ZX es "LINK" (no IGDB_URL).',
      ui.ButtonSet.OK);
    return;
  }
  
  uiAlert_('SOURCE_TYPE "' + cfg.sourceType + '" no implementado.');
}

// ============================================
// ESCRITURA GENÉRICA IGDB
// ============================================

function writeBackIGDBRowFromData_(sh, row, headers, data) {
  if (!data) return;

  function normalizeHeaderKey_(s) {
    let t = String(s || '').toLowerCase().trim();
    t = t.replace(/[áàäâ]/g, 'a').replace(/[éèëê]/g, 'e').replace(/[íìïî]/g, 'i')
         .replace(/[óòöô]/g, 'o').replace(/[úùüû]/g, 'u').replace(/ñ/g, 'n');
    return t.replace(/\s+/g, ' ');
  }

  function colIndex_(name) {
    const target = normalizeHeaderKey_(name || '');
    for (let i = 0; i < headers.length; i++) {
      if (normalizeHeaderKey_(headers[i]) === target) return i + 1;
    }
    return 0;
  }

  function cleanValue_(v) {
    if (v == null) return '';
    let t = String(v).trim();
    if (!t || t === '????' || /^dato no disponible$/i.test(t)) return '';
    return t;
  }

  function writeIfEmpty_(colName, value) {
    const col = colIndex_(colName);
    const v = cleanValue_(value);
    if (!col || !v) return;
    const rng = sh.getRange(row, col);
    if (!String(rng.getValue() || '').trim()) rng.setValue(v);
  }

  function anchorsToText_(arr) {
    return (Array.isArray(arr) ? arr : [])
      .map(a => (a && a.text) ? String(a.text) : '').filter(Boolean).join(', ');
  }

  writeIfEmpty_('AÑO', data.anio);
  writeIfEmpty_('PUNTUACIÓN', data.ratingDisplay);
  writeIfEmpty_('PUNTUACION', data.ratingDisplay);
  writeIfEmpty_('GÉNERO', anchorsToText_(data.generoAnchors));
  writeIfEmpty_('GENERO', anchorsToText_(data.generoAnchors));
  writeIfEmpty_('SUBGÉNERO', anchorsToText_(data.subgeneroAnchors));
  writeIfEmpty_('SUBGENERO', anchorsToText_(data.subgeneroAnchors));
  writeIfEmpty_('PUBLISHER', anchorsToText_(data.publisherAnchors));
  writeIfEmpty_('DESARROLLO', anchorsToText_(data.desarrolladorAnchors));
  writeIfEmpty_('DESARROLLADOR', anchorsToText_(data.desarrolladorAnchors));
  writeIfEmpty_('JUGADORES', anchorsToText_(data.jugadoresAnchors));
  writeIfEmpty_('CARÁTULA', data.caratula);
  writeIfEmpty_('CARATULA', data.caratula);
  writeIfEmpty_('SCREENSHOTS', Array.isArray(data.screenshots) ? data.screenshots.join(', ') : '');
  writeIfEmpty_('SINOPSIS', data.sinopsis);
  writeIfEmpty_('VIDEO', data.video);
  writeIfEmpty_('ARGUMENTO', data.argumento);
}

// ============================================
// IDs GENÉRICOS POR PLATFORM_KEY
// ============================================

function menuRellenarIdFilaActual() {
  const ss = SpreadsheetApp.getActive();
  const shActiva = ss.getActiveSheet();
  const nombreHoja = shActiva ? shActiva.getName().trim() : '';
  
  const cfg = getPlatformConfigByDataSheet_(nombreHoja);
  
  if (cfg && cfg.sourceType === 'IGDB') {
    return rellenarIdIGDBFilaActual_(shActiva, cfg.platformKey);
  }
  
  if (nombreHoja.toUpperCase() === 'ZX_SPECTRUM') {
    return rellenarIdsZXLista();
  }
  
  if (nombreHoja.toUpperCase().includes('PS3')) {
    return rellenarIdIGDBFilaActual_(shActiva, 'PS3');
  }
  
  uiAlert_('No se puede generar ID para "' + nombreHoja + '".');
}

function rellenarIdIGDBFilaActual_(sh, platformKey) {
  const activeCell = sh.getActiveCell();
  const row = activeCell ? activeCell.getRow() : 0;

  if (!row || row === 1) {
    return uiAlert_('Selecciona una fila con datos (no la cabecera).');
  }

  const headers = sh.getRange(1, 1, 1, Math.max(1, sh.getLastColumn())).getValues()[0];
  const colIdIndex = headers.indexOf('ID');

  if (colIdIndex === -1) {
    return uiAlert_('No se encontró la columna "ID".');
  }

  const colId = colIdIndex + 1;
  const numRows = Math.max(0, sh.getLastRow() - 1);
  let ids = numRows > 0 ? sh.getRange(2, colId, numRows, 1).getValues() : [];

  const prefix = platformKey + '_';
  let ultimoNumero = 0;

  for (let i = 0; i < ids.length; i++) {
    const val = String(ids[i][0] || '').trim();
    if (val.startsWith(prefix)) {
      const match = val.match(/(\d+)$/);
      if (match) {
        const num = parseInt(match[1], 10);
        if (num > ultimoNumero) ultimoNumero = num;
      }
    }
  }

  const currentId = String(sh.getRange(row, colId).getValue() || '').trim();
  if (currentId) {
    return uiAlert_('La fila ya tiene ID: ' + currentId);
  }
  
  const nuevoId = prefix + String(ultimoNumero + 1).padStart(4, '0');
  sh.getRange(row, colId).setValue(nuevoId);
  Logger.log('[ID] Nuevo ID: ' + nuevoId);
}

// ============================================
// NUEVA FUNCIÓN onOpen() - REEMPLAZA LA EXISTENTE
// ============================================

function onOpen() {
  const ui = SpreadsheetApp.getUi();
  
  // Menú 1: ID
  ui.createMenu('ID')
    .addItem('Rellenar ID (fila actual)', 'menuRellenarIdFilaActual')
    .addToUi();
  
  // Menú 2: ZX SP (antes era "Fichas")
  ui.createMenu('ZX SP')
    .addItem('Vista previa de ficha (fila actual)', 'menuPreviewFichaActual')
    .addToUi();
    
  // Menú 3: IGDB
  ui.createMenu('IGDB')
    .addItem('Actualizar desde IGDB (fila actual)', 'menuActualizarFilaActual')
    .addToUi();
}


// ============================================
// FIN DEL BLOQUE NUEVO v3.0
// ============================================


// ============================================
// FUNCIÓN PRINCIPAL - PREVIEW DE FICHA
// ============================================

function menuPreviewFichaActual() {
  const ui = SpreadsheetApp.getUi();
  const sh = SpreadsheetApp.getActiveSheet();
  const row = sh.getActiveCell() ? sh.getActiveCell().getRow() : 0;
  
  // Validaciones básicas
  if (!row || row === 1) {
    return uiAlert_('Selecciona una fila con datos (no la cabecera).');
  }

  const headers = sh.getRange(1, 1, 1, Math.max(1, sh.getLastColumn())).getValues()[0];
  
  // Función auxiliar para normalizar texto (quitar acentos, espacios extra)
  const normalizeHeader = (s) => {
    return String(s || '').trim().toUpperCase()
      .normalize('NFD').replace(/[\u0300-\u036f]/g, '') // quitar acentos
      .replace(/\s+/g, '_'); // espacios a guiones bajos
  };
  
  const get = (h) => {
    // Primero buscar coincidencia exacta
    let i = headers.indexOf(h);
    if (i > -1) return sh.getRange(row, i + 1).getValue();
    
    // Si no, buscar coincidencia normalizada
    const hNorm = normalizeHeader(h);
    for (let j = 0; j < headers.length; j++) {
      if (normalizeHeader(headers[j]) === hNorm) {
        return sh.getRange(row, j + 1).getValue();
      }
    }
    return '';
  };

  // ===============================
  // DETECTAR PLATAFORMA
  // ===============================
  const sheetName = sh.getName().trim().toUpperCase();
const isPS3 = sheetName.includes('PS3');

// ====================================
// FLUJO PS3 (IGDB)
// ====================================
if (isPS3) {
  const titulo = get('TÍTULO') || get('TITULO');
  if (!titulo) return uiAlert_('Falta el campo "TÍTULO" / "TITULO" en la fila.');

  // LINK IGDB (opcional, pero si existe, manda él)
  const linkPS3 = get('IGDB_URL') || '';

  // Año de la hoja (si la cabecera es "AÑO")
  const anioHoja = String(get('AÑO') || '').trim();

  // ====================================
  // LEER COLUMNAS MANUALES (NO SE TOCAN AL SCRAPEAR)
  // ====================================
  const columnasManualPS3 = {
    ubicacion: String(get('PS3_UBICACION') || '').trim(),
    tipoFormato: String(get('PS3_TIPO_FORMATO') || '').trim(),
    favorito: String(get('FAVORITO') || '').trim(),
    terminado: String(get('TERMINADO') || '').trim(),
    masInfo: String(get('MAS_INFO') || '')
  };

  Logger.log('[PS3] MAS_INFO leído (longitud=' + columnasManualPS3.masInfo.length + ')');

  // Leer VIDEO existente en la hoja
  const videoHojaPS3 = String(get('VIDEO') || '').trim();
  
  // Leer ARGUMENTO existente en la hoja
  const argumentoHojaPS3 = String(get('ARGUMENTO') || '');
  
  // Leer SINOPSIS existente en la hoja
  const sinopsisHojaPS3 = String(get('SINOPSIS') || '');

  // ====================================
  // v2.1: LEER TODAS LAS COLUMNAS PARA RESPETAR CONTENIDO EXISTENTE
  // ====================================
  const caratulaHojaPS3 = String(get('CARÁTULA') || get('CARATULA') || '').trim();
  const screenshotsHojaPS3 = String(get('SCREENSHOTS') || '').trim();
  const anioHojaPS3_existente = String(get('AÑO') || '').trim();
  const generoHojaPS3 = String(get('GÉNERO') || get('GENERO') || '').trim();
  const subgeneroHojaPS3 = String(get('SUBGÉNERO') || get('SUBGENERO') || '').trim();
  const publisherHojaPS3 = String(get('PUBLISHER') || '').trim();
  const desarrolladorHojaPS3 = String(get('DESARROLLADOR') || '').trim();
  const jugadoresHojaPS3 = String(get('JUGADORES') || '').trim();
  const controlesHojaPS3 = String(get('CONTROLES') || '').trim();
  const versionHojaPS3 = String(get('VERSIÓN') || get('VERSION') || '').trim();
  const distribuidorasHojaPS3 = String(get('DISTRIBUIDORAS') || '').trim();
  const puntuacionHojaPS3 = String(get('PUNTUACIÓN') || get('PUNTUACION') || '').trim();

  Logger.log('[PS3] Título: ' + titulo + ' | LINK: ' + linkPS3 + ' | AÑO hoja: ' + anioHoja);
  Logger.log('[PS3] Carátula existente en hoja: ' + (caratulaHojaPS3 ? 'SÍ (' + caratulaHojaPS3.substring(0,50) + '...)' : 'NO'));

  // Obtener datos de IGDB
  const dataPS3 = fetchPS3_fromIGDB_(titulo, linkPS3, anioHoja);

  // ====================================
  // v2.1: RESPETAR TODOS LOS VALORES EXISTENTES EN LA HOJA
  // ====================================
  
  // VIDEO: respetar si ya existe
  if (videoHojaPS3) {
    dataPS3.video = videoHojaPS3;
    Logger.log('[PS3] Video manual respetado');
  }
  
  // CARÁTULA: respetar si ya existe
  if (caratulaHojaPS3) {
    dataPS3.caratula = caratulaHojaPS3;
    Logger.log('[PS3] Carátula manual respetada: ' + caratulaHojaPS3);
  }
  
  // SCREENSHOTS: respetar si ya existen
  if (screenshotsHojaPS3) {
    dataPS3.screenshots = screenshotsHojaPS3.split(',').map(s => s.trim()).filter(Boolean);
    Logger.log('[PS3] Screenshots manuales respetados');
  }
  
  // AÑO: respetar si ya existe
  if (anioHojaPS3_existente) {
    dataPS3.anio = anioHojaPS3_existente;
    Logger.log('[PS3] Año manual respetado: ' + anioHojaPS3_existente);
  }
  
  // GÉNERO: respetar si ya existe
  if (generoHojaPS3) {
    dataPS3.generoAnchors = [{text: generoHojaPS3, href: ''}];
    Logger.log('[PS3] Género manual respetado');
  }
  
  // SUBGÉNERO: respetar si ya existe
  if (subgeneroHojaPS3) {
    dataPS3.subgeneroAnchors = [{text: subgeneroHojaPS3, href: ''}];
    Logger.log('[PS3] Subgénero manual respetado');
  }
  
  // PUBLISHER: respetar si ya existe
  if (publisherHojaPS3) {
    dataPS3.publisherAnchors = [{text: publisherHojaPS3, href: ''}];
    Logger.log('[PS3] Publisher manual respetado');
  }
  
  // DESARROLLADOR: respetar si ya existe
  if (desarrolladorHojaPS3) {
    dataPS3.desarrolladorAnchors = [{text: desarrolladorHojaPS3, href: ''}];
    Logger.log('[PS3] Desarrollador manual respetado');
  }
  
  // JUGADORES: respetar si ya existe
  if (jugadoresHojaPS3) {
    dataPS3.jugadoresAnchors = [{text: jugadoresHojaPS3, href: ''}];
    Logger.log('[PS3] Jugadores manual respetado');
  }
  
  // CONTROLES: respetar si ya existe
  if (controlesHojaPS3) {
    dataPS3.controlesAnchors = [{text: controlesHojaPS3, href: ''}];
    Logger.log('[PS3] Controles manual respetado');
  }
  
  // VERSIÓN: respetar si ya existe
  if (versionHojaPS3) {
    dataPS3.versionAnchors = [{text: versionHojaPS3, href: ''}];
    Logger.log('[PS3] Versión manual respetada');
  }
  
  // DISTRIBUIDORAS: respetar si ya existe
  if (distribuidorasHojaPS3) {
    dataPS3.distribuidorasAnchors = [{text: distribuidorasHojaPS3, href: ''}];
    Logger.log('[PS3] Distribuidoras manual respetado');
  }
  
  // PUNTUACIÓN: respetar si ya existe
  if (puntuacionHojaPS3) {
    dataPS3.ratingDisplay = puntuacionHojaPS3;
    Logger.log('[PS3] Puntuación manual respetada');
  }
  
  // ====================================
  // SINOPSIS: traducir si viene de IGDB y la hoja está vacía
  // ====================================
  if (sinopsisHojaPS3.trim()) {
    dataPS3.sinopsis = sinopsisHojaPS3;
    Logger.log('[PS3] Sinopsis manual respetada');
  } else if (dataPS3.sinopsis && dataPS3.sinopsis.trim()) {
    Logger.log('[PS3] Traduciendo sinopsis de IGDB...');
    dataPS3.sinopsis = translateTextToSpanish_(dataPS3.sinopsis);
  }
  
  // ====================================
  // ARGUMENTO: traducir si viene de IGDB y la hoja está vacía
  // ====================================
  if (argumentoHojaPS3.trim()) {
    dataPS3.argumento = argumentoHojaPS3;
    Logger.log('[PS3] Argumento manual respetado');
  } else if (dataPS3.argumento && dataPS3.argumento.trim()) {
    Logger.log('[PS3] Traduciendo argumento de IGDB...');
    dataPS3.argumento = translateTextToSpanish_(dataPS3.argumento);
  }

  // Datos técnicos para PS3
  const tecnicosPS3 = {
    ubicacion: columnasManualPS3.ubicacion,
    tipoFormato: columnasManualPS3.tipoFormato,
    favorito: columnasManualPS3.favorito,
    terminado: columnasManualPS3.terminado,
    masInfo: columnasManualPS3.masInfo,
    formato: '',
    zx2a: '',
    tspec: ''
  };

  writeBackPS3RowFromData_(sh, row, headers, dataPS3);

  const html = buildPreviewHtml_(titulo, 'PlayStation 3', linkPS3, dataPS3, tecnicosPS3, dataPS3.sinopsis);
  SpreadsheetApp.getUi().showSidebar(HtmlService.createHtmlOutput(html).setTitle('Ficha PS3'));
  return;
}


  // ===============================
  // FLUJO ORIGINAL ZX SPECTRUM
  // (copiado tal cual de tu script estable)
  // ===============================
  // ====================================
  // FLUJO COMMODORE 64 (LEMON64)
  // ====================================
  const isC64 = /c64|commodore.*64/i.test(sh.getName());
  
  if (isC64) {
    const titulo = get('TÍTULO') || get('TITULO');
    
    if (!titulo) return uiAlert_('Falta el campo "TÍTULO" en la fila.');

    const link = get('LINK');
    if (!link) return uiAlert_('Falta el campo "LINK".');

    // ====================================
    // LEER DATOS TÉCNICOS DESDE LA HOJA
    // ====================================
    const tecnicos = {
      formato: String(get('FORMATO') || '').trim(),
      funciona: String(get('FUNCIONA') || '').trim(),
      favorito: String(get('FAVORITO') || '').trim(),
      terminado: String(get('TERMINADO') || '').trim(),
      // Campos no usados en C64 (compatibilidad con buildPreviewHtml_)
      zx2a: '',
      tspec: '',
      ubicacion: '',
      tipoFormato: '',
      masInfo: ''
    };

    // ====================================
    // LEER OVERRIDES MANUALES DESDE LA HOJA
    // ====================================
    const overrides = {
      caratula: String(get('CARÁTULA') || get('CARATULA') || '').trim(),
      anio: String(get('AÑO') || get('ANO') || '').trim(),
      publisher: String(get('PUBLISHER') || '').trim(),
      desarrollador: String(get('DESARROLLADOR') || '').trim(),
      autores: String(get('AUTORES') || '').trim(),
      video: String(get('VIDEO') || '').trim(),
      genero: String(get('GÉNERO') || get('GENERO') || '').trim(),
      subgenero: String(get('SUBGÉNERO') || get('SUBGENERO') || '').trim(),
      jugadores: String(get('JUGADORES') || '').trim(),
      controles: String(get('CONTROLES') || '').trim(),
      screenshots: String(get('SCREENSHOTS') || '').trim(),
      imagenesExtra: String(get('IMÁGENES') || get('IMAGENES') || '').trim(),
      instrucciones: String(get('INSTRUCCIONES') || '').trim(),
      puntuacion: String(get('PUNTUACIÓN') || get('PUNTUACION') || '').trim(),
      sinopsis: String(get('SINOPSIS') || '').trim(),
      revistas: String(get('REVISTAS') || '').trim()
    };

    // ====================================
    // SCRAPING DE LEMON64
    // ====================================
    Logger.log('[C64] Scrapeando: ' + titulo + ' | Link: ' + link);
    const data = fetchC64_fromLemon64_(titulo, link, overrides);
    
    // ====================================
    // PROCESAR IMÁGENES ADICIONALES
    // ====================================
    if (overrides.imagenesExtra) {
      const imagenesInput = overrides.imagenesExtra;
      const extraImages = getExtraImagesForGame(imagenesInput, data.caratula, data.screenshots);
      
      // Combinar con las auto-detectadas (sin duplicados)
      const allExtra = [...new Set([...(data.imagenesAdicionales || []), ...extraImages])];
      data.imagenesAdicionales = allExtra;
    }

    // ====================================
    // COMBINAR REVISTAS (AUTO + MANUAL)
    // ====================================
    const revistasUser = parseSheetRevistas_(overrides.revistas);
    if (Array.isArray(data.revistas)) {
      data.revistas = data.revistas.concat(revistasUser);
    } else {
      data.revistas = revistasUser;
    }

    // ====================================
    // FORMATEAR PUNTUACIÓN
    // ====================================
    if (!overrides.puntuacion && data.ratingScore10) {
      data.ratingDisplay = data.ratingScore10 + '/10';
    }

    // ====================================
    // SINOPSIS (usar override si existe)
    // ====================================
    let sinopsisText = overrides.sinopsis || data.sinopsis || '';

    // ====================================
    // ESCRIBIR DATOS EN LA HOJA (SOLO CELDAS VACÍAS)
    // ====================================
    writeBackC64RowFromData_(sh, row, headers, data, {
      sinopsis: sinopsisText
    });

    // ====================================
    // GENERAR Y MOSTRAR FICHA HTML
    // ====================================
    const html = buildPreviewHtml_(titulo, 'Commodore 64', link, data, tecnicos, sinopsisText);
    SpreadsheetApp.getUi()
      .showSidebar(HtmlService.createHtmlOutput(html).setTitle('Ficha C64'));
    
    Logger.log('[C64] Ficha generada exitosamente');
    return;
  }
  const isZX = /spectrum/i.test(sh.getName());
  const titulo = get('TÍTULO');
  
  if (!titulo) return uiAlert_('Falta el campo "TÍTULO" en la fila.');
  if (!isZX) return uiAlert_('Esta vista previa está pensada para la hoja "ZX Spectrum".');

  const link = get('LINK');
  if (!link) return uiAlert_('Falta el campo "LINK".');

  // ====================================
  // LEER DATOS TÉCNICOS DESDE LA HOJA
  // ====================================
  const tecnicos = {
    formato: String(get('FORMATO') || '').trim(),
    zx2a: String(get('ZX +2A') || '').trim(),
    tspec: String(get('TSPEC') || '').trim(),
    terminado: normalizarTerminado_(get('TERMINADO'))
  };

  // ====================================
  // LEER OVERRIDES MANUALES DESDE LA HOJA
  // ====================================
  const overrides = {
    caratula: String(get('CARÁTULA') || '').trim(),
    anio: String(get('AÑO') || '').trim(),
    publisher: String(get('PUBLISHER') || '').trim(),
    autor: String(get('AUTOR') || '').trim(),
    desarrollador: String(get('DESARROLLADOR') || '').trim(),
    video: String(get('VIDEO') || '').trim(),
    genero: String(get('GÉNERO') || '').trim(),
    subgenero: String(get('SUBGÉNERO') || '').trim(),
    contribuciones: String(get('CONTRIBUCIONES') || '').trim(),
    jugadores: String(get('JUGADORES') || '').trim(),
    controles: String(get('CONTROLES') || '').trim(),
    version: String(get('VERSIÓN') || get('VERSION') || '').trim(),
    distribuidoras: String(get('DISTRIBUIDORAS') || '').trim(),
    screenshots: String(get('SCREENSHOTS') || '').trim(),
    imagenesExtra: String(get('IMÁGENES') || get('IMAGENES') || '').trim(),
    mapa: String(get('MAPA') || '').trim(),
    instrucciones: String(get('INSTRUCCIONES') || '').trim(),
    puntuacion: String(get('PUNTUACIÓN') || get('PUNTUACION') || '').trim(),
    sinopsis: String(get('SINOPSIS') || '').trim(),
    revistas: String(get('REVISTAS') || '').trim()
  };

  // ====================================
  // SCRAPING DE SPECTRUM COMPUTING
  // ====================================
  const data = fetchZX_fromSpectrumComputing_(titulo, link, overrides.caratula);
  
  // Guardamos screenshots auto-detectados ANTES de aplicar overrides
  const autoScreens = Array.isArray(data.screenshots) ? data.screenshots.slice(0, 2) : [];

  // ====================================
  // APLICAR OVERRIDES MANUALES
  // ====================================
  aplicarOverrides_(data, overrides, link);

  // ====================================
  // OBTENER DESARROLLADOR DESDE ZXART
  // ====================================
  if (!overrides.desarrollador) {
    const zx = getDeveloperFromZXART_(titulo);
    if (zx && zx.text) {
      data.desarrolladorAnchors = splitByCommaToAnchors_(zx.text, link);
    }
  }

  // ====================================
  // OBTENER PUNTUACIÓN
  // ====================================
  if (overrides.puntuacion) {
    data.ratingDisplay = overrides.puntuacion;
  } else {
    data.ratingDisplay = formatRatingDisplay_(data.ratingScore10, data.ratingVotes);
  }

  // ====================================
  // OBTENER SINOPSIS (PRIORIDAD: HOJA > ZXART)
  // ====================================
  let sinopsisText = overrides.sinopsis || obtenerSinopsisZXArt_(titulo);

  // ====================================
  // PROCESAR IMÁGENES ADICIONALES
  // ====================================
  const imagenesInput = overrides.imagenesExtra || (data.imagenesAdicionales || []).join('\n');
  data.imagenesAdicionales = getExtraImagesForGame(imagenesInput, data.caratula, data.screenshots);

  // ====================================
  // COMBINAR REVISTAS (AUTO + MANUAL)
  // ====================================
  const revistasUser = parseSheetRevistas_(overrides.revistas);
  if (Array.isArray(data.revistas)) {
    data.revistas = data.revistas.concat(revistasUser);
  } else {
    data.revistas = revistasUser;
  }

  // ====================================
  // ESCRIBIR DATOS EN LA HOJA (SOLO CELDAS VACÍAS)
  // ====================================
  writeBackZXRowFromData_(sh, row, headers, data, {
    autoScreenshots: autoScreens,
    sinopsis: sinopsisText
  });

  // ====================================
  // GENERAR Y MOSTRAR FICHA HTML
  // ====================================
  const html = buildPreviewHtml_(titulo, 'ZX Spectrum', link, data, tecnicos, sinopsisText);
  SpreadsheetApp.getUi()
    .showSidebar(HtmlService.createHtmlOutput(html).setTitle('Ficha'));
}


  // Cierre de la función principal de menú


// ============================================
// HELPER: APLICAR OVERRIDES MANUALES
// ============================================

function aplicarOverrides_(data, overrides, link) {
  // Año
  if (overrides.anio) data.anio = overrides.anio;
  
  // Vídeo
  if (overrides.video) data.video = overrides.video;

  // Publisher (con normalización)
  if (overrides.publisher) {
    data.publisherAnchors = splitByCommaToAnchors_(overrides.publisher, link, 'Publisher')
      .map(a => ({ ...a, text: normalizePublisherName_(a.text) }));
  } else if (Array.isArray(data.publisherAnchors)) {
    data.publisherAnchors = data.publisherAnchors.map(a => ({ ...a, text: normalizePublisherName_(a.text) }));
  }

  // Autor
  if (overrides.autor) {
    data.autorAnchors = splitByCommaToAnchors_(overrides.autor, link);
  }

  // Desarrollador
  if (overrides.desarrollador) {
    data.desarrolladorAnchors = splitByCommaToAnchors_(overrides.desarrollador, link);
  }

  // Contribuciones
  if (overrides.contribuciones) {
    data.contributorsAnchors = splitByCommaToAnchors_(overrides.contribuciones, link);
  }

  // Género
  if (overrides.genero) {
    data.generoAnchors = splitByCommaToAnchors_(overrides.genero.replace(/;/g, ','), link);
  }

  // Subgénero
  if (overrides.subgenero) {
    data.subgeneroAnchors = splitByCommaToAnchors_(overrides.subgenero.replace(/;/g, ','), link);
  }

  // Jugadores
  if (overrides.jugadores) {
    data.jugadoresAnchors = splitByCommaToAnchors_(overrides.jugadores.replace(/;/g, ','), link, 'Maximum Players');
  }

  // Controles
  if (overrides.controles) {
    data.controlesAnchors = splitByCommaToAnchors_(overrides.controles.replace(/;/g, ','), link, 'Controls');
  }

  // Versión
  if (overrides.version) {
    data.versionAnchors = splitByCommaToAnchors_(overrides.version.replace(/;/g, ','), link, 'Machine Type');
  }

  // Distribuidoras
  if (overrides.distribuidoras) {
    data.distribuidorasAnchors = splitByCommaToAnchors_(overrides.distribuidoras.replace(/;/g, ','), link, 'Publisher');
  }

  // Mapa
  if (overrides.mapa) {
    data.mapa = overrides.mapa;
  }

  // Instrucciones
  if (overrides.instrucciones) {
    data.instrucciones = overrides.instrucciones;
  }

  // Screenshots (si el usuario pone algo manual, reemplaza los auto-detectados)
  if (overrides.screenshots) {
    const parts = overrides.screenshots.split(/\s*,\s*/).map(x => x.trim()).filter(Boolean);
    data.screenshots = parts.slice(0, 2);
  }
}

// ============================================
// HELPER: NORMALIZAR CAMPO "TERMINADO"
// ============================================

function normalizarTerminado_(valor) {
  const v = String(valor || '').trim();
  if (!v) return '';
  if (/^si$/i.test(v)) return 'SI';
  if (/^no$/i.test(v)) return 'NO';
  return v;
}

// ============================================
// HELPER: OBTENER SINOPSIS DESDE ZXART
// ============================================

function obtenerSinopsisZXArt_(titulo) {
  try {
    const zxSyn = getZXArtSynopsisTranslated_(titulo);
    if (zxSyn) {
      if (zxSyn.es && String(zxSyn.es).trim()) {
        return String(zxSyn.es).trim();
      } else if (zxSyn.en && String(zxSyn.en).trim()) {
        return String(zxSyn.en).trim();
      }
    }
  } catch (e) {
    Logger.log('[ERROR] obtenerSinopsisZXArt_: ' + e);
  }
  return 'Sinopsis no disponible en ZXArt.';
}

/**
 * ============================================
 * PARTE 2: SCRAPING SPECTRUM COMPUTING
 * ============================================
 * 
 * Extrae todos los datos desde SpectrumComputing.co.uk:
 * - Datos básicos (año, género, publisher, autor)
 * - Carátula (Inlay - Front)
 * - Screenshots (Loading + Running)
 * - Puntuación (User Score)
 * - Imágenes adicionales
 * - Instrucciones, mapa, vídeo
 * - Revistas (Magazine Reviews)
 * 
 * ============================================
 */

function fetchZX_fromSpectrumComputing_(titulo, link, coverManual) {
  try {
    const res = UrlFetchApp.fetch(link, { muteHttpExceptions: true });
    const html = res.getContentText();
    const data = {};

    // ====================================
    // HELPERS PARA EXTRAER DATOS DEL HTML
    // ====================================
    
    // Extrae texto plano de un campo
    const rowVal = (labels) => {
      const alts = (Array.isArray(labels) ? labels : [labels]).map(escapeRegex_).join('|');
      const patterns = [
        `<div\\s+class="col-sm-4">\\s*<b>\\s*(?:${alts})\\s*:?\\s*</b>\\s*</div>\\s*<div\\s+class="col-sm-8">([\\s\\S]*?)</div>`,
        `<dt[^>]*>\\s*(?:${alts})\\s*:?\\s*<\\/dt>\\s*<dd[^>]*>([\\s\\S]*?)<\\/dd>`,
        `<t[hd][^>]*>\\s*(?:${alts})\\s*:?\\s*<\\/t[hd]>\\s*<t[hd][^>]*>([\\s\\S]*?)<\\/t[hd]>`
      ];
      
      for (const pattern of patterns) {
        const m = new RegExp(pattern, 'i').exec(html);
        if (m) return stripTags_(m[1]).replace(/\s+/g, ' ').trim();
      }
      return '';
    };

    // Extrae HTML interno de un campo (con enlaces)
    const rowValHtml = (labels) => {
      const alts = (Array.isArray(labels) ? labels : [labels]).map(escapeRegex_).join('|');
      const patterns = [
        `<div\\s+class="col-sm-4">\\s*<b>\\s*(?:${alts})\\s*:?\\s*</b>\\s*</div>\\s*<div\\s+class="col-sm-8">([\\s\\S]*?)</div>`,
        `<dt[^>]*>\\s*(?:${alts})\\s*:?\\s*<\\/dt>\\s*<dd[^>]*>([\\s\\S]*?)<\\/dd>`,
        `<t[hd][^>]*>\\s*(?:${alts})\\s*:?\\s*<\\/t[hd]>\\s*<t[hd][^>]*>([\\s\\S]*?)<\\/t[hd]>`
      ];
      
      for (const pattern of patterns) {
        const m = new RegExp(pattern, 'i').exec(html);
        if (m) return m[1];
      }
      return '';
    };

    // ====================================
    // EXTRAER DATOS BÁSICOS
    // ====================================
    
    data.anio = rowVal(['Release Date', 'Release']);
    data.generoAnchors = parseAnchors_(rowValHtml('Genre'), link);
    
    // Themes / Subgénero
    let themesHtml = rowValHtml(['Themes?', 'Theme', 'Themes']);
    if (!themesHtml) themesHtml = findLabelBlock_(html, 'Themes?');
    data.subgeneroAnchors = parseAnchors_(themesHtml, link);

    // ====================================
    // PUBLISHER (CON NORMALIZACIÓN)
    // ====================================
    
    const pubHtml = rowValHtml(['Original Publisher', 'Original\\s*Publisher']);
    data.publisherAnchors = parseAnchors_(pubHtml, link);
    
    if (!data.publisherAnchors.length) {
      const pubText = rowVal(['Original Publisher', 'Original\\s*Publisher']);
      data.publisherAnchors = splitByCommaToAnchors_(pubText, link);
    }
    
    // Normalizar nombres de publishers
    data.publisherAnchors = data.publisherAnchors.map(a => ({
      ...a,
      text: normalizePublisherName_(a.text)
    }));

    // ====================================
    // AUTORES Y CONTRIBUCIONES
    // ====================================
    
    // Autores (Creators)
    data.autorAnchors = parseAnchors_(rowValHtml(['Creator', 'Creators']), link);
    if (!data.autorAnchors.length) {
      data.autorAnchors = splitByCommaToAnchors_(rowVal(['Creator', 'Creators']), link);
    }

    // Contribuciones (Contributors)
    data.contributorsAnchors = parseAnchors_(rowValHtml(['Contributor', 'Contributors']), link);
    if (!data.contributorsAnchors.length) {
      data.contributorsAnchors = splitByCommaToAnchors_(rowVal(['Contributor', 'Contributors']), link);
    }

    // ====================================
    // JUGADORES, CONTROLES, VERSIÓN
    // ====================================
    
    const jugadoresTxt = rowVal(['Maximum Players', 'Players', 'Max. Players', 'Number of Players']);
    data.jugadoresAnchors = splitByCommaToAnchors_(jugadoresTxt, link, 'Maximum Players');

    data.controlesAnchors = parseAnchors_(rowValHtml(['Controls?', 'Controls']), link);
    if (!data.controlesAnchors.length) {
      data.controlesAnchors = splitByCommaToAnchors_(rowVal(['Controls?', 'Controls']), link, 'Controls');
    }

    data.versionAnchors = splitByCommaToAnchors_(rowVal('Machine Type'), link, 'Machine Type');

    // ====================================
    // DISTRIBUIDORAS (RE-RELEASES)
    // ====================================
    
    data.releases = [];
    const reRe = /<div class="hidden-xs col-md-2">Re-release[^<]*<\/div>\s*<div class="col-sm-4 col-md-3">[\s\S]*?>([^<]+)<\/a>/ig;
    let rm;
    while ((rm = reRe.exec(html))) {
      data.releases.push(stripTags_(rm[1]).trim());
    }
    data.distribuidorasAnchors = splitByCommaToAnchors_(data.releases.join(', '), link, 'Publisher');

    // ====================================
    // PUNTUACIÓN (USER SCORE)
    // ====================================
    
    const scoreTxt = rowVal(['Score']);
    const votesTxt = rowVal(['Total votes', 'Votes']);
    
    if (scoreTxt) {
      const m = scoreTxt.replace(',', '.').match(/-?\d+(?:\.\d+)?/);
      if (m) data.ratingScore10 = parseFloat(m[0]);
    }
    
    if (votesTxt) {
      const m2 = votesTxt.match(/\d+/);
      if (m2) data.ratingVotes = parseInt(m2[0], 10);
    }

    // ====================================
    // CARÁTULA (INLAY - FRONT)
    // ====================================
    
    let autoCover = '';

    // Estrategia 1: <a href="URL.jpg">...<small>Inlay - Front</small>
    const pattern1 = /<a[^>]+href=["']([^"']+\.(?:jpg|jpeg|png|webp))["'][^>]*>[\s\S]*?<small>Inlay\s*-\s*Front<\/small>/i;
    const match1 = pattern1.exec(html);
    
    if (match1 && match1[1]) {
      autoCover = absolutize_(link, match1[1]);
    }

    // Estrategia 2: Loop por todos los <a> que contengan "Inlay - Front"
    if (!autoCover) {
      const linkRegex = /<a[^>]+href=["']([^"']+)["'][^>]*>([\s\S]*?)<\/a>/gi;
      let linkMatch;
      
      while ((linkMatch = linkRegex.exec(html)) !== null) {
        const href = linkMatch[1];
        const content = linkMatch[2];
        
        if (/Inlay\s*-\s*Front/i.test(content) && /\.(?:jpg|jpeg|png|webp|gif)$/i.test(href)) {
          autoCover = absolutize_(link, href);
          break;
        }
      }
    }

    // Prioridad: Manual > Auto > Fallback
    const manualTrim = String(coverManual || '').trim();
    if (manualTrim) {
      data.caratula = manualTrim;
    } else if (autoCover) {
      data.caratula = autoCover;
    } else {
      data.caratula = FALLBACK_COVER_URL;
    }

    // ====================================
    // SCREENSHOTS (LOADING + RUNNING)
    // ====================================
    
    const top2 = extractTopScreens_(html, link);
    data.screenshots = top2.slice(0, 2);

    // ====================================
    // IMÁGENES ADICIONALES
    // ====================================
    
    const addImgs = new Map();
    
    const pushAdditional = (u) => {
      if (!u) return;
      const abs = absolutize_(link, u);
      const imgSrc = scrToImg_(abs);
      const key = normalizeKey_(imgSrc);
      const isTop = (data.screenshots || []).some(s => normalizeKey_(s) === key);
      if (!isTop && !addImgs.has(key)) addImgs.set(key, imgSrc);
    };

    // Buscar en panel de Screenshots
    const shotsPanel = getPanel_(html, 'Screenshots');
    if (shotsPanel) {
      [...shotsPanel.matchAll(/<a[^>]+href=["']([^"']+)["'][^>]*>/ig)].forEach(m => pushAdditional(m[1]));
      [...shotsPanel.matchAll(/<img[^>]+src=["']([^"']+)["']/ig)].forEach(m => pushAdditional(m[1]));
    }

    // Buscar todas las imágenes .scr, .png, .jpg en el HTML
    [...html.matchAll(/<a[^>]+href=["']([^"']+\.(?:scr|png|jpe?g|webp|gif))["'][^>]*>/ig)]
      .forEach(m => pushAdditional(m[1]));
    
    data.imagenesAdicionales = Array.from(addImgs.values());

    // ====================================
    // INSTRUCCIONES (PDF O TXT)
    // ====================================
    
    const instPdf = /<a[^>]+href=["']([^"']+\.(?:pdf))["'][^>]*>[\s\S]*?<small>\s*Instructions\s*<\/small>/i.exec(html);
    const instTxt = /<a[^>]+href=["']([^"']+\.(?:txt))["'][^>]*>[\s\S]*?<small>\s*Instructions\s*<\/small>/i.exec(html);
    
    if (instPdf && instPdf[1]) {
      data.instrucciones = absolutize_(link, instPdf[1]);
    } else if (instTxt && instTxt[1]) {
      data.instrucciones = absolutize_(link, instTxt[1]);
    } else {
      data.instrucciones = '';
    }

    // ====================================
    // MAPA
    // ====================================
    
    const mapsPanel = getPanel_(html, 'Speccy\\s*Screenshot\\s*Maps');
    if (mapsPanel) {
      const m = /<a[^>]+href=["']([^"']+)["'][^>]*>/i.exec(mapsPanel);
      if (m && m[1]) {
        data.mapa = absolutize_(link, m[1]);
      } else {
        data.mapa = '';
      }
    } else {
      data.mapa = '';
    }

    // ====================================
    // VÍDEO (YOUTUBE)
    // ====================================
    
    const y1 = /<iframe[^>]+src=["']([^"']*youtube[^"']+)["']/i.exec(html);
    data.video = (y1 && y1[1]) ? y1[1] : '';

    // ====================================
    // REVISTAS (MAGAZINE REVIEWS)
    // ====================================
    
    data.revistas = extractSCMagazineReviewsFromHtml_(html);

    return data;
    
  } catch (e) {
    Logger.log('[ERROR] fetchZX_fromSpectrumComputing_: ' + e);
    return {};
  }
}

/**
 * ============================================
 * SCRAPING LEMON64 PARA COMMODORE 64
 * ============================================
 * 
 * Extrae datos desde Lemon64.com:
 * - Datos básicos (año, publisher, desarrollador, autores)
 * - Carátula (Front Cover)
 * - Screenshots (2 primeras)
 * - Imágenes adicionales (desde la 3ª)
 * - Puntuación (Score con imágenes)
 * - Género, tags, jugadores, controles
 * - Vídeo YouTube
 * - Revistas
 * - Instrucciones
 * 
 * ============================================
 */

function fetchC64_fromLemon64_(titulo, link, overrides) {
  try {
    const res = UrlFetchApp.fetch(link, { muteHttpExceptions: true });
    const html = res.getContentText();
    const data = {};

    // ====================================
    // HELPERS PARA EXTRAER DATOS
    // ====================================
    
    // Buscar fila por etiqueta (ej: "Developer:", "Year:")
    const findRow = (label) => {
      const escaped = label.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
      const pattern = `<td[^>]*class="[^"]*align-top[^"]*text-nowrap[^"]*"[^>]*>\\s*${escaped}\\s*:?\\s*</td>\\s*<td[^>]*class="[^"]*credits-data[^"]*"[^>]*>([\\s\\S]*?)</td>`;
      const m = new RegExp(pattern, 'i').exec(html);
      return m ? m[1] : '';
    };

    // ====================================
    // ID LEMON64
    // ====================================
    const idMatch = html.match(/Game ID:\s*(\d+)/i);
    data.idLemon64 = idMatch ? idMatch[1] : '';

    // ====================================
    // AÑO
    // ====================================
    const yearHtml = findRow('Year|Released');
    const yearMatch = yearHtml.match(/list_year=(\d{4})/);
    data.anio = yearMatch ? yearMatch[1] : '';

    // ====================================
    // PUBLISHER
    // ====================================
    const publisherHtml = findRow('Publisher');
    const pubAnchors = parseAnchors_(publisherHtml, link);
    data.publisherAnchors = pubAnchors.length ? pubAnchors : [];

    // ====================================
    // DESARROLLADOR
    // ====================================
    const devHtml = findRow('Developer');
    const devAnchors = parseAnchors_(devHtml, link);
    
    // Si no hay desarrollador, usar publisher
    data.desarrolladorAnchors = devAnchors.length 
      ? devAnchors 
      : (pubAnchors.length ? pubAnchors : []);

    // ====================================
    // AUTORES (con roles: Coder, Musician, etc.)
    // ====================================
    const autoresRegex = /<td[^>]*class="[^"]*align-top[^"]*text-nowrap[^"]*"[^>]*>\s*([^<:]+)\s*:\s*<\/td>\s*<td[^>]*class="[^"]*credits-data[^"]*"[^>]*>\s*<a[^>]+href=["'][^"']*list_individual[^"']*["'][^>]*>([^<]+)<\/a>/gi;
    const autores = [];
    let autorMatch;
    
    while ((autorMatch = autoresRegex.exec(html)) !== null) {
      const rol = stripTags_(autorMatch[1]).trim();
      const nombre = stripTags_(autorMatch[2]).trim();
      
      // Excluir roles que no son autores creativos
      const rolesExcluidos = /publisher|copyright|released|distributor/i;
      if (!rolesExcluidos.test(rol) && nombre) {
        autores.push(`${nombre} (${rol})`);
      }
    }
    
    data.autores = autores.join(', ');
    data.autorAnchors = autores.map(a => ({ text: a, href: '#' }));

    // ====================================
    // GÉNERO
    // ====================================
    const genreRegex = /<a[^>]+href=["'][^"']*list_genre=([^"'&]+)[^"']*["'][^>]*>([^<]+)<\/a>/gi;
    const genres = [];
    let genreMatch;
    
    while ((genreMatch = genreRegex.exec(html)) !== null) {
      const genreName = stripTags_(genreMatch[2]).trim();
      if (genreName) genres.push({ text: genreName, href: '#' });
    }
    
    data.generoAnchors = genres;

    // ====================================
    // SUBGÉNERO (Tags)
    // ====================================
    const tagRegex = /<a[^>]+href=["'][^"']*list_tag=([^"']+)["'][^>]*class=["'][^"']*game_tag[^"']*["'][^>]*>([^<]+)<\/a>/gi;
    const tags = [];
    let tagMatch;
    
    while ((tagMatch = tagRegex.exec(html)) !== null) {
      const tagName = stripTags_(tagMatch[2]).trim();
      if (tagName) tags.push({ text: tagName, href: '#' });
    }
    
    data.subgeneroAnchors = tags;

    // ====================================
    // JUGADORES (convertir a Single Player / Multiple Players)
    // ====================================
    const playersHtml = findRow('Players');
    const playersText = stripTags_(playersHtml).trim();
    const jugadores = [];
    
    if (playersText) {
      // Si contiene "1" (pero no 10, 11, etc.) → Single Player
      if (/\b1\b/.test(playersText) && !/1[0-9]/.test(playersText)) {
        jugadores.push('Single Player');
      }
      
      // Si contiene 2-9 o "simultaneous" → Multiple Players
      if (/[2-9]/.test(playersText) || /simultaneous/i.test(playersText)) {
        jugadores.push('Multiple Players');
      }
    }
    
    data.jugadoresAnchors = jugadores.map(j => ({ text: j, href: '#' }));

    // ====================================
    // CONTROLES
    // ====================================
    const controlHtml = findRow('Main Control');
    const controlText = stripTags_(controlHtml).trim();
    data.controlesAnchors = controlText ? [{ text: controlText, href: '#' }] : [];

    // ====================================
    // CARÁTULA (Front Cover scan)
    // ====================================
    let autoCover = '';
    const coverMatch = html.match(/<img[^>]+src=["']([^"']+)["'][^>]*alt=["'][^"']*Front Cover scan[^"']*["']/i);
    
    if (coverMatch && coverMatch[1]) {
      autoCover = coverMatch[1].startsWith('http') 
        ? coverMatch[1] 
        : 'https://www.lemon64.com' + coverMatch[1];
    }
    
    // Aplicar override manual si existe
    const manualCover = (overrides && overrides.caratula) ? String(overrides.caratula).trim() : '';
    data.caratula = manualCover || autoCover || FALLBACK_COVER_URL;

    // ====================================
    // SCREENSHOTS (primeras 2)
    // ====================================
    const screenshotRegex = /<a[^>]+class=["'][^"']*lslide[^"']*["'][^>]*>\s*<img[^>]+src=["']([^"']+)["'][^>]*alt=["'][^"']*screenshot[^"']*["']/gi;
    const allScreenshots = [];
    let screenMatch;
    
    while ((screenMatch = screenshotRegex.exec(html)) !== null) {
      let url = screenMatch[1];
      if (!url.startsWith('http')) {
        url = 'https://www.lemon64.com' + url;
      }
      allScreenshots.push(url);
    }
    
    // Eliminar duplicados (los clones del slider)
    const uniqueScreenshots = [...new Set(allScreenshots)];
    
    data.screenshots = uniqueScreenshots.slice(0, 2);
    data.imagenesAdicionales = uniqueScreenshots.slice(2);

    // ====================================
    // VIDEO (YouTube)
    // ====================================
    const videoMatch = html.match(/<a[^>]+href=["'](https?:\/\/(?:www\.)?youtube\.com\/watch\?v=[^"']+)["']/i);
    data.video = videoMatch ? videoMatch[1] : '';

    // ====================================
    // REVISTAS
    // ====================================
    data.revistas = extractLemon64MagazineReviews_(html);

    // ====================================
    // INSTRUCCIONES (primer documento)
    // ====================================
    const docMatch = html.match(/<a[^>]+href=["']([^"']*\/doc\/[^"']+)["']/i);
    if (docMatch && docMatch[1]) {
      data.instrucciones = docMatch[1].startsWith('http') 
        ? docMatch[1] 
        : 'https://www.lemon64.com' + docMatch[1];
    } else {
      data.instrucciones = '';
    }

    // ====================================
    // PUNTUACIÓN (extraer de imágenes PNG)
    // ====================================
    const scoreImgsRegex = /<div[^>]*class=["'][^"']*votes-score[^"']*["'][^>]*>([\s\S]*?)<\/div>/i;
    const scoreBlock = scoreImgsRegex.exec(html);
    
    if (scoreBlock && scoreBlock[1]) {
      const scoreHtml = scoreBlock[1];
      const imgRegex = /<img[^>]+src=["'][^"']*\/score\/([^"']+)\.png["']/gi;
      const digits = [];
      let imgMatch;
      
      while ((imgMatch = imgRegex.exec(scoreHtml)) !== null) {
        const filename = imgMatch[1];
        
        // Ignorar "score" y "score-2x"
        if (filename.includes('score')) continue;
        
        // Convertir "dot" en "."
        if (filename === 'dot') {
          digits.push('.');
        } else {
          // Números: "7" → "7"
          digits.push(filename);
        }
      }
      
      const scoreValue = digits.join('');
      data.ratingDisplay = scoreValue || '';
      
      // Intentar parsear como número
      const numScore = parseFloat(scoreValue);
      if (!isNaN(numScore)) {
        data.ratingScore10 = numScore;
      }
    } else {
      data.ratingDisplay = '';
    }

    // ====================================
    // APLICAR OVERRIDES MANUALES
    // ====================================
    if (overrides) {
      if (overrides.anio) data.anio = overrides.anio;
      if (overrides.video) data.video = overrides.video;
      if (overrides.genero) {
        data.generoAnchors = splitByCommaToAnchors_(overrides.genero, link);
      }
      if (overrides.subgenero) {
        data.subgeneroAnchors = splitByCommaToAnchors_(overrides.subgenero, link);
      }
      if (overrides.publisher) {
        data.publisherAnchors = splitByCommaToAnchors_(overrides.publisher, link);
      }
      if (overrides.desarrollador) {
        data.desarrolladorAnchors = splitByCommaToAnchors_(overrides.desarrollador, link);
      }
      if (overrides.autores) {
        data.autores = overrides.autores;
        data.autorAnchors = splitByCommaToAnchors_(overrides.autores, link);
      }
      if (overrides.jugadores) {
        data.jugadoresAnchors = splitByCommaToAnchors_(overrides.jugadores, link);
      }
      if (overrides.controles) {
        data.controlesAnchors = splitByCommaToAnchors_(overrides.controles, link);
      }
      if (overrides.screenshots) {
        const parts = overrides.screenshots.split(/\s*,\s*/).map(x => x.trim()).filter(Boolean);
        data.screenshots = parts.slice(0, 2);
        data.imagenesAdicionales = parts.slice(2);
      }
      if (overrides.imagenesExtra) {
        const extraUrls = overrides.imagenesExtra.split(/[\n,;]+/).map(s => s.trim()).filter(Boolean);
        data.imagenesAdicionales = [...new Set([...data.imagenesAdicionales, ...extraUrls])];
      }
      if (overrides.instrucciones) {
        data.instrucciones = overrides.instrucciones;
      }
      if (overrides.puntuacion) {
        data.ratingDisplay = overrides.puntuacion;
      }
    }

    // ====================================
    // CAMPOS VACÍOS/NO APLICABLES
    // ====================================
    data.contributorsAnchors = []; // No aplicable en C64
    data.versionAnchors = []; // No aplicable (todos son C64)
    data.distribuidorasAnchors = []; // No aplicable
    data.mapa = ''; // Lemon64 no tiene mapas
    data.sinopsis = ''; // Lemon64 no tiene sinopsis (se rellena manual)

    return data;

  } catch (e) {
    Logger.log('[ERROR] fetchC64_fromLemon64_: ' + e);
    return {};
  }
}

// ====================================
// HELPER: EXTRAER REVISTAS DE LEMON64
// ====================================

function extractLemon64MagazineReviews_(html) {
  const revistas = [];
  
  // Buscar tabla de revistas
  const magazineTableRegex = /<table[^>]*class=["'][^"']*table-common[^"']*table-stripes[^"']*["'][^>]*>([\s\S]*?)<\/table>/gi;
  let tableMatch;
  
  while ((tableMatch = magazineTableRegex.exec(html)) !== null) {
    const tableHtml = tableMatch[1];
    
    // Verificar que es la tabla de revistas (debe tener "Magazine" o enlaces a revistas)
    if (!/<strong>/.test(tableHtml) && !tableHtml.includes('magazine')) continue;
    
    // Extraer cada fila <tr>
    const rowRegex = /<tr[^>]*>([\s\S]*?)<\/tr>/gi;
    let rowMatch;
    
    while ((rowMatch = rowRegex.exec(tableHtml)) !== null) {
      const rowHtml = rowMatch[1];
      
      // Ignorar fila de promedio
      if (/average.*rating/i.test(rowHtml)) continue;
      
      // Extraer enlace y nombre de revista
      const linkMatch = rowHtml.match(/<a[^>]+href=["']([^"']+)["'][^>]*>\s*(?:<[^>]+>)*\s*<strong>([^<]+)<\/strong>/i);
      
      if (linkMatch) {
        const url = linkMatch[1];
        const nombre = stripTags_(linkMatch[2]).trim();
        
        // Extraer detalles adicionales (número, fecha)
        const fullText = stripTags_(rowHtml).replace(/\s+/g, ' ').trim();
        
        // Formato: "ACE No. 14 (nov 88), p61"
        const detailsMatch = fullText.match(/(?:No\.|Nº|Issue)?\s*\d+[^,]*(?:\([^)]+\))?[^,]*/i);
        const detalles = detailsMatch ? detailsMatch[0].trim() : '';
        
        revistas.push({
          mag: nombre,
          title: detalles || nombre,
          href: url.startsWith('http') ? url : 'https://www.lemon64.com' + url
        });
      }
    }
  }
  
  return revistas;
}

// ====================================
// HELPER: EXTRAER LOADING + RUNNING SCREENS
// ====================================

function extractTopScreens_(html, link) {
  const found = new Map();
  const re = /<a[^>]+href=["']([^"']+)["'][^>]*>\s*<div[^>]*>\s*<div[^>]*title=["'](Loading screen|Running screen)["'][^>]*><\/div>[\s\S]*?<\/div>\s*<\/a>/ig;
  let m;
  
  while ((m = re.exec(html))) {
    const href = absolutize_(link, m[1]);
    const key = /loading/i.test(m[2]) ? 'loading' : 'running';
    const existing = found.get(key);
    
    if (!existing) {
      found.set(key, href);
    } else if (isScr_(href) && !isScr_(existing)) {
      // Priorizar archivos .scr sobre otros formatos
      found.set(key, href);
    }
  }
  
  const list = [];
  ['loading', 'running'].forEach(k => {
    const u = found.get(k);
    if (u) list.push(scrToImg_(u));
  });
  
  return list;
}

// ====================================
// HELPER: PROCESAR IMÁGENES ADICIONALES
// ====================================

function getExtraImagesForGame(rawCellValue, caratulaUrl, screenshotUrls) {
  if (!rawCellValue) return [];
  
  // Separar URLs por saltos de línea, comas o punto y coma
  let urls = rawCellValue
    .split(/[\n,;]+/g)
    .map(s => s.trim())
    .filter(s => s.length > 0);

  // Filtrar solo URLs válidas de imágenes
  urls = urls.filter(url => 
    /^https?:\/\//i.test(url) && 
    /\.(jpg|jpeg|png|gif|webp|scr)$/i.test(url)
  );

  // Eliminar duplicados
  const seen = new Set();
  urls = urls.filter(url => {
    const key = url.toLowerCase().replace(/(\?|\#).*/, '');
    if (seen.has(key)) return false;
    seen.add(key);
    return true;
  });

  // Excluir la carátula
  if (caratulaUrl) {
    const cKey = caratulaUrl.toLowerCase().replace(/(\?|\#).*/, '');
    urls = urls.filter(url => url.toLowerCase().replace(/(\?|\#).*/, '') !== cKey);
  }

  // Excluir screenshots principales
  if (Array.isArray(screenshotUrls)) {
    const sKeys = screenshotUrls.map(s => s.toLowerCase().replace(/(\?|\#).*/, ''));
    urls = urls.filter(url => !sKeys.includes(url.toLowerCase().replace(/(\?|\#).*/, '')));
  }

  // Limitar a 40 imágenes máximo
  if (urls.length > 40) urls = urls.slice(0, 40);
  
  return urls;
}

/**
 * ============================================
 * PARTE 3: SCRAPING DE REVISTAS
 * ============================================
 * 
 * Extrae información de revistas desde dos fuentes:
 * 1. SpectrumComputing (Magazine Reviews) - Automático
 * 2. Columna REVISTAS de la hoja - Manual
 * 
 * Formato de salida:
 * { mag: "CRASH", title: "Nº48 (1985/Oct).", href: "URL" }
 * 
 * ============================================
 */

// ====================================
// REVISTAS DESDE SPECTRUM COMPUTING
// ====================================

function extractSCMagazineReviewsFromHtml_(html) {
  if (!html) return [];

  const block = extractMagazineReviewsBlock_(html);
  if (!block) return [];

  const reviewsRaw = extractMagazineReviewsFromBlock_(block);
  if (!reviewsRaw || !reviewsRaw.length) return [];

  const out = [];
  for (const r of reviewsRaw) {
    if (!r) continue;
    
    const revista = String(r.revista || '').trim();
    const href = String(r.enlace || '').trim();
    const label = formatReviewLabelForFicha_(r);
    
    if (revista && href && label) {
      out.push({
        mag: revista,      // "Sinclair User"
        title: label,      // "Nº55 (1986/Oct)."
        href: href         // URL al PDF/VIEW
      });
    }
  }
  
  return out;
}

// ====================================
// EXTRAER BLOQUE "MAGAZINE REVIEWS"
// ====================================

function extractMagazineReviewsBlock_(html) {
  const markerStart = "Magazine Reviews";
  const startIdx = html.indexOf(markerStart);
  
  if (startIdx < 0) return null;

  // Buscar dónde termina el bloque (siguiente sección)
  const endMarkers = [
    "Magazine References",
    "Magazine Advertisements",
    "Related Magazine References",
    "Magazine related titles",
    "Scrapped File Downloads"
  ];
  
  let endIdx = html.length;
  endMarkers.forEach(m => {
    const idx = html.indexOf(m, startIdx + markerStart.length);
    if (idx > 0 && idx < endIdx) endIdx = idx;
  });

  return html.substring(startIdx, endIdx);
}

// ====================================
// EXTRAER FILAS DE REVISTAS
// ====================================

function extractMagazineReviewsFromBlock_(block) {
  const results = [];
  
  // Localizar todas las filas <div class="row zxdb_stripes">
  const rowOpenRegex = /<div[^>]*class="[^"]*\brow\b[^"]*\bzxdb_stripes\b[^"]*"[^>]*>/gi;
  const rowStarts = [];
  let m;
  
  while ((m = rowOpenRegex.exec(block)) !== null) {
    rowStarts.push(m.index);
  }

  // Procesar cada fila
  for (let i = 0; i < rowStarts.length; i++) {
    const start = rowStarts[i];
    const end = (i + 1 < rowStarts.length) ? rowStarts[i + 1] : block.length;
    const rowHtml = block.substring(start, end);

    // Extraer columnas <div class="...col-md-X...">
    const cols = [];
    const colRegex = /<div[^>]*class="[^"]*col-md-[^"]*"[^>]*>([\s\S]*?)<\/div>/gi;
    let colMatch;
    
    while ((colMatch = colRegex.exec(rowHtml)) !== null) {
      cols.push(colMatch[1]);
    }

    // Necesitamos al menos 4 columnas: Magazine, Issue, Page, Type
    if (cols.length < 4) continue;

    // Columna 1: Revista
    const revista = cleanupText_(stripTags_(cols[0]));

    // Columna 2: Issue + Fecha (formato: "#55 - 1986/Oct")
    const rawIssue = cleanupText_(stripTags_(cols[1]));
    let issue = "", fecha = "";
    
    if (rawIssue) {
      const parts = rawIssue.split(" - ");
      if (parts.length >= 2) {
        issue = parts[0].trim();
        fecha = parts.slice(1).join(" - ").trim();
      } else {
        issue = rawIssue;
      }
    }

    // Columna 3: Página
    const pageCellHtml = cols[2];
    const pageText = cleanupText_(stripTags_(pageCellHtml));
    const firstNumMatch = pageText.match(/\d+(?:-\d+)?/);
    const pagina = firstNumMatch ? firstNumMatch[0] : pageText;

    // Columna 4: Tipo (Review, Preview, etc.)
    const tipo = cleanupText_(stripTags_(cols[3]));

    // Columna 5 (opcional): Score
    const score = cols.length >= 5 ? cleanupText_(stripTags_(cols[4])) : "";

    // Extraer enlace PDF/VIEW desde la celda de página
    let enlace = "";
    const linkMatch = pageCellHtml.match(/href="([^"]+)"/i);
    if (linkMatch && linkMatch[1]) {
      const href = linkMatch[1];
      enlace = /^https?:\/\//i.test(href) 
        ? href 
        : "https://spectrumcomputing.co.uk" + href;
    }

    results.push({
      revista: revista,
      issue: issue,
      fecha: fecha,
      pagina: pagina,
      tipo: tipo,
      score: score,
      enlace: enlace
    });
  }

  return results;
}

// ====================================
// FORMATEAR LABEL PARA LA FICHA
// ====================================

function formatReviewLabelForFicha_(r) {
  if (!r) return "";
  
  const issue = String(r.issue || "").trim();
  const fecha = String(r.fecha || "").trim();
  
  // Extraer solo el número del issue (ej: "#48" → "48")
  const num = issue.match(/\d+/);
  const parts = [];
  
  if (num) parts.push("Nº" + num[0]);
  if (fecha) parts.push("(" + fecha + ")");
  
  let label = parts.join(" ");
  if (label && !label.endsWith(".")) label += ".";
  
  return label.trim();
}

// ====================================
// REVISTAS DESDE LA HOJA (MANUAL)
// ====================================

function parseSheetRevistas_(cellText) {
  const s = String(cellText || '').trim();
  if (!s) return [];
  
  // Separar por saltos de línea o punto y coma
  const items = s.split(/\n|;/).map(x => String(x).trim()).filter(Boolean);
  const out = [];
  
  // Detectar nombre de revista desde texto o URL
  const detectMag = (txt, url) => {
    const hay = (re) => re.test(txt) || re.test(url);
    
    if (hay(/\bcrash\b/i)) return 'CRASH';
    if (hay(/sinclair\s*user/i)) return 'SINCLAIR USER';
    if (hay(/your\s*computer/i)) return 'YOUR COMPUTER';
    if (hay(/your\s*spectrum/i)) return 'YOUR SPECTRUM';
    if (hay(/(?:micro\s*hobby|microhobby)/i)) return 'MICROHOBBY';
    if (hay(/microman[ií]a/i)) return 'MICROMANÍA';
    
    // Si no coincide con ninguna conocida, usar el dominio
    try {
      const h = (new URL(url)).hostname.replace(/^www\./, '');
      return h.toUpperCase();
    } catch (_) {
      return 'REVISTA';
    }
  };

  // Parsear cada línea
  for (const it of items) {
    let label = '', url = '';
    
    // Formato 1: [texto](URL)
    let m = it.match(/\[([^\]]+)\]\((https?:\/\/[^\s)]+)\)/i);
    if (m) {
      label = m[1].trim();
      url = m[2].trim();
    } else {
      // Formato 2: texto | URL
      m = it.match(/^(.+?)\|\s*(https?:\/\/\S+)/i);
      if (m) {
        label = m[1].trim();
        url = m[2].trim();
      } else {
        // Formato 3: solo URL (o texto + URL sin separador claro)
        m = it.match(/(https?:\/\/\S+)/i);
        if (m) {
          url = m[1];
          label = it.replace(m[1], '').trim() || m[1];
        }
      }
    }
    
    if (!url) continue;
    
    const mag = detectMag(label, url);
    out.push({
      mag: mag,
      title: label || url,
      href: url
    });
  }
  
  return out;
}

// ====================================
// HELPER: LIMPIAR TEXTO
// ====================================

function cleanupText_(s) {
  return String(s || "")
    .replace(/&nbsp;/gi, " ")
    .replace(/\s+/g, " ")
    .trim();
}

/**
 * ============================================
 * PARTE 4: SCRAPING ZXART
 * ============================================
 * 
 * Extrae dos datos principales desde ZXArt.ee:
 * 1. Desarrollador (campo "Produced by")
 * 2. Sinopsis (traducida de EN a ES)
 * 
 * Estrategias de búsqueda (en orden):
 * - API de ZXArt
 * - Búsqueda web en el sitio
 * - Slug heurístico
 * 
 * ============================================
 */

// ====================================
// OBTENER DESARROLLADOR DESDE ZXART
// ====================================

function getDeveloperFromZXART_(title) {
  try {
    const q = String(title || '').trim();

    // ESTRATEGIA 1: API de ZXArt
    const apiSearchUrl = `https://zxart.ee/api/search/software?query=${encodeURIComponent(q)}`;
    const searchRes = UrlFetchApp.fetch(apiSearchUrl, { muteHttpExceptions: true });
    
    if (searchRes.getResponseCode() === 200) {
      let hits = [];
      try {
        hits = JSON.parse(searchRes.getContentText());
      } catch (_) {}
      
      if (Array.isArray(hits) && hits.length > 0 && hits[0] && hits[0].id) {
        const dataUrl = `https://zxart.ee/api/software/${hits[0].id}`;
        const dataRes = UrlFetchApp.fetch(dataUrl, { muteHttpExceptions: true });
        
        if (dataRes.getResponseCode() === 200) {
          try {
            const j = JSON.parse(dataRes.getContentText());
            const raw = (j && (j.producedBy || j.productedBy || j.producer || j.author)) || "";
            const text = normalizeProducedBy_(raw);
            if (text) return { text, source: 'zxart_api' };
          } catch (_) {}
        }
      }
    }

    // ESTRATEGIA 2: Búsqueda web en ZXArt
    const webResults = findZxartSoftwarePage_(q);
    if (webResults && webResults.url) {
      const text = fetchZxartProducedByFromPage_(webResults.url);
      if (text) return { text, source: 'zxart_web' };
    }

    // ESTRATEGIA 3: Slug heurístico
    const slug = makeZxartSlug_(q);
    const guessUrl = `https://zxart.ee/eng/software/games/${slug}/`;
    const text3 = fetchZxartProducedByFromPage_(guessUrl);
    if (text3) return { text: text3, source: 'zxart_slug' };

    return { text: "", source: 'none' };
    
  } catch (e) {
    Logger.log('[ERROR] getDeveloperFromZXART_: ' + e);
    return { text: "", source: 'error' };
  }
}

// ====================================
// BUSCAR PÁGINA DE SOFTWARE EN ZXART (WEB)
// ====================================

function findZxartSoftwarePage_(title) {
  try {
    const q = String(title || '').trim();
    const searchUrl = `https://zxart.ee/eng/search/?form=software&query=${encodeURIComponent(q)}`;
    const res = UrlFetchApp.fetch(searchUrl, { muteHttpExceptions: true });
    
    if (res.getResponseCode() !== 200) return null;
    
    const html = res.getContentText();
    const m = html.match(/href=["'](\/eng\/software\/[^"']+)["']/i);
    
    if (m && m[1]) {
      const url = `https://zxart.ee${m[1]}`.replace(/([^:])\/{2,}/g, '$1/').replace('https:/', 'https://');
      return { url, via: 'web_search' };
    }
    
    return null;
  } catch (_) {
    return null;
  }
}

// ====================================
// EXTRAER "PRODUCED BY" DE UNA PÁGINA ZXART
// ====================================

function fetchZxartProducedByFromPage_(url) {
  try {
    const res = UrlFetchApp.fetch(url, { muteHttpExceptions: true });
    if (res.getResponseCode() !== 200) return "";
    
    const html = res.getContentText();
    
    // Buscar el campo "Produced by"
    let cell = findLabelBlock_(html, 'Produced\\s*by');
    if (!cell) cell = findLabelBlock_(html, 'Producido\\s*por');

    if (!cell) {
      const re = /Produced\s*by\s*:<\/[^>]+>\s*<[^>]+>([\s\S]*?)<\/[^>]+>/i;
      const m = re.exec(html);
      if (m) cell = m[1];
    }

    if (!cell) {
      const m2 = /<td[^>]*>\s*Produced\s*by\s*:\s*<\/td>\s*<td[^>]*>([\s\S]*?)<\/td>/i.exec(html);
      if (m2) cell = m2[1];
    }

    if (!cell) return "";

    // Extraer nombres desde enlaces <a>
    const anchors = [];
    for (const a of String(cell).matchAll(/<a[^>]+href=["']([^"']+)["'][^>]*>([\s\S]*?)<\/a>/ig)) {
      const text = stripTags_(a[2]).replace(/\s+/g, ' ').trim();
      if (text) anchors.push(text);
    }
    
    if (anchors.length) return cleanDeveloperList_(anchors.join(', '));
    
    // Si no hay enlaces, usar el texto plano
    const plain = stripTags_(cell).replace(/\s+/g, ' ').trim();
    return cleanDeveloperList_(plain);
    
  } catch (_) {
    return "";
  }
}

// ====================================
// GENERAR SLUG PARA URL ZXART
// ====================================

function makeZxartSlug_(title) {
  return String(title || '')
    .toLowerCase()
    .replace(/[''`´]/g, '')
    .replace(/[^a-z0-9]+/g, '-')
    .replace(/^-+|-+$/g, '')
    .replace(/--+/g, '-');
}

// ====================================
// NORMALIZAR DATOS DE "PRODUCED BY"
// ====================================

function normalizeProducedBy_(raw) {
  if (!raw) return "";
  let list = "";
  
  if (Array.isArray(raw)) {
    const names = raw.map(x => 
      (typeof x === 'string') ? x : (x && (x.name || x.title || x.nickname) || '')
    ).filter(Boolean);
    list = names.join(', ');
  } else if (typeof raw === 'object' && raw) {
    list = raw.name || raw.title || raw.nickname || "";
  } else {
    list = String(raw || '');
  }
  
  return cleanDeveloperList_(list);
}

// ====================================
// LIMPIAR LISTA DE DESARROLLADORES
// ====================================

function cleanDeveloperList_(raw) {
  return String(raw || '')
    .split(/[,/]/)
    .map(s => s.trim())
    .filter(s => s.length > 0)
    .map(s => toTitleCase_(s))
    .join(', ');
}

function toTitleCase_(str) {
  return String(str || '').replace(/\w\S*/g, w => 
    w.charAt(0).toUpperCase() + w.slice(1).toLowerCase()
  );
}

// ====================================
// OBTENER SINOPSIS DESDE ZXART (CON TRADUCCIÓN)
// ====================================

function getZXArtSynopsisTranslated_(titulo) {
  const title = (titulo || '').trim();
  
  // Resolver URL del juego en ZXArt
  const url = resolveZXArtUrlForTitle_(title);
  if (!url) {
    return { en: '', es: '', preview: '' };
  }

  // Extraer sinopsis en inglés
  const sinEN = extractZXArtSynopsisFromUrl_(url);
  if (!sinEN || !String(sinEN).trim()) {
    return { en: '', es: '', preview: '' };
  }

  // Normalizar saltos de línea
  const normalizedEn = String(sinEN)
    .replace(/\r\n/g, '\n')
    .replace(/\r/g, '\n')
    .trim();

  // Separar en párrafos
  const paragraphsEn = normalizedEn
    .split(/\n\s*\n+/)
    .map(p => p.replace(/\s+/g, ' ').trim())
    .filter(p => p.length > 0);

  // Si no hay párrafos pero sí texto, usar todo como un párrafo
  if (!paragraphsEn.length && normalizedEn.length) {
    paragraphsEn.push(normalizedEn);
  }

  // Traducir cada párrafo
  let sinES = '';
  if (paragraphsEn.length) {
    const translated = [];
    
    for (let i = 0; i < paragraphsEn.length; i++) {
      const p = paragraphsEn[i];
      let t = '';
      
      try {
        t = LanguageApp.translate(p, 'en', 'es');
      } catch (err) {
        Logger.log('[WARN] Falló traducción de párrafo ' + i + ': ' + err);
        t = p; // Usar original si falla
      }
      
      translated.push(String(t || '').trim());
    }
    
    sinES = translated.join('\n\n');
  } else {
    // Traducción global si no hay párrafos
    try {
      sinES = LanguageApp.translate(normalizedEn, 'en', 'es');
    } catch (err2) {
      Logger.log('[WARN] Falló traducción global: ' + err2);
      sinES = '';
    }
  }

  sinES = String(sinES || '').trim();

  // Si la traducción falla, usar el inglés original
  if (!sinES) {
    sinES = normalizedEn;
  }

  return {
    en: normalizedEn,
    es: sinES,
    preview: normalizedEn.substring(0, 500)
  };
}

// ====================================
// TRADUCCIÓN GENÉRICA DE TEXTO (INGLÉS → ESPAÑOL)
// ====================================
// Usada para traducir sinopsis y argumento de IGDB en PS3
// Sin marcas ni indicadores de traducción

function translateTextToSpanish_(text) {
  if (!text) return '';
  
  const normalizedText = String(text)
    .replace(/\r\n/g, '\n')
    .replace(/\r/g, '\n')
    .trim();
  
  if (!normalizedText) return '';
  
  // Separar en párrafos
  const paragraphs = normalizedText
    .split(/\n\s*\n+/)
    .map(p => p.replace(/\s+/g, ' ').trim())
    .filter(p => p.length > 0);
  
  // Si no hay párrafos pero sí texto, usar todo como un párrafo
  if (!paragraphs.length && normalizedText.length) {
    paragraphs.push(normalizedText);
  }
  
  // Traducir cada párrafo
  let translatedText = '';
  if (paragraphs.length) {
    const translated = [];
    
    for (let i = 0; i < paragraphs.length; i++) {
      const p = paragraphs[i];
      let t = '';
      
      try {
        t = LanguageApp.translate(p, 'en', 'es');
      } catch (err) {
        Logger.log('[WARN] Falló traducción de párrafo ' + i + ': ' + err);
        t = p; // Usar original si falla
      }
      
      translated.push(String(t || '').trim());
    }
    
    translatedText = translated.join('\n\n');
  } else {
    // Traducción global si no hay párrafos
    try {
      translatedText = LanguageApp.translate(normalizedText, 'en', 'es');
    } catch (err2) {
      Logger.log('[WARN] Falló traducción global: ' + err2);
      translatedText = normalizedText; // Usar original si falla
    }
  }
  
  translatedText = String(translatedText || '').trim();
  
  // Si la traducción falla completamente, usar el original
  if (!translatedText) {
    translatedText = normalizedText;
  }
  
  return translatedText;
}

// ====================================
// RESOLVER URL DE ZXART PARA UN TÍTULO
// ====================================

function resolveZXArtUrlForTitle_(rawTitle) {
  const title = (rawTitle || "").trim();
  if (!title) return "";

  const base = "https://zxart.ee";

  // ESTRATEGIA 1: API de ZXArt
  try {
    const apiUrl = base + "/api/search/software?query=" + encodeURIComponent(title);
    const apiResp = UrlFetchApp.fetch(apiUrl, { muteHttpExceptions: true });
    const code = apiResp.getResponseCode();
    const text = apiResp.getContentText("UTF-8") || "";

    const match = text.match(/"?(\/eng\/software\/[^"]+)"/);
    if (code === 200 && match && match[1]) {
      const candidate = base + match[1];
      if (urlExists_(candidate)) return candidate;
    }
  } catch (e) {}

  // ESTRATEGIA 2: Búsqueda web
  try {
    const sUrl = base + "/eng/search/?form=software&query=" + encodeURIComponent(title);
    const resp = UrlFetchApp.fetch(sUrl, { muteHttpExceptions: true });
    const code = resp.getResponseCode();
    const html = resp.getContentText("UTF-8") || "";

    const p = findFirstSoftwareUrlInHtml_(html);
    if (p) {
      const candidate = base + p;
      if (urlExists_(candidate)) return candidate;
    }
  } catch (e) {}

  // ESTRATEGIA 3: Slug heurístico
  try {
    const slug = slugifyForZXArt_(title);
    const candidate = base + "/eng/software/games/" + slug + "/";
    if (urlExists_(candidate)) return candidate;
  } catch (e) {}

  return "";
}

// ====================================
// EXTRAER SINOPSIS DESDE URL DE ZXART
// ====================================

function extractZXArtSynopsisFromUrl_(url) {
  try {
    const resp = UrlFetchApp.fetch(url, { muteHttpExceptions: true });
    const code = resp.getResponseCode();
    const html = resp.getContentText("UTF-8") || "";

    if (code !== 200 || !html.length) return "";

    // Buscar bloque de descripción larga
    const block = extractLongBlock_(html);
    if (block) return cleanSynopsisText_(block);

    // Buscar og:description
    const og = extractMetaContent_(html, "property", "og:description");
    if (og) return cleanSynopsisText_(og);

    // Buscar meta description
    const meta = extractMetaContent_(html, "name", "description");
    if (meta) return cleanSynopsisText_(meta);

    return "";
  } catch (e) {
    Logger.log('[ERROR] extractZXArtSynopsisFromUrl_: ' + e);
    return "";
  }
}

// ====================================
// EXTRAER BLOQUE DE DESCRIPCIÓN LARGA
// ====================================

function extractLongBlock_(html) {
  const regex = /<div class="zxprod_details_description"[^>]*>([\s\S]*?)<\/div>/i;
  const m = html.match(regex);
  if (!m) return "";

  let t = m[1];
  t = t.replace(/<br\s*\/?>/gi, "\n");
  t = t.replace(/<\/p>/gi, "\n\n");
  t = t.replace(/<[^>]+>/g, "");
  
  return t;
}

// ====================================
// EXTRAER META TAG CONTENT
// ====================================

function extractMetaContent_(html, attrName, attrValue) {
  const regex = new RegExp(`<meta[^>]+${attrName}="${attrValue}"[^>]+content="([^"]+)"`, "i");
  const m = html.match(regex);
  return m ? m[1] : "";
}

// ====================================
// LIMPIAR TEXTO DE SINOPSIS
// ====================================

function cleanSynopsisText_(text) {
  if (!text) return '';

  const raw = String(text)
    .replace(/\r\n/g, '\n')
    .replace(/\r/g, '\n');

  const paragraphs = raw
    .split(/\n\s*\n+/)
    .map(p => p.replace(/\n+/g, ' ').replace(/\s+/g, ' ').trim())
    .filter(p => p.length > 0);

  if (!paragraphs.length) {
    return raw.replace(/\s+/g, ' ').trim();
  }

  return paragraphs.join('\n\n');
}

// ====================================
// HELPERS AUXILIARES
// ====================================

function urlExists_(u) {
  try {
    const r = UrlFetchApp.fetch(u, { muteHttpExceptions: true });
    return r.getResponseCode() === 200;
  } catch (e) {
    return false;
  }
}

function findFirstSoftwareUrlInHtml_(html) {
  const re = /href="(\/eng\/software\/[^"]+)"/g;
  let m;
  while ((m = re.exec(html)) !== null) return m[1];
  return "";
}

function slugifyForZXArt_(title) {
  let s = title.toLowerCase();
  const accentMap = {
    "á": "a", "à": "a", "ä": "a", "â": "a",
    "é": "e", "è": "e", "ë": "e", "ê": "e",
    "í": "i", "ì": "i", "ï": "i", "î": "i",
    "ó": "o", "ò": "o", "ö": "o", "ô": "o",
    "ú": "u", "ù": "u", "ü": "u", "û": "u",
    "ñ": "n", "ç": "c"
  };
  s = s.split("").map(ch => accentMap[ch] || ch).join("");
  s = s.replace(/[^a-z0-9 ]+/g, " ").replace(/\s+/g, " ").trim();
  return s.replace(/ /g, "-");
}

/**
 * ============================================
 * ESCRIBIR DATOS EN LA HOJA COMMODORE 64
 * ============================================
 * 
 * Escribe los datos scrapeados desde Lemon64 en la hoja C64.
 * Solo rellena celdas VACÍAS (respeta datos manuales).
 * 
 * Columnas gestionadas:
 * - ID_LEMON64, AÑO, PUBLISHER, DESARROLLADOR, AUTORES
 * - GÉNERO, SUBGÉNERO, JUGADORES, CONTROLES
 * - CARÁTULA, SCREENSHOTS, IMÁGENES, VIDEO
 * - REVISTAS, INSTRUCCIONES, PUNTUACIÓN
 * 
 * ============================================
 */

function writeBackC64RowFromData_(sh, row, headers, data, extras) {
  if (!data) return;

  // ====================================
  // HELPER: NORMALIZAR NOMBRES DE COLUMNAS
  // ====================================
  function normalizeHeaderKey_(s) {
    let t = String(s || '').toLowerCase().trim();
    // Quitar acentos
    t = t.replace(/[áàäâ]/g, 'a').replace(/[éèëê]/g, 'e').replace(/[íìïî]/g, 'i')
         .replace(/[óòöô]/g, 'o').replace(/[úùüû]/g, 'u').replace(/ñ/g, 'n');
    return t.replace(/\s+/g, ' ');
  }

  // ====================================
  // HELPER: ENCONTRAR ÍNDICE DE COLUMNA
  // ====================================
  function colIndex_(name) {
    const target = normalizeHeaderKey_(name || '');
    for (let i = 0; i < headers.length; i++) {
      if (normalizeHeaderKey_(headers[i]) === target) return i + 1;
    }
    return 0;
  }

  // ====================================
  // HELPER: LIMPIAR VALOR
  // ====================================
  function cleanValue_(v) {
    if (v == null) return '';
    let t = String(v).trim();
    if (!t || t === '????' || /^dato no disponible$/i.test(t)) return '';
    return t;
  }

  // ====================================
  // HELPER: ESCRIBIR SI ESTÁ VACÍO
  // ====================================
  function writeIfEmpty_(colName, value) {
    const col = colIndex_(colName);
    const v = cleanValue_(value);
    if (!col || !v) return;
    
    const rng = sh.getRange(row, col);
    const currentValue = String(rng.getValue() || '').trim();
    
    if (!currentValue) {
      rng.setValue(v);
      Logger.log('[C64] Escrito en ' + colName + ': ' + v.substring(0, 50));
    } else {
      Logger.log('[C64] Respetado valor manual en ' + colName);
    }
  }

  // ====================================
  // HELPER: CONVERTIR ANCHORS A TEXTO
  // ====================================
  function anchorsToText_(arr) {
    return (Array.isArray(arr) ? arr : [])
      .map(a => (a && a.text) ? String(a.text) : '')
      .filter(Boolean)
      .join(', ');
  }

  // ====================================
  // HELPER: CONVERTIR REVISTAS A MARKDOWN
  // ====================================
  function revistasToMarkdown_(arr) {
    if (!Array.isArray(arr) || !arr.length) return '';
    
    return arr.map(r => {
      const mag = r.mag || 'Revista';
      const title = r.title || mag;
      const href = r.href || '#';
      
      return `[${mag} - ${title}](${href})`;
    }).join('\n');
  }

  // ====================================
  // ESCRIBIR DATOS EN LA HOJA
  // ====================================

  // ID Lemon64
  writeIfEmpty_('ID_LEMON64', data.idLemon64);

  // Año
  writeIfEmpty_('AÑO', data.anio);
  writeIfEmpty_('ANO', data.anio); // Por si acaso sin tilde

  // Publisher
  writeIfEmpty_('PUBLISHER', anchorsToText_(data.publisherAnchors));

  // Desarrollador
  writeIfEmpty_('DESARROLLADOR', anchorsToText_(data.desarrolladorAnchors));

  // Autores (ya viene como texto con roles)
  writeIfEmpty_('AUTORES', data.autores);

  // Género
  writeIfEmpty_('GÉNERO', anchorsToText_(data.generoAnchors));
  writeIfEmpty_('GENERO', anchorsToText_(data.generoAnchors));

  // Subgénero
  writeIfEmpty_('SUBGÉNERO', anchorsToText_(data.subgeneroAnchors));
  writeIfEmpty_('SUBGENERO', anchorsToText_(data.subgeneroAnchors));

  // Jugadores
  writeIfEmpty_('JUGADORES', anchorsToText_(data.jugadoresAnchors));

  // Controles
  writeIfEmpty_('CONTROLES', anchorsToText_(data.controlesAnchors));

  // Carátula
  writeIfEmpty_('CARÁTULA', data.caratula);
  writeIfEmpty_('CARATULA', data.caratula);

  // Screenshots (primeras 2, separadas por salto de línea)
  if (Array.isArray(data.screenshots) && data.screenshots.length) {
    writeIfEmpty_('SCREENSHOTS', data.screenshots.join('\n'));
  }

  // Imágenes adicionales (desde 3ª, separadas por ", ")
  if (Array.isArray(data.imagenesAdicionales) && data.imagenesAdicionales.length) {
    writeIfEmpty_('IMÁGENES', data.imagenesAdicionales.join(', '));
    writeIfEmpty_('IMAGENES', data.imagenesAdicionales.join(', '));
  }

  // Video
  writeIfEmpty_('VIDEO', data.video);

  // Revistas (formato Markdown con enlaces)
  const revistasMarkdown = revistasToMarkdown_(data.revistas);
  if (revistasMarkdown) {
    writeIfEmpty_('REVISTAS', revistasMarkdown);
  }

  // Instrucciones
  writeIfEmpty_('INSTRUCCIONES', data.instrucciones);

  // Puntuación
  writeIfEmpty_('PUNTUACIÓN', data.ratingDisplay);
  writeIfEmpty_('PUNTUACION', data.ratingDisplay);

  // ====================================
  // EXTRAS (sinopsis si viene en extras)
  // ====================================
  if (extras && extras.sinopsis) {
    writeIfEmpty_('SINOPSIS', extras.sinopsis);
  }

  Logger.log('[C64] Escritura completada en fila ' + row);
}

/**
 * ============================================
 * PARTE 5: GENERACIÓN HTML DE LA FICHA
 * ============================================
 * 
 * Genera el HTML completo de la ficha con:
 * - Información básica (año, publisher, autor, etc.)
 * - Sinopsis (con párrafos)
 * - Datos técnicos
 * - Screenshots
 * - Imágenes adicionales
 * - Gameplay (YouTube)
 * - Revistas
 * - Útiles (mapa, instrucciones, enlace fuente)
 * 
 * ============================================
 */

function buildPreviewHtml_(titulo, plataforma, fuenteUrl, d, tecnicos, sinopsisText) {
  
  // ====================================
  // CSS DE LA FICHA
  // ====================================
  const css = `
    <style>
      body {
        font-family: Arial, Helvetica, sans-serif;
        padding: 14px;
      }
      .h1 {
        font-weight: 700;
        font-size: 20px;
        margin: 0 0 6px;
      }
      .meta {
        color: #666;
        font-size: 12px;
        margin: 0 0 10px;
      }
      .row {
        margin: 8px 0;
      }
      .cover {
        max-width: 100%;
        border-radius: 8px;
      }
      .section-title {
        font-weight: 700;
        margin-top: 10px;
      }
      .grid2 {
        display: grid;
        grid-template-columns: repeat(2, 1fr);
        gap: 6px;
      }
      .shots img, .addimgs img {
        width: 100%;
        border-radius: 6px;
        display: block;
        border: 1px solid #ddd;
      }
      .info {
        font-size: 13px;
        line-height: 1.5;
        color: #222;
        margin-top: 8px;
      }
      .info .line {
        margin: 2px 0;
      }
      .info b {
        font-weight: 700;
      }
      .video {
        position: relative;
        padding-bottom: 56.25%;
        height: 0;
      }
      .video iframe {
        position: absolute;
        left: 0;
        top: 0;
        width: 100%;
        height: 100%;
        border: 0;
        border-radius: 8px;
      }
      a {
        word-break: break-word;
        text-decoration: none;
      }
    </style>`;

  // ====================================
  // HELPERS INTERNOS
  // ====================================
  
  // Convierte array de anchors a HTML con enlaces
  const toJoinedLinks = (arr) => (arr && arr.length)
    ? arr.map(a => `<a href="${escapeAttr_(a.href)}" target="_blank">${escapeHtml_(a.text)}</a>`).join(', ')
    : '';

  // Crea anchors locales desde texto simple
  const makeLocalAnchors = (txt) => {
    const s = String(txt || '').trim();
    if (!s) return [];
    return s.split(/\s*,\s*/).map(t => t.trim()).filter(Boolean).map(t => ({ text: t, href: '#' }));
  };

  // Renderiza una línea con enlaces
  const renderLineLinks = (label, anchors) => {
    if (!anchors || !anchors.length) return '';
    return `<div class="line">· <b>${escapeHtml_(label)}:</b> ${toJoinedLinks(anchors)}</div>`;
  };

  // Renderiza una línea con texto plano
  const renderLineText = (label, text) => {
    return `<div class="line">· <b>${escapeHtml_(label)}:</b> ${escapeHtml_(text || '')}</div>`;
  };

  // ====================================
  // CARÁTULA
  // ====================================
  const cover = d.caratula 
    ? `<div class="row"><img class="cover" src="${escapeAttr_(d.caratula)}" alt="CARÁTULA"/></div>` 
    : '';

  // ====================================
  // PLATAFORMA
  // ====================================
  const plataformaMeta = plataforma 
    ? `<div class="meta">${escapeHtml_(plataforma)}</div>` 
    : '';

  // ====================================
  // SINOPSIS (RESPETA PÁRRAFOS)
  // ====================================
  const sinopsisBlock = (() => {
    const raw = sinopsisText && String(sinopsisText).trim();
    if (!raw) return '';

    // Separar por párrafos (saltos de línea dobles)
    const paragraphs = raw
      .split(/\n\s*\n+/)
      .map(p => p.trim())
      .filter(Boolean);

    const htmlParagraphs = paragraphs
      .map(p => `<div class="line">${escapeHtml_(p)}</div>`)
      .join('');

    return `<div class="row"><div class="section-title">Sinopsis</div><div class="info">${htmlParagraphs}</div></div>`;
  })();

  // ====================================
  // ARGUMENTO (SOLO PS3, desde storyline de IGDB)
  // ====================================
  // Se muestra solo si hay contenido en el campo argumento y es ficha PS3
  const argumentoBlock = (() => {
  const isIGDB = (plataforma && !plataforma.toLowerCase().includes('spectrum'));
    if (!isIGDB) return '';
    
    const argumentoText = (d && d.argumento) ? String(d.argumento).trim() : '';
    if (!argumentoText) return '';
    
    // Convertir saltos de línea a <br> para respetar el formato
    const argumentoFormatted = escapeHtml_(argumentoText).replace(/\n/g, '<br>');
    
    return `<div class="row"><div class="section-title">Argumento</div><div class="info"><div class="line">${argumentoFormatted}</div></div></div>`;
  })();

  // ====================================
  // INFORMACIÓN
  // ====================================
  const infoLinesArr = [
    renderLineLinks('Año', splitByCommaToAnchors_(d.anio, fuenteUrl)),
    renderLineLinks('Publisher', d.publisherAnchors),
    renderLineLinks('Desarrollo', d.desarrolladorAnchors),
    renderLineLinks('Autor', d.autorAnchors),
    renderLineLinks('Contribuciones', d.contributorsAnchors),
    renderLineLinks('Género', d.generoAnchors),
    renderLineLinks('Subgénero', d.subgeneroAnchors),
    renderLineLinks('Controles', d.controlesAnchors),
    renderLineLinks('Versión', d.versionAnchors),
    renderLineLinks('Distribuidoras', d.distribuidorasAnchors),
    renderLineText('Puntuación', (d.ratingDisplay && String(d.ratingDisplay).trim()) ? d.ratingDisplay : 'Dato no disponible')
  ].filter(Boolean);

  const infoHtml = infoLinesArr.length
    ? `<div class="row"><div class="section-title">Información</div><div class="info">${infoLinesArr.join('')}</div></div>`
    : '';

  // ====================================
  // DATOS TÉCNICOS (ADAPTADO A ZX / PS3)
  // ====================================
  const isIGDBFicha = (plataforma && !plataforma.toLowerCase().includes('spectrum'));
  
  let tecnicosLines = '';

  if (isIGDBFicha) {
    // Datos técnicos para PS3 (sin masInfo, que va en sección aparte)
    // Ubicación: solo si NO es "--"
    // Favorito: solo si
    tecnicosLines = [
      renderLineLinks('Modos de juego', d.jugadoresAnchors),
      (tecnicos && tecnicos.ubicacion && tecnicos.ubicacion !== '--') ? renderLineText('Ubicación', tecnicos.ubicacion) : '',
      tecnicos && tecnicos.tipoFormato ? renderLineText('Formato', tecnicos.tipoFormato) : '',
      (tecnicos && tecnicos.favorito && tecnicos.favorito.toUpperCase() === 'SI') ? renderLineText('Favorito', tecnicos.favorito) : '',
      tecnicos && tecnicos.terminado ? renderLineText('Terminado', tecnicos.terminado) : ''
    ].filter(Boolean).join('');
  } else {
    // Datos técnicos para ZX Spectrum
    tecnicosLines = [
      renderLineLinks('Modos de juego', d.jugadoresAnchors),
      renderLineLinks('Formato', makeLocalAnchors(tecnicos && tecnicos.formato)),
        renderLineLinks('ZX +2A', makeLocalAnchors(tecnicos && tecnicos.zx2a)),
        renderLineLinks('TSPEC', makeLocalAnchors(tecnicos && tecnicos.tspec)),
        renderLineText('Terminado', tecnicos && tecnicos.terminado)
      ].filter(Boolean).join('');
  }

  const tecnicosHtml = tecnicosLines
    ? `<div class="row"><div class="section-title">Datos Técnicos</div><div class="info">${tecnicosLines}</div></div>`
    : '';

  // ====================================
  // MÁS INFO (SOLO PS3, SECCIÓN SEPARADA)
  // ====================================
  // Se muestra solo si hay contenido en MAS_INFO y es ficha PS3
  // Respeta saltos de línea del texto original
  const masInfoHtml = (() => {
    if (!isIGDBFicha) return '';
    const masInfoText = (tecnicos && tecnicos.masInfo) ? String(tecnicos.masInfo).trim() : '';
    if (!masInfoText) return '';
    
    // Convertir saltos de línea a <br> para respetar el formato del usuario
    const masInfoFormatted = escapeHtml_(masInfoText).replace(/\n/g, '<br>');
    
    return `<div class="row"><div class="section-title">Más Info</div><div class="info"><div class="line">${masInfoFormatted}</div></div></div>`;
  })();

  // ====================================
  // SCREENSHOTS
  // ====================================
  const shotsHtml = (d.screenshots && d.screenshots.length)
    ? `<div class="row"><div class="section-title">Screenshots</div><div class="grid2 shots">${
        d.screenshots.map(u => `<img src="${escapeAttr_(u)}" alt="">`).join('')
      }</div></div>`
    : '';

  // ====================================
  // IMÁGENES ADICIONALES
  // ====================================
  const addHtml = (d.imagenesAdicionales && d.imagenesAdicionales.length)
    ? `<div class="row"><div class="section-title">Imágenes adicionales</div><div class="grid2 addimgs">${
        d.imagenesAdicionales.map(u => `<img src="${escapeAttr_(u)}" alt="">`).join('')
      }</div></div>`
    : '';

  // ====================================
  // GAMEPLAY (YOUTUBE)
  // ====================================
  const videoBlock = d.video && /youtube\.com|youtu\.be/i.test(d.video)
    ? `<div class="row">
         <div class="section-title">Gameplay</div>
         <div class="video"><iframe src="${escapeAttr_(youtubeEmbedUrl_(d.video))}" allowfullscreen loading="lazy"></iframe></div>
       </div>`
    : (d.video
        ? `<div class="row">
             <div class="section-title">Gameplay</div>
             <a href="${escapeAttr_(d.video)}" target="_blank">▶ Gameplay (YouTube)</a>
           </div>`
        : '');

  // ====================================
  // REVISTAS
  // ====================================
  const revistasLines = (d.revistas || []).map(it =>
    `<div class="line"><b>· ${escapeHtml_(it.mag)}: </b><a href="${escapeAttr_(it.href)}" target="_blank">${escapeHtml_(it.title)}</a></div>`
  ).join('');
  
  const revistasHtml = revistasLines
    ? `<div class="row"><div class="section-title">Revistas</div><div class="info">${revistasLines}</div></div>`
    : '';

  // ====================================
  // ÚTILES (MAPA, INSTRUCCIONES, ENLACE FUENTE)
  // ====================================
  const utilesBlock = (d.mapa || d.instrucciones || fuenteUrl)
    ? `<div class="row">
         <div class="section-title">Útiles</div>
         <div class="info">
           ${d.mapa ? `<div class="line">· <a href="${escapeAttr_(d.mapa)}" target="_blank">🗺️ Mapa</a></div>` : ''}
           ${d.instrucciones ? `<div class="line">· <a href="${escapeAttr_(d.instrucciones)}" target="_blank">📄 Instrucciones</a></div>` : ''}
           ${fuenteUrl ? `<div class="line">· <a href="${escapeAttr_(fuenteUrl)}" target="_blank">🔗 Enlace fuente</a></div>` : ''}
         </div>
       </div>`
    : '';

  // ====================================
  // ENSAMBLAR HTML COMPLETO
  // ====================================
  return `<!DOCTYPE html><html><head><meta charset="UTF-8">${css}</head><body>`
    + `<div class="h1">${escapeHtml_(titulo)}</div>`
    + plataformaMeta
    + cover
    + infoHtml
    + sinopsisBlock
    + argumentoBlock
    + tecnicosHtml
    + masInfoHtml
    + shotsHtml
    + addHtml
    + videoBlock
    + revistasHtml
    + utilesBlock
    + `</body></html>`;
}

// ====================================
// HELPER: FORMATEAR PUNTUACIÓN
// ====================================

function formatRatingDisplay_(score10, votes) {
  const hasScore = (typeof score10 === 'number') && !isNaN(score10);
  const hasVotes = (typeof votes === 'number') && !isNaN(votes);

  if (!hasScore || !hasVotes) {
    return 'Dato no disponible';
  }

  if (score10 === 0 && votes === 0) {
    return 'Dato no disponible';
  }

  // Formateo con coma decimal
  const scoreStr = (Math.round(score10 * 10) / 10).toFixed(1).replace('.', ',');
  const votosStr = `${votes} voto${votes === 1 ? '' : 's'}`;
  
  return `${scoreStr} (${votosStr})`;
}

// ====================================
// HELPER: CONVERTIR URL DE YOUTUBE A EMBED
// ====================================

function youtubeEmbedUrl_(u) {
  try {
    let url = String(u);
    
    // youtu.be/ID
    const m1 = url.match(/youtu\.be\/([A-Za-z0-9_-]{6,})/);
    if (m1) return `https://www.youtube.com/embed/${m1[1]}`;
    
    // youtube.com/watch?v=ID
    const v = (url.match(/[?&]v=([A-Za-z0-9_-]{6,})/) || [])[1];
    if (v) return `https://www.youtube.com/embed/${v}`;
    
    // youtube.com/embed/ID (ya está en formato correcto)
    const m2 = url.match(/\/embed\/([A-Za-z0-9_-]{6,})/);
    if (m2) return `https://www.youtube.com/embed/${m2[1]}`;
    
    return url;
  } catch (e) {
    return u;
  }
}

/**
 * ============================================
 * PARTE 6: ESCRITURA EN SHEET + IDS
 * ============================================
 * 
 * Funciones para:
 * 1. Escribir datos scrapeados en la hoja (solo celdas vacías)
 * 2. Rellenar IDs automáticamente
 * 3. Limpieza de comillas
 * 
 * ============================================
 */

// ====================================
// ESCRIBIR DATOS EN LA HOJA (SOLO CELDAS VACÍAS)
// ====================================

function writeBackZXRowFromData_(sh, row, headers, data, opts) {
  opts = opts || {};
  const autoScreens = Array.isArray(opts.autoScreenshots) ? opts.autoScreenshots : [];
  const sinopsis = String(opts.sinopsis || '').trim();

  // ====================================
  // HELPER: NORMALIZAR NOMBRES DE COLUMNAS
  // ====================================
  function normalizeHeaderKey_(s) {
    let t = String(s || '').toLowerCase().trim();
    
    // Quitar tildes
    t = t
      .replace(/[áàäâ]/g, 'a')
      .replace(/[éèëê]/g, 'e')
      .replace(/[íìïî]/g, 'i')
      .replace(/[óòöô]/g, 'o')
      .replace(/[úùüû]/g, 'u')
      .replace(/ñ/g, 'n');
    
    t = t.replace(/\s+/g, ' ');
    return t;
  }

  // ====================================
  // HELPER: ENCONTRAR ÍNDICE DE COLUMNA
  // ====================================
  function colIndex_(name) {
    const target = normalizeHeaderKey_(name);
    for (let i = 0; i < headers.length; i++) {
      const hKey = normalizeHeaderKey_(headers[i]);
      if (hKey === target) return i + 1;
    }
    return 0;
  }

  // ====================================
  // HELPER: ESCRIBIR SI LA CELDA ESTÁ VACÍA
  // ====================================
  function writeIfEmpty_(colName, value) {
    const col = colIndex_(colName);
    if (!col || value == null) return;

    const rng = sh.getRange(row, col);
    const current = String(rng.getValue() || '').trim();

    // Limpiar comillas del valor
    const v = limpiarComillasExtra_(value);

    if (!current && v) {
      rng.setValue(v);
    }
  }

  // ====================================
  // APLANAR DATOS A STRINGS
  // ====================================
  const anio = data.anio || '';
  const publisher = (data.publisherAnchors || []).map(a => a.text).join(', ');
  const dev = (data.desarrolladorAnchors || []).map(a => a.text).join(', ');
  const genero = (data.generoAnchors || []).map(a => a.text).join(', ');
  const subgenero = (data.subgeneroAnchors || []).map(a => a.text).join(', ');
  const autor = (data.autorAnchors || []).map(a => a.text).join(', ');
  const contrib = (data.contributorsAnchors || []).map(a => a.text).join(', ');
  const jugadores = (data.jugadoresAnchors || []).map(a => a.text).join(', ');
  const controles = (data.controlesAnchors || []).map(a => a.text).join(', ');
  const version = (data.versionAnchors || []).map(a => a.text).join(', ');
  const distrib = (data.distribuidorasAnchors || []).map(a => a.text).join(', ');
  
  const caratula = data.caratula || '';
  const screenshots = autoScreens.join(', ');
  const extraImgs = (data.imagenesAdicionales || []).join('\n');
  const mapa = data.mapa || '';
  const instrucciones = data.instrucciones || '';
  const video = data.video || '';
  const ratingDisp = (data.ratingDisplay && String(data.ratingDisplay).trim()) ? data.ratingDisplay : '';

  // REVISTAS: formato [REVISTA - Título](URL)
  const revistasStr = (data.revistas || []).map(r => {
    if (!r || !r.href) return '';
    const mag = String(r.mag || '').trim();
    const title = String(r.title || '').trim();
    const label = mag ? (mag + (title ? ' - ' + title : '')) : title;
    const finalLabel = label || r.href;
    return '[' + finalLabel + '](' + r.href + ')';
  }).filter(line => line !== '').join('\n');

  // ====================================
  // ESCRIBIR DATOS (SOLO SI CELDAS VACÍAS)
  // ====================================
  
  // Carátula: NO escribir si es el fallback genérico
  if (caratula && caratula !== FALLBACK_COVER_URL) {
    writeIfEmpty_('CARÁTULA', caratula);
  }

  writeIfEmpty_('AÑO', anio);
  writeIfEmpty_('PUBLISHER', publisher);
  writeIfEmpty_('DESARROLLADOR', dev);
  writeIfEmpty_('GÉNERO', genero);
  writeIfEmpty_('SUBGÉNERO', subgenero);
  writeIfEmpty_('AUTOR', autor);
  writeIfEmpty_('CONTRIBUCIONES', contrib);
  writeIfEmpty_('JUGADORES', jugadores);
  writeIfEmpty_('CONTROLES', controles);
  writeIfEmpty_('VERSIÓN', version);
  writeIfEmpty_('DISTRIBUIDORAS', distrib);
  writeIfEmpty_('SCREENSHOTS', screenshots);
  writeIfEmpty_('IMÁGENES', extraImgs);
  writeIfEmpty_('REVISTAS', revistasStr);
  writeIfEmpty_('SINOPSIS', sinopsis);
  writeIfEmpty_('MAPA', mapa);
  writeIfEmpty_('INSTRUCCIONES', instrucciones);
  writeIfEmpty_('VIDEO', video);
  writeIfEmpty_('PUNTUACIÓN', ratingDisp);
}

// ====================================
// LIMPIEZA DE COMILLAS
// ====================================

function limpiarComillasExtra_(t) {
  if (t == null) return "";
  t = String(t);

  // Normalizar comillas dobles "raras" a comillas dobles normales
  t = t.replace(/[""«»„‟]/g, '"');

  // Colapsar grupos de comillas dobles múltiples a una sola
  t = t.replace(/"{2,}/g, '"');

  // Eliminar cualquier comilla doble que quede
  t = t.replace(/"/g, "");

  // Espacios múltiples → uno solo
  t = t.replace(/\s{2,}/g, " ").trim();

  return t;
}

// ====================================
// RELLENAR IDs AUTOMÁTICAMENTE
// ====================================

function rellenarIdsZXLista() {
  const ss = SpreadsheetApp.getActive();
  const shActiva = ss.getActiveSheet();
  const nombreHojaActiva = shActiva ? shActiva.getName().trim().toUpperCase() : '';

  if (nombreHojaActiva.includes('PS3')) {
    return rellenarIdPS3FilaActual_(shActiva);
  }

  const sh = ss.getSheetByName('ZX_SPECTRUM');

  if (!sh) return;

  const lastRow = sh.getLastRow();
  if (lastRow < 2) return;

  // Leer cabeceras
  const headers = sh.getRange(1, 1, 1, sh.getLastColumn()).getValues()[0];

  const colIdIndex = headers.indexOf('ID');
  const colTituloIndex = headers.indexOf('TÍTULO') !== -1
    ? headers.indexOf('TÍTULO')
    : headers.indexOf('TITULO');

  if (colIdIndex === -1 || colTituloIndex === -1) return;

  const colId = colIdIndex + 1;
  const colTitulo = colTituloIndex + 1;
  const numRows = lastRow - 1;

  const idsRange = sh.getRange(2, colId, numRows, 1);
  const titulosRange = sh.getRange(2, colTitulo, numRows, 1);

  const ids = idsRange.getValues();
  const titulos = titulosRange.getValues();

  // Encontrar el ID más alto actual
  let maxId = 0;
  for (let i = 0; i < ids.length; i++) {
    const val = ids[i][0];
    if (typeof val === 'number' && !isNaN(val)) {
      if (val > maxId) maxId = val;
    }
  }

  // Rellenar solo IDs vacíos que tengan título
  for (let i = 0; i < ids.length; i++) {
    const idActual = ids[i][0];
    const tituloActual = String(titulos[i][0] || '').trim();

    if (!tituloActual) continue; // Fila vacía
    
    if (idActual === '' || idActual == null) {
      maxId++;
      ids[i][0] = maxId;
    }
  }

  // Guardar los IDs actualizados
  idsRange.setValues(ids);
}

function rellenarIdPS3FilaActual_(sh) {
  const ui = SpreadsheetApp.getUi();
  const activeCell = sh.getActiveCell();
  const row = activeCell ? activeCell.getRow() : 0;

  if (!row || row === 1) {
    return uiAlert_('Selecciona una fila con datos (no la cabecera).');
  }

  const headers = sh.getRange(1, 1, 1, Math.max(1, sh.getLastColumn())).getValues()[0];
  const colIdIndex = headers.indexOf('ID');

  if (colIdIndex === -1) {
    return uiAlert_('No se ha encontrado la columna "ID" en la hoja PS3.');
  }

  const colId = colIdIndex + 1;
  const numRows = Math.max(0, sh.getLastRow() - 1);
  let ids = [];

  if (numRows > 0) {
    ids = sh.getRange(2, colId, numRows, 1).getValues();
  }

  let ultimoId = '';

  for (let i = ids.length - 1; i >= 0; i--) {
    const val = String(ids[i][0] || '').trim();
    if (val) {
      ultimoId = val;
      break;
    }
  }

  let siguienteNumero = 1;

  if (ultimoId) {
    const match = ultimoId.match(/(\d+)$/);
    if (match) {
      siguienteNumero = parseInt(match[1], 10) + 1;
    }
  }

  const nuevoId = `PS3_${String(siguienteNumero).padStart(4, '0')}`;
  sh.getRange(row, colId).setValue(nuevoId);
}

/**
 * ============================================
 * PARTE 7: HELPERS GENERALES (ÚLTIMA PARTE)
 * ============================================
 * 
 * Funciones auxiliares de bajo nivel:
 * - Manipulación de HTML
 * - Manipulación de URLs
 * - Parsing de anchors
 * - Conversión de archivos .scr
 * - Normalización de nombres
 * - Utilidades diversas
 * 
 * ============================================
 */

// ====================================
// UTILIDADES BÁSICAS
// ====================================

function uiAlert_(m) {
  SpreadsheetApp.getUi().alert(m);
}

function stripTags_(s) {
  return String(s || '').replace(/<[^>]*>/g, '');
}

function escapeHtml_(s) {
  return String(s || '').replace(/[&<>"']/g, c => ({
    "&": "&amp;",
    "<": "&lt;",
    ">": "&gt;",
    "\"": "&quot;",
    "'": "&#39;"
  }[c] || c));
}

function escapeAttr_(s) {
  return String(s || '').replace(/"/g, '&quot;');
}

function escapeRegex_(s) {
  return String(s).replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
}

// ====================================
// MANIPULACIÓN DE URLs
// ====================================

function absolutize_(base, url) {
  if (!url) return url;
  if (/^https?:\/\//i.test(url)) return url;
  
  const root = base.replace(/(https?:\/\/[^\/]+).*/, '$1');
  if (url.charAt(0) !== '/') url = '/' + url;
  
  return root + url;
}

function rootOf_(u) {
  return String(u).replace(/(https?:\/\/[^\/]+).*/, '$1');
}

function pathOf_(u) {
  return String(u).replace(/^https?:\/\/[^\/]+\//, '');
}

// ====================================
// CONVERSIÓN DE ARCHIVOS .SCR
// ====================================

function isScr_(u) {
  return /\.scr(?:\?|#|$)/i.test(String(u));
}

function scrToImg_(u) {
  if (!isScr_(u)) return u;
  
  const root = rootOf_(u);
  const path = pathOf_(u);
  
  return `${root}/SCRtoFace.php?SCR=${encodeURIComponent(path)}`;
}

function normalizeKey_(u) {
  let s = String(u);
  s = s.replace(/^https?:\/\/[^\/]+\//, '');
  s = s.replace(/^SCRtoFace\.php\?SCR=/i, '');
  s = s.replace(/[?#].*$/, '');
  return s.toLowerCase();
}

// ====================================
// EXTRACCIÓN DE PANELES HTML
// ====================================

function getPanel_(html, headingReStr) {
  const re = new RegExp(
    '<div\\s+class="panel-heading[^"]*">\\s*' + headingReStr + 
    '[\\s\\S]*?<div\\s+class="panel-body">([\\s\\S]*?)<\\/div>',
    'i'
  );
  const m = re.exec(html);
  return m ? m[1] : '';
}

function findLabelBlock_(fullHtml, label) {
  const L = escapeRegex_(label);
  const re = new RegExp(
    '(?:' +
    '<dt[^>]*>\\s*' + L + '\\s*:?\\s*<\\/dt>\\s*<dd[^>]*>([\\s\\S]*?)<\\/dd>|' +
    '<div\\s+class="col-sm-4">\\s*<b>\\s*' + L + '\\s*:?\\s*<\\/b>\\s*<\\/div>\\s*<div\\s+class="col-sm-8">([\\s\\S]*?)<\\/div>|' +
    '<t[hd][^>]*>\\s*' + L + '\\s*:?\\s*<\\/t[hd]>\\s*<t[hd][^>]*>([\\s\\S]*?)<\\/t[hd]>' +
    ')',
    'i'
  );
  const m = re.exec(fullHtml);
  if (!m) return '';
  return (m[1] || m[2] || m[3] || '');
}

// ====================================
// PARSING DE ANCHORS (ENLACES)
// ====================================

function parseAnchors_(htmlInner, baseUrl) {
  const out = [];
  const s = String(htmlInner || '');
  
  // Buscar todos los enlaces <a>
  for (const m of s.matchAll(/<a[^>]+href=["']([^"']+)["'][^>]*>([\s\S]*?)<\/a>/ig)) {
    const href = absolutize_(baseUrl, m[1]);
    const text = stripTags_(m[2]).replace(/\s+/g, ' ').trim();
    if (text) out.push({ text, href });
  }
  
  if (out.length) return out;

  // Si no hay enlaces, crear anchors desde texto plano
  const plain = stripTags_(s).replace(/\s*\n\s*/g, '|').replace(/\s*[,;]\s*/g, '|');
  const parts = plain.split('|').map(x => x.trim()).filter(Boolean);
  
  for (const p of parts) {
    const href = `${rootOf_(baseUrl)}/list?quick=s&text=${encodeURIComponent(p)}`;
    out.push({ text: p, href });
  }
  
  return out;
}

function splitByCommaToAnchors_(txt, baseUrl, labelPrefix) {
  const s = String(txt || '').trim();
  if (!s) return [];
  
  const parts = s.split(/\s*,\s*/).map(t => t.trim()).filter(Boolean);
  const root = rootOf_(baseUrl);
  
  return parts.map(p => {
    const q = labelPrefix ? `${labelPrefix} ${p}` : p;
    return {
      text: p,
      href: `${root}/list?quick=s&text=${encodeURIComponent(q)}`
    };
  });
}

// ====================================
// NORMALIZACIÓN DE NOMBRES
// ====================================

function normalizePublisherName_(t) {
  let s = String(t || '').trim();
  
  // Quitar sufijos geográficos
  s = s.replace(/\s*\((?:UK|USA|US|Spain|Italia|France|Germany|ES|GB)\)\s*$/i, '');
  
  // Quitar palabras comunes de empresas
  s = s.replace(/\b(Software|Ltd\.?|Limited|Inc\.?|S\.?A\.?|S\.?L\.?)\b/ig, '');
  s = s.replace(/\s{2,}/g, ' ').trim();
  
  // Normalizar Ocean
  if (/^ocean\b/i.test(s)) s = 'Ocean';
  
  return s;
}

// ====================================
// PARSING DE URLs (ANÁLISIS DE NOMBRES)
// ====================================

function parseUrlName_(u) {
  const full = String(u);
  const clean = full.split(/[?#]/)[0];
  const file = clean.substring(clean.lastIndexOf('/') + 1);
  const dot = file.lastIndexOf('.');
  const base = dot > 0 ? file.substring(0, dot) : file;
  const ext = dot > 0 ? file.substring(dot + 1) : '';
  
  return { full, file, base, ext };
}

/**
 * ============================================
 * INTEGRACIÓN IGDB: fetchPS3_fromIGDB_
 * ============================================
 * 
 * Busca datos del juego en IGDB y devuelve un objeto
 * compatible con buildPreviewHtml_.
 * 
 * LÓGICA DE SELECCIÓN (v2.0):
 * 1) Si hay URL IGDB → usarla directamente (prioridad absoluta)
 * 2) Si no hay URL → búsqueda por título con filtros inteligentes:
 *    - Familia de título (normalización)
 *    - Filtro por año (si está en la hoja)
 *    - Filtro por plataforma PS3
 *    - Descarte de "Part II", "Remastered", etc. si no están en el título de hoja
 *    - Desempate: juego más antiguo
 * 
 * @param {string} titulo - Título del juego a buscar
 * @param {string} link - URL de IGDB (opcional, pero prioritaria)
 * @param {string} anioHoja - Año de la hoja (opcional, para filtrar/desempatar)
 * @returns {Object} - Objeto con estructura compatible con el sistema de fichas
 */
function fetchPS3_fromIGDB_(titulo, link, anioHoja) {
  // ============================================
  // CONSTANTES Y CONFIGURACIÓN
  // ============================================
  
  // ID de plataforma PS3 en IGDB
  const PS3_PLATFORM_ID = 9;
  
  // Términos a eliminar para obtener el "título base"
  const EDITION_TERMS = [
    'remastered', 'remaster', 'remake', 'remade',
    'definitive edition', 'definitive',
    'game of the year', 'goty', 'goty edition',
    'ultimate edition', 'ultimate',
    'complete edition', 'complete',
    'directors cut', 'director\'s cut',
    'extended edition', 'extended',
    'enhanced edition', 'enhanced',
    'special edition', 'special',
    'gold edition', 'gold',
    'platinum', 'platinum edition',
    'hd', 'hd edition', 'hd collection',
    'collection', 'anthology',
    'deluxe', 'deluxe edition',
    'legendary edition', 'legendary'
  ];
  
  // Términos de "parte/secuela" a detectar
  const PART_TERMS = [
    'part ii', 'part 2', 'part two',
    'part iii', 'part 3', 'part three',
    'part iv', 'part 4', 'part four',
    'ii', 'iii', 'iv', 'v', 'vi', 'vii', 'viii', 'ix', 'x',
    '2', '3', '4', '5', '6', '7', '8', '9', '10'
  ];
  
  // ============================================
  // OBJETO VACÍO (FALLBACK)
  // ============================================
  const emptyResult = {
    plataforma: 'PlayStation 3',
    titulo: titulo || 'Juego PS3',
    anio: '????',
    generoAnchors: [],
    subgeneroAnchors: [],
    publisherAnchors: [],
    desarrolladorAnchors: [],
    autorAnchors: [],
    contributorsAnchors: [],
    jugadoresAnchors: [],
    controlesAnchors: [],
    versionAnchors: [],
    distribuidorasAnchors: [],
    ratingDisplay: '',
    caratula: '',
    screenshots: [],
    imagenesAdicionales: [],
    mapa: '',
    instrucciones: '',
    video: '',
    revistas: [],
    sinopsis: ''
  };

  // ============================================
  // VARIABLES DE ENTRADA
  // ============================================
  const titleStr = String(titulo || '').trim();
  const linkStr = String(link || '').trim();
  const desiredYear = parseInt(String(anioHoja || '').trim(), 10);
  const hasDesiredYear = !isNaN(desiredYear);

  if (!titleStr && !linkStr) {
    Logger.log('[IGDB-PS3] Sin título ni link. Abortando.');
    return emptyResult;
  }

  // ============================================
  // HELPERS INTERNOS
  // ============================================
  
  /**
   * Extrae el año de un juego IGDB
   */
  function getYearFromGame_(game) {
    if (!game || !game.first_release_date) return null;
    const d = new Date(game.first_release_date * 1000);
    const y = d.getFullYear();
    return isNaN(y) ? null : y;
  }

  /**
   * Parsea una URL de IGDB para extraer ID y/o slug
   */
  function parseIgdbLink_(url) {
    if (!url) return { id: null, slug: null };
    try {
      const m = String(url).match(/igdb\.com\/games\/([^/?#]+)/i);
      if (!m) return { id: null, slug: null };
      const part = m[1]; // "1234-the-last-of-us" o "the-last-of-us"

      const idMatch = part.match(/^(\d+)-/);
      let id = null;
      let slug = null;

      if (idMatch) {
        id = parseInt(idMatch[1], 10);
        slug = part.substring(idMatch[0].length) || null;
      } else {
        slug = part || null;
      }

      if (isNaN(id)) id = null;
      Logger.log('[IGDB-PS3] parseIgdbLink_ url=' + url + ' → id=' + id + ', slug=' + slug);
      return { id: id, slug: slug };
    } catch (e) {
      Logger.log('[IGDB-PS3] parseIgdbLink_ EXCEPCIÓN: ' + e);
      return { id: null, slug: null };
    }
  }

  /**
   * Normaliza un título para comparación (título base)
   * - Minúsculas
   * - Sin acentos
   * - Sin puntuación
   * - Sin términos de edición (remastered, goty, etc.)
   * - Sin términos de parte (part ii, etc.) → para agrupar familia
   */
  function normalizeToBaseTitle_(text) {
    if (!text) return '';
    let s = String(text).toLowerCase().trim();
    
    // Quitar acentos
    s = s.normalize('NFD').replace(/[\u0300-\u036f]/g, '');
    
    // Quitar puntuación y caracteres especiales (dejar letras, números, espacios)
    s = s.replace(/[^a-z0-9\s]/g, ' ');
    
    // Quitar términos de edición
    EDITION_TERMS.forEach(function(term) {
      var re = new RegExp('\\b' + term.replace(/[.*+?^${}()|[\]\\]/g, '\\$&') + '\\b', 'gi');
      s = s.replace(re, ' ');
    });
    
    // Quitar términos de parte/secuela (para agrupar en familia)
    // Pero solo los que están al final o separados
    PART_TERMS.forEach(function(term) {
      // Solo quitar si está al final del título o separado
      var re = new RegExp('\\s+' + term.replace(/[.*+?^${}()|[\]\\]/g, '\\$&') + '(?:\\s+|$)', 'gi');
      s = s.replace(re, ' ');
    });
    
    // Colapsar espacios múltiples
    s = s.replace(/\s+/g, ' ').trim();
    
    return s;
  }

  /**
   * Comprueba si un texto contiene alguno de los términos de "parte/secuela"
   */
  function containsPartTerms_(text) {
    if (!text) return false;
    var lower = String(text).toLowerCase();
    
    // Patrones específicos para Part II, Part 2, etc.
    var partPatterns = [
      /\bpart\s*(ii|iii|iv|v|vi|vii|viii|ix|x|2|3|4|5|6|7|8|9|10)\b/i,
      /\b(ii|iii|iv|v|vi|vii|viii|ix|x)\s*$/i,  // Números romanos al final
      /\s+(2|3|4|5|6|7|8|9|10)\s*$/  // Números arábigos al final (con cuidado)
    ];
    
    for (var i = 0; i < partPatterns.length; i++) {
      if (partPatterns[i].test(lower)) return true;
    }
    
    return false;
  }

  /**
   * Comprueba si un texto contiene términos de edición especial
   */
  function containsEditionTerms_(text) {
    if (!text) return false;
    var lower = String(text).toLowerCase();
    
    for (var i = 0; i < EDITION_TERMS.length; i++) {
      var term = EDITION_TERMS[i];
      var re = new RegExp('\\b' + term.replace(/[.*+?^${}()|[\]\\]/g, '\\$&') + '\\b', 'i');
      if (re.test(lower)) return true;
    }
    
    return false;
  }

  /**
   * Comprueba si un juego tiene la plataforma PS3
   */
  function hasPS3Platform_(game) {
    if (!game || !Array.isArray(game.platforms)) return false;
    return game.platforms.some(function(p) {
      return p === PS3_PLATFORM_ID || (p && p.id === PS3_PLATFORM_ID);
    });
  }

  /**
   * Convierte un objeto game de IGDB al formato de salida
   */
  function gameToResult_(game) {
    var gameYear = getYearFromGame_(game);
    var anio = '????';
    if (gameYear) {
      anio = String(gameYear);
    }

    var generoAnchors = [];
    if (Array.isArray(game.genres)) {
      game.genres.forEach(function(g) {
        if (g && g.name) generoAnchors.push({ text: g.name, href: '' });
      });
    }

    // Themes de IGDB → Subgénero
    var subgeneroAnchors = [];
    if (Array.isArray(game.themes)) {
      game.themes.forEach(function(t) {
        if (t && t.name) subgeneroAnchors.push({ text: t.name, href: '' });
      });
    }

    var jugadoresAnchors = [];
    if (Array.isArray(game.game_modes)) {
      game.game_modes.forEach(function(m) {
        if (m && m.name) jugadoresAnchors.push({ text: m.name, href: '' });
      });
    }

    var publisherAnchors = [];
    var desarrolladorAnchors = [];
    if (Array.isArray(game.involved_companies)) {
      game.involved_companies.forEach(function(ic) {
        if (ic && ic.company && ic.company.name) {
          var companyName = ic.company.name;
          if (ic.publisher) publisherAnchors.push({ text: companyName, href: '' });
          if (ic.developer) desarrolladorAnchors.push({ text: companyName, href: '' });
        }
      });
    }

    var caratula = '';
    if (game.cover && game.cover.image_id) {
      caratula = 'https://images.igdb.com/igdb/image/upload/t_1080p/' + game.cover.image_id + '.jpg';
    }

    var screenshots = [];
    if (Array.isArray(game.screenshots)) {
      game.screenshots.slice(0, 4).forEach(function(s) {
        if (s && s.image_id) {
          screenshots.push('https://images.igdb.com/igdb/image/upload/t_1080p/' + s.image_id + '.jpg');
        }
      });
    }

    // ====================================
    // PROCESAR VÍDEOS DE IGDB
    // ====================================
    // IGDB devuelve videos como array con video_id (ID de YouTube)
    // Convertimos a URLs de YouTube en texto plano
    var videoUrl = '';
    if (Array.isArray(game.videos) && game.videos.length > 0) {
      var videoUrls = [];
      game.videos.forEach(function(v) {
        if (v && v.video_id) {
          // IGDB almacena el ID de YouTube directamente
          videoUrls.push('https://www.youtube.com/watch?v=' + v.video_id);
        }
      });
      // Guardamos solo el primer vídeo (el más representativo, normalmente el trailer principal)
      // Si quieres todos, cambia a: videoUrl = videoUrls.join(', ');
      if (videoUrls.length > 0) {
        videoUrl = videoUrls[0];
      }
    }

    var sinopsis = game.summary || '';
    
    // Argumento (storyline de IGDB) - campo separado de la sinopsis
    var argumento = game.storyline || '';

    var ratingDisplay = '';
    if (typeof game.aggregated_rating === 'number' && !isNaN(game.aggregated_rating)) {
      ratingDisplay = Math.round(game.aggregated_rating) + '/100';
    }

    return {
      plataforma: 'PlayStation 3',
      titulo: game.name || titulo,
      anio: anio,
      generoAnchors: generoAnchors,
      subgeneroAnchors: subgeneroAnchors,
      publisherAnchors: publisherAnchors,
      desarrolladorAnchors: desarrolladorAnchors,
      autorAnchors: [],
      contributorsAnchors: [],
      jugadoresAnchors: jugadoresAnchors,
      controlesAnchors: [],
      versionAnchors: [],
      distribuidorasAnchors: [],
      ratingDisplay: ratingDisplay,
      caratula: caratula,
      screenshots: screenshots,
      imagenesAdicionales: [],
      mapa: '',
      instrucciones: '',
      video: videoUrl,
      revistas: [],
      sinopsis: sinopsis,
      argumento: argumento
    };
  }

  /**
   * Ejecuta una query a IGDB y devuelve los resultados
   */
function fetchRatingByName_(gameName) {
    if (!gameName) return null;
    var query = 'fields name, aggregated_rating, rating; search "' + gameName.replace(/"/g, '\\"') + '"; where aggregated_rating != null | rating != null; limit 5;';
    var endpoint = 'https://api.igdb.com/v4/games';
    var options = {
      method: 'post',
      headers: {
        'Client-ID': IGDB_CLIENT_ID,
        'Authorization': 'Bearer ' + IGDB_ACCESS_TOKEN,
        'Content-Type': 'text/plain'
      },
      payload: query,
      muteHttpExceptions: true
    };
    try {
      var response = UrlFetchApp.fetch(endpoint, options);
      if (response.getResponseCode() !== 200) return null;
      var results = JSON.parse(response.getContentText());
      if (Array.isArray(results) && results.length > 0) {
        for (var i = 0; i < results.length; i++) {
          var g = results[i];
          Logger.log('[IGDB] Fallback rating encontrado en "' + g.name + '": aggregated=' + g.aggregated_rating + ', user=' + g.rating);
          if (typeof g.aggregated_rating === 'number' && !isNaN(g.aggregated_rating)) {
            return Math.round(g.aggregated_rating);
          } else if (typeof g.rating === 'number' && !isNaN(g.rating)) {
            return Math.round(g.rating);
          }
        }
      }
    } catch (e) {
      Logger.log('[IGDB] Error buscando rating por nombre: ' + e);
    }
    return null;
  }
  function executeIgdbQuery_(query) {
    var endpoint = 'https://api.igdb.com/v4/games';
    var options = {
      method: 'post',
      headers: {
        'Client-ID': IGDB_CLIENT_ID,
        'Authorization': 'Bearer ' + IGDB_ACCESS_TOKEN,
        'Content-Type': 'text/plain'
      },
      payload: query,
      muteHttpExceptions: true
    };

    var response = UrlFetchApp.fetch(endpoint, options);
    var code = response.getResponseCode();

    if (code !== 200) {
      Logger.log('[IGDB-PS3] Error HTTP ' + code + ': ' + response.getContentText());
      return null;
    }

    var results = JSON.parse(response.getContentText());
    return Array.isArray(results) ? results : null;
  }

  // ============================================
  // LÓGICA PRINCIPAL
  // ============================================
  
  try {
    // Campos a solicitar de IGDB (incluimos platforms para filtrar y videos para trailers)
    var fieldsBlock =
      'fields name, slug, first_release_date, aggregated_rating, ' +
      'genres.name, ' +
      'themes.name, ' +
      'game_modes.name, ' +
      'involved_companies.company.name, ' +
      'involved_companies.developer, ' +
      'involved_companies.publisher, ' +
      'cover.image_id, ' +
      'screenshots.image_id, ' +
      'videos.video_id, ' +
      'videos.name, ' +
      'summary, ' +
      'storyline, ' +
      'platforms;';

    // ============================================
    // CASO 1: HAY URL IGDB → PRIORIDAD ABSOLUTA
    // ============================================
    if (linkStr) {
      var parsedLink = parseIgdbLink_(linkStr);
      var query = null;

      if (parsedLink.id) {
        query = fieldsBlock + ' where id = ' + parsedLink.id + '; limit 1;';
        Logger.log('[IGDB-PS3] 🔗 Usando URL por ID: ' + parsedLink.id);
      } else if (parsedLink.slug) {
        var safeSlug = parsedLink.slug.replace(/"/g, '\\"');
        query = fieldsBlock + ' where slug = "' + safeSlug + '"; limit 1;';
        Logger.log('[IGDB-PS3] 🔗 Usando URL por slug: ' + safeSlug);
      }

      if (query) {
        var results = executeIgdbQuery_(query);
        if (results && results.length > 0) {
          var game = results[0];
          Logger.log('[IGDB-PS3] ✅ Juego encontrado por URL: ' + (game.name || 'N/A'));
          return gameToResult_(game);
        }
        Logger.log('[IGDB-PS3] ⚠️ URL válida pero sin resultados. Intentando búsqueda por título...');
      } else {
        Logger.log('[IGDB-PS3] ⚠️ URL presente pero no parseable. Intentando búsqueda por título...');
      }
      // Si la URL no dio resultados, continuamos con búsqueda por título
    }

    // ============================================
    // CASO 2: BÚSQUEDA POR TÍTULO
    // ============================================
    if (!titleStr) {
      Logger.log('[IGDB-PS3] Sin título para buscar. Abortando.');
      return emptyResult;
    }

    var safeTitle = titleStr.replace(/"/g, '\\"');
    
    // Búsqueda amplia (limit 20 para tener más candidatos)
    var searchQuery = fieldsBlock + ' search "' + safeTitle + '"; limit 20;';
    
    Logger.log('[IGDB-PS3] 🔍 Buscando por título: "' + titleStr + '" (año hoja: ' + (hasDesiredYear ? desiredYear : 'N/A') + ')');
    
    var results = executeIgdbQuery_(searchQuery);
    
    if (!results || results.length === 0) {
      Logger.log('[IGDB-PS3] ❌ Sin resultados para: ' + titleStr);
      return emptyResult;
    }

    Logger.log('[IGDB-PS3] Encontrados ' + results.length + ' candidatos iniciales');

    // ============================================
    // FILTRADO INTELIGENTE DE CANDIDATOS
    // ============================================
    
    var candidates = results.slice(); // Copia del array
    var sheetBaseTitle = normalizeToBaseTitle_(titleStr);
    var sheetHasPartTerms = containsPartTerms_(titleStr);
    var sheetHasEditionTerms = containsEditionTerms_(titleStr);
    
    Logger.log('[IGDB-PS3] Título hoja base: "' + sheetBaseTitle + '"');
    Logger.log('[IGDB-PS3] Título hoja tiene Part terms: ' + sheetHasPartTerms);
    Logger.log('[IGDB-PS3] Título hoja tiene Edition terms: ' + sheetHasEditionTerms);

    // --------------------------------------------
    // PASO 3.1: Filtrar por "familia de título"
    // --------------------------------------------
    var familyFiltered = candidates.filter(function(g) {
      var gameBaseTitle = normalizeToBaseTitle_(g.name);
      return gameBaseTitle === sheetBaseTitle;
    });
    
    if (familyFiltered.length > 0) {
      Logger.log('[IGDB-PS3] Filtro familia: ' + familyFiltered.length + ' juegos coinciden con título base');
      candidates = familyFiltered;
    } else {
      Logger.log('[IGDB-PS3] Filtro familia: ninguno coincide exactamente, manteniendo todos');
    }

    // --------------------------------------------
    // PASO 3.2: Filtrar por año (si hay año en hoja)
    // --------------------------------------------
    if (hasDesiredYear && candidates.length > 1) {
      var yearFiltered = candidates.filter(function(g) {
        var gameYear = getYearFromGame_(g);
        return gameYear === desiredYear;
      });
      
      if (yearFiltered.length > 0) {
        Logger.log('[IGDB-PS3] Filtro año ' + desiredYear + ': ' + yearFiltered.length + ' juegos coinciden');
        candidates = yearFiltered;
      } else {
        Logger.log('[IGDB-PS3] Filtro año: ninguno coincide con ' + desiredYear + ', manteniendo anteriores');
      }
    }

    // --------------------------------------------
    // PASO 3.3: Filtrar por plataforma PS3
    // --------------------------------------------
    if (candidates.length > 1) {
      var ps3Filtered = candidates.filter(function(g) {
        return hasPS3Platform_(g);
      });
      
      if (ps3Filtered.length > 0) {
        Logger.log('[IGDB-PS3] Filtro PS3: ' + ps3Filtered.length + ' juegos tienen plataforma PS3');
        candidates = ps3Filtered;
      } else {
        Logger.log('[IGDB-PS3] Filtro PS3: ninguno tiene PS3 explícito, manteniendo anteriores');
      }
    }

    // --------------------------------------------
    // PASO 3.4: Descartar Part II / Remastered si el título de hoja no los tiene
    // --------------------------------------------
    var beforeVariantFilter = candidates.slice(); // Guardar por si el filtro es muy agresivo
    
    if (candidates.length > 1) {
      // Si el título de la hoja NO tiene "Part II", descartar juegos que sí lo tengan
      if (!sheetHasPartTerms) {
        var noPartFiltered = candidates.filter(function(g) {
          return !containsPartTerms_(g.name);
        });
        if (noPartFiltered.length > 0) {
          Logger.log('[IGDB-PS3] Descartando variantes "Part II": de ' + candidates.length + ' a ' + noPartFiltered.length);
          candidates = noPartFiltered;
        }
      }
      
      // Si el título de la hoja NO tiene términos de edición, descartar los que sí
      if (!sheetHasEditionTerms && candidates.length > 1) {
        var noEditionFiltered = candidates.filter(function(g) {
          return !containsEditionTerms_(g.name);
        });
        if (noEditionFiltered.length > 0) {
          Logger.log('[IGDB-PS3] Descartando variantes "Remastered/Edition": de ' + candidates.length + ' a ' + noEditionFiltered.length);
          candidates = noEditionFiltered;
        }
      }
    }
    
    // Si el filtro dejó vacío el array, volver al estado anterior
    if (candidates.length === 0) {
      Logger.log('[IGDB-PS3] Filtro de variantes demasiado agresivo, restaurando candidatos anteriores');
      candidates = beforeVariantFilter;
    }

    // --------------------------------------------
    // PASO 3.5: Desempate final (el más antiguo)
    // --------------------------------------------
    if (candidates.length > 1) {
      candidates.sort(function(a, b) {
        var yearA = getYearFromGame_(a) || 9999;
        var yearB = getYearFromGame_(b) || 9999;
        return yearA - yearB; // Más antiguo primero
      });
      Logger.log('[IGDB-PS3] Desempate por antigüedad: seleccionando el más antiguo');
    }

    // Seleccionar el primer candidato (el mejor según todos los filtros)
    var selectedGame = candidates[0];
    
    Logger.log('[IGDB-PS3] ✅ Seleccionado: "' + (selectedGame.name || 'N/A') + '" (' + (getYearFromGame_(selectedGame) || '????') + ')');
    
    return gameToResult_(selectedGame);

  } catch (e) {
    Logger.log('[IGDB-PS3] ❌ Excepción: ' + e);
    return emptyResult;
  }
}



// ============================================
// ESCRITURA EN HOJA PS3 (SOLO CELDAS VACÍAS)
// ============================================
// ⚠️ IMPORTANTE: Esta función NO toca las columnas manuales:
//    - PS3_UBICACION
//    - PS3_TIPO_FORMATO
//    - FAVORITO
//    - TERMINADO
//    - MAS_INFO
// Esas columnas se leen y muestran en la ficha, pero nunca se sobreescriben.
// ============================================
function writeBackPS3RowFromData_(sh, row, headers, data) {
  if (!data) return;

  // ---------- Helpers internos ----------
  function normalizeHeaderKey_(s) {
    let t = String(s || '').toLowerCase().trim();
    t = t
      .replace(/[áàäâ]/g, 'a')
      .replace(/[éèëê]/g, 'e')
      .replace(/[íìïî]/g, 'i')
      .replace(/[óòöô]/g, 'o')
      .replace(/[úùüû]/g, 'u')
      .replace(/ñ/g, 'n');
    t = t.replace(/\s+/g, ' ');
    return t;
  }

  function colIndex_(name) {
    const target = normalizeHeaderKey_((name || ''));
    for (let i = 0; i < headers.length; i++) {
      const hKey = normalizeHeaderKey_(headers[i]);
      if (hKey === target) return i + 1;
    }
    return 0;
  }

  function cleanValue_(v) {
    if (v == null) return '';
    let t = String(v).trim();
    if (!t) return '';
    if (t === '????') return '';                        // no escribimos placeholders
    if (/^dato no disponible$/i.test(t)) return '';     // tampoco este texto
    return t;
  }

 function writeIfEmpty_(colName, value) {
  const col = colIndex_(colName || '');
  const v = cleanValue_(value);
  if (!col || !v) return;

  const rng = sh.getRange(row, col);
  const current = String(rng.getValue() || '').trim();
  if (!current) {
    rng.setValue(v);
  }
}

  function anchorsToText_(arr) {
    return (Array.isArray(arr) ? arr : [])
      .map(a => (a && a.text) ? String(a.text) : '')
      .filter(Boolean)
      .join(', ');
  }

  // ---------- Aplanar datos ----------
  const anio = data.anio || '';
  const genero = anchorsToText_(data.generoAnchors);
  const subgenero = anchorsToText_(data.subgeneroAnchors);
  const publisher = anchorsToText_(data.publisherAnchors);
  const desarrollo = anchorsToText_(data.desarrolladorAnchors);
  const jugadores = anchorsToText_(data.jugadoresAnchors);
  const controles = anchorsToText_(data.controlesAnchors);
  const version = anchorsToText_(data.versionAnchors);
  const distrib = anchorsToText_(data.distribuidorasAnchors);
  const rating = data.ratingDisplay || '';
  const caratula = data.caratula || '';
  const screenshots = Array.isArray(data.screenshots) ? data.screenshots.join(', ') : '';
  const sinopsis = data.sinopsis || '';
  const video = data.video || '';
  const argumento = data.argumento || '';

  // ---------- Escritura en columnas PS3 ----------
  writeIfEmpty_('AÑO', anio);
  writeIfEmpty_('PUNTUACIÓN', rating);
  writeIfEmpty_('GÉNERO', genero);
  writeIfEmpty_('SUBGÉNERO', subgenero);
  writeIfEmpty_('PUBLISHER', publisher);
  writeIfEmpty_('DESARROLLO', desarrollo);
  writeIfEmpty_('JUGADORES', jugadores);
  writeIfEmpty_('CONTROLES', controles);
  writeIfEmpty_('VERSIÓN', version);
  writeIfEmpty_('DISTRIBUIDORAS', distrib);
  writeIfEmpty_('CARÁTULA', caratula);
  writeIfEmpty_('SCREENSHOTS', screenshots);
  writeIfEmpty_('SINOPSIS', sinopsis);
  writeIfEmpty_('VIDEO', video);
  writeIfEmpty_('ARGUMENTO', argumento);
}

/**global
 * ============================================
 * GENERADOR DE FICHAS ZX SPECTRUM - v2.0
 * ============================================
 * 
 * PARTE 1: CONSTANTES, MENÚS Y FUNCIÓN PRINCIPAL
 * 
 * Este archivo contiene:
 * - Configuración global
 * - Menús de Google Sheets
 * - Función principal de preview de fichas
 * 
 * ============================================
 */
// =====================================
// IGDB CONFIG — RELLENAR CON TUS DATOS
// =====================================
const IGDB_CLIENT_ID = '690ect4klrsg9vr5g2vaub27wjjo5i';
const IGDB_ACCESS_TOKEN = '2a2pcx8h9e36umavdk8eikzi1pr8ic';


// ============================================
// CONSTANTES GLOBALES
// ============================================

const FALLBACK_COVER_URL = 'https://raw.githubusercontent.com/Lesbeziers/MI-COLECCION-DE-VIDEOJUEGOS/main/assets/img/CaratulaNoDisponible.png';
const FALLBACK_COVER_URL_C64 = 'https://raw.githubusercontent.com/Lesbeziers/MI-COLECCION-DE-VIDEOJUEGOS/main/assets/img/CaratulaNoDisponible_C64.png';

// ============================================
// BLOQUE NUEVO v3.0: MOTOR IGDB GENÉRICO
// ============================================
// ============================================
// BLOQUE NUEVO v3.0: MOTOR IGDB GENÉRICO
// ============================================
// INSTRUCCIONES: 
// 1. Copia este bloque COMPLETO
// 2. Pégalo en tu script DESPUÉS de las constantes (IGDB_CLIENT_ID, etc.)
//    y ANTES de la función onOpen()
// 3. Reemplaza la función onOpen() existente con la nueva versión de abajo
// ============================================

// ============================================
// HELPERS DE CONFIGURACIÓN DE PLATAFORMA
// ============================================

/**
 * Lee CONFIG_PLATAFORMAS y devuelve la configuración para una hoja de datos.
 * Usa lectura por cabeceras (no por índices).
 */
function getPlatformConfigByDataSheet_(sheetName) {
  const ss = SpreadsheetApp.getActive();
  const configSheet = ss.getSheetByName('CONFIG_PLATAFORMAS');
  
  if (!configSheet) {
    Logger.log('[CONFIG] ERROR: No se encuentra la hoja CONFIG_PLATAFORMAS');
    return null;
  }
  
  const lastRow = configSheet.getLastRow();
  const lastCol = configSheet.getLastColumn();
  
  if (lastRow < 2 || lastCol < 1) {
    Logger.log('[CONFIG] ERROR: CONFIG_PLATAFORMAS está vacía o sin datos');
    return null;
  }
  
  const headers = configSheet.getRange(1, 1, 1, lastCol).getValues()[0];
  
  const colIdx = {};
  headers.forEach((h, i) => {
    const key = String(h || '').trim().toUpperCase();
    if (key) colIdx[key] = i;
  });
  
  const requiredCols = ['PLATFORM_KEY', 'DATA_SHEET', 'SOURCE_TYPE'];
  for (const col of requiredCols) {
    if (colIdx[col] === undefined) {
      Logger.log('[CONFIG] ERROR: Falta columna requerida: ' + col);
      return null;
    }
  }
  
  const data = configSheet.getRange(2, 1, lastRow - 1, lastCol).getValues();
  const targetSheet = String(sheetName || '').trim().toUpperCase();
  
  for (const row of data) {
    const dataSheetVal = String(row[colIdx['DATA_SHEET']] || '').trim().toUpperCase();
    
    if (dataSheetVal === targetSheet) {
      const config = {
        platformKey: String(row[colIdx['PLATFORM_KEY']] || '').trim(),
        dataSheet: String(row[colIdx['DATA_SHEET']] || '').trim(),
        listSheet: colIdx['LIST_SHEET'] !== undefined ? String(row[colIdx['LIST_SHEET']] || '').trim() : '',
        sourceType: String(row[colIdx['SOURCE_TYPE']] || '').trim().toUpperCase(),
        igdbPlatformId: null,
        coverLayout: colIdx['COVER_LAYOUT'] !== undefined ? String(row[colIdx['COVER_LAYOUT']] || '').trim() : '',
        extraFieldsRaw: colIdx['EXTRA_FIELDS'] !== undefined ? String(row[colIdx['EXTRA_FIELDS']] || '').trim() : '',
        nombreVisible: colIdx['NOMBRE_VISIBLE'] !== undefined ? String(row[colIdx['NOMBRE_VISIBLE']] || '').trim() : ''
      };
      
      if (colIdx['IGDB_PLATFORM_ID'] !== undefined) {
        const rawId = row[colIdx['IGDB_PLATFORM_ID']];
        if (rawId !== null && rawId !== '' && !isNaN(Number(rawId))) {
          config.igdbPlatformId = parseInt(Number(rawId), 10);
        }
      }
      
      Logger.log('[CONFIG] Configuración encontrada para "' + sheetName + '": ' + JSON.stringify(config));
      return config;
    }
  }
  
  Logger.log('[CONFIG] AVISO: No se encontró configuración para hoja "' + sheetName + '"');
  return null;
}

/**
 * Obtiene la configuración de la plataforma basándose en la hoja activa.
 */
function getActivePlatformConfig_() {
  const sh = SpreadsheetApp.getActiveSheet();
  if (!sh) {
    Logger.log('[CONFIG] ERROR: No hay hoja activa');
    return null;
  }
  return getPlatformConfigByDataSheet_(sh.getName().trim());
}

// ============================================
// MOTOR IGDB GENÉRICO
// ============================================

/**
 * Motor IGDB genérico para buscar datos de un juego.
 * Reutilizable por PS3, SWITCH y futuras plataformas IGDB.
 */
function fetchIGDB_(igdbPlatformId, titulo, igdbUrl, anioHoja, nombrePlataforma) {
  const platformName = nombrePlataforma || ('Plataforma IGDB #' + igdbPlatformId);
  
  const EDITION_TERMS = [
    'remastered', 'remaster', 'remake', 'remade',
    'definitive edition', 'definitive',
    'game of the year', 'goty', 'goty edition',
    'ultimate edition', 'ultimate',
    'complete edition', 'complete',
    'directors cut', 'director\'s cut',
    'extended edition', 'extended',
    'enhanced edition', 'enhanced',
    'special edition', 'special',
    'gold edition', 'gold',
    'platinum', 'platinum edition',
    'hd', 'hd edition', 'hd collection',
    'collection', 'anthology',
    'deluxe', 'deluxe edition',
    'legendary edition', 'legendary'
  ];
  
  const PART_TERMS = [
    'part ii', 'part 2', 'part two',
    'part iii', 'part 3', 'part three',
    'part iv', 'part 4', 'part four',
    'ii', 'iii', 'iv', 'v', 'vi', 'vii', 'viii', 'ix', 'x',
    '2', '3', '4', '5', '6', '7', '8', '9', '10'
  ];
  
  const emptyResult = {
    plataforma: platformName,
    titulo: titulo || 'Juego',
    anio: '????',
    generoAnchors: [],
    subgeneroAnchors: [],
    publisherAnchors: [],
    desarrolladorAnchors: [],
    autorAnchors: [],
    contributorsAnchors: [],
    jugadoresAnchors: [],
    controlesAnchors: [],
    versionAnchors: [],
    distribuidorasAnchors: [],
    ratingDisplay: '',
    caratula: '',
    screenshots: [],
    imagenesAdicionales: [],
    mapa: '',
    instrucciones: '',
    video: '',
    revistas: [],
    sinopsis: '',
    argumento: ''
  };

  const titleStr = String(titulo || '').trim();
  const linkStr = String(igdbUrl || '').trim();
  const desiredYear = parseInt(String(anioHoja || '').trim(), 10);
  const hasDesiredYear = !isNaN(desiredYear);

  if (!titleStr && !linkStr) {
    Logger.log('[IGDB] Sin título ni link. Abortando.');
    return emptyResult;
  }

  function getYearFromGame_(game) {
    if (!game || !game.first_release_date) return null;
    const d = new Date(game.first_release_date * 1000);
    const y = d.getFullYear();
    return isNaN(y) ? null : y;
  }

  function parseIgdbLink_(url) {
    if (!url) return { id: null, slug: null };
    try {
      const m = String(url).match(/igdb\.com\/games\/([^/?#]+)/i);
      if (!m) return { id: null, slug: null };
      const part = m[1];
      const idMatch = part.match(/^(\d+)-/);
      let id = null, slug = null;
      if (idMatch) {
        id = parseInt(idMatch[1], 10);
        slug = part.substring(idMatch[0].length) || null;
      } else {
        slug = part || null;
      }
      if (isNaN(id)) id = null;
      return { id: id, slug: slug };
    } catch (e) {
      return { id: null, slug: null };
    }
  }

  function normalizeToBaseTitle_(text) {
    if (!text) return '';
    let s = String(text).toLowerCase().trim();
    s = s.normalize('NFD').replace(/[\u0300-\u036f]/g, '');
    s = s.replace(/[^a-z0-9\s]/g, ' ');
    EDITION_TERMS.forEach(function(term) {
      var re = new RegExp('\\b' + term.replace(/[.*+?^${}()|[\]\\]/g, '\\$&') + '\\b', 'gi');
      s = s.replace(re, ' ');
    });
    PART_TERMS.forEach(function(term) {
      var re = new RegExp('\\s+' + term.replace(/[.*+?^${}()|[\]\\]/g, '\\$&') + '(?:\\s+|$)', 'gi');
      s = s.replace(re, ' ');
    });
    return s.replace(/\s+/g, ' ').trim();
  }

  function containsPartTerms_(text) {
    if (!text) return false;
    var lower = String(text).toLowerCase();
    var partPatterns = [
      /\bpart\s*(ii|iii|iv|v|vi|vii|viii|ix|x|2|3|4|5|6|7|8|9|10)\b/i,
      /\b(ii|iii|iv|v|vi|vii|viii|ix|x)\s*$/i,
      /\s+(2|3|4|5|6|7|8|9|10)\s*$/
    ];
    for (var i = 0; i < partPatterns.length; i++) {
      if (partPatterns[i].test(lower)) return true;
    }
    return false;
  }

  function containsEditionTerms_(text) {
    if (!text) return false;
    var lower = String(text).toLowerCase();
    for (var i = 0; i < EDITION_TERMS.length; i++) {
      var term = EDITION_TERMS[i];
      var re = new RegExp('\\b' + term.replace(/[.*+?^${}()|[\]\\]/g, '\\$&') + '\\b', 'i');
      if (re.test(lower)) return true;
    }
    return false;
  }

  function hasPlatform_(game, platformId) {
    if (!game || !Array.isArray(game.platforms)) return false;
    return game.platforms.some(function(p) {
      return p === platformId || (p && p.id === platformId);
    });
  }

  function gameToResult_(game) {
    var gameYear = getYearFromGame_(game);
    var anio = gameYear ? String(gameYear) : '????';

    var generoAnchors = [];
    if (Array.isArray(game.genres)) {
      game.genres.forEach(function(g) {
        if (g && g.name) generoAnchors.push({ text: g.name, href: '' });
      });
    }

    var subgeneroAnchors = [];
    if (Array.isArray(game.themes)) {
      game.themes.forEach(function(t) {
        if (t && t.name) subgeneroAnchors.push({ text: t.name, href: '' });
      });
    }

    var jugadoresAnchors = [];
    if (Array.isArray(game.game_modes)) {
      game.game_modes.forEach(function(m) {
        if (m && m.name) jugadoresAnchors.push({ text: m.name, href: '' });
      });
    }

    var publisherAnchors = [];
    var desarrolladorAnchors = [];
    if (Array.isArray(game.involved_companies)) {
      game.involved_companies.forEach(function(ic) {
        if (ic && ic.company && ic.company.name) {
          var companyName = ic.company.name;
          if (ic.publisher) publisherAnchors.push({ text: companyName, href: '' });
          if (ic.developer) desarrolladorAnchors.push({ text: companyName, href: '' });
        }
      });
    }

    var caratula = '';
    if (game.cover && game.cover.image_id) {
      caratula = 'https://images.igdb.com/igdb/image/upload/t_1080p/' + game.cover.image_id + '.jpg';
    }

    var screenshots = [];
    if (Array.isArray(game.screenshots)) {
      game.screenshots.slice(0, 4).forEach(function(s) {
        if (s && s.image_id) {
          screenshots.push('https://images.igdb.com/igdb/image/upload/t_1080p/' + s.image_id + '.jpg');
        }
      });
    }

var videoUrl = '';
    if (Array.isArray(game.videos) && game.videos.length > 0) {
      game.videos.forEach(function(v) {
        if (v && v.video_id && !videoUrl) {
          videoUrl = 'https://www.youtube.com/watch?v=' + v.video_id;
        }
      });
    }

    // Rating con fallback: primero critic, luego user, luego juego padre
    Logger.log('[IGDB DEBUG] aggregated_rating: ' + game.aggregated_rating + ', rating: ' + game.rating + ', version_parent: ' + game.version_parent);
    var ratingValue = null;
    if (typeof game.aggregated_rating === 'number' && !isNaN(game.aggregated_rating)) {
      ratingValue = Math.round(game.aggregated_rating);
    } else if (typeof game.rating === 'number' && !isNaN(game.rating)) {
      ratingValue = Math.round(game.rating);
} else {
      Logger.log('[IGDB] Sin rating local, buscando por nombre...');
      ratingValue = fetchRatingByName_(game.name);
    }

    return {
      plataforma: platformName,
      titulo: game.name || titulo,
      anio: anio,
      generoAnchors: generoAnchors,
      subgeneroAnchors: subgeneroAnchors,
      publisherAnchors: publisherAnchors,
      desarrolladorAnchors: desarrolladorAnchors,
      autorAnchors: [],
      contributorsAnchors: [],
      jugadoresAnchors: jugadoresAnchors,
      controlesAnchors: [],
      versionAnchors: [],
      distribuidorasAnchors: [],
ratingDisplay: ratingValue !== null ? ratingValue + '/100' : '',
      caratula: caratula,
      screenshots: screenshots,
      imagenesAdicionales: [],
      mapa: '',
      instrucciones: '',
      video: videoUrl,
      revistas: [],
      sinopsis: game.summary || '',
      argumento: game.storyline || ''
    };
  }
function fetchRatingByName_(gameName) {
    if (!gameName) return null;
    var query = 'fields name, aggregated_rating, rating; search "' + gameName.replace(/"/g, '\\"') + '"; where aggregated_rating != null | rating != null; limit 5;';
    var endpoint = 'https://api.igdb.com/v4/games';
    var options = {
      method: 'post',
      headers: {
        'Client-ID': IGDB_CLIENT_ID,
        'Authorization': 'Bearer ' + IGDB_ACCESS_TOKEN,
        'Content-Type': 'text/plain'
      },
      payload: query,
      muteHttpExceptions: true
    };
    try {
      var response = UrlFetchApp.fetch(endpoint, options);
      if (response.getResponseCode() !== 200) return null;
      var results = JSON.parse(response.getContentText());
      if (Array.isArray(results) && results.length > 0) {
        for (var i = 0; i < results.length; i++) {
          var g = results[i];
          Logger.log('[IGDB] Fallback rating encontrado en "' + g.name + '": aggregated=' + g.aggregated_rating + ', user=' + g.rating);
          if (typeof g.aggregated_rating === 'number' && !isNaN(g.aggregated_rating)) {
            return Math.round(g.aggregated_rating);
          } else if (typeof g.rating === 'number' && !isNaN(g.rating)) {
            return Math.round(g.rating);
          }
        }
      }
    } catch (e) {
      Logger.log('[IGDB] Error buscando rating por nombre: ' + e);
    }
    return null;
  }
  function executeIgdbQuery_(query) {
    var endpoint = 'https://api.igdb.com/v4/games';
    var options = {
      method: 'post',
      headers: {
        'Client-ID': IGDB_CLIENT_ID,
        'Authorization': 'Bearer ' + IGDB_ACCESS_TOKEN,
        'Content-Type': 'text/plain'
      },
      payload: query,
      muteHttpExceptions: true
    };
    var response = UrlFetchApp.fetch(endpoint, options);
    if (response.getResponseCode() !== 200) {
      Logger.log('[IGDB] Error HTTP ' + response.getResponseCode());
      return null;
    }
    var results = JSON.parse(response.getContentText());
    return Array.isArray(results) ? results : null;
  }

  try {
var fieldsBlock =
      'fields name, slug, first_release_date, aggregated_rating, rating, version_parent, ' +
      'genres.name, themes.name, game_modes.name, ' +
      'involved_companies.company.name, involved_companies.developer, involved_companies.publisher, ' +
      'cover.image_id, screenshots.image_id, videos.video_id, summary, storyline, platforms;';

    if (linkStr) {
      var parsedLink = parseIgdbLink_(linkStr);
      var query = null;
      if (parsedLink.id) {
        query = fieldsBlock + ' where id = ' + parsedLink.id + '; limit 1;';
      } else if (parsedLink.slug) {
        query = fieldsBlock + ' where slug = "' + parsedLink.slug.replace(/"/g, '\\"') + '"; limit 1;';
      }
      if (query) {
        var results = executeIgdbQuery_(query);
        if (results && results.length > 0) {
          Logger.log('[IGDB] Juego encontrado por URL: ' + results[0].name);
          return gameToResult_(results[0]);
        }
      }
    }

    if (!titleStr) return emptyResult;

    var searchQuery = fieldsBlock + ' search "' + titleStr.replace(/"/g, '\\"') + '"; limit 20;';
    Logger.log('[IGDB] Buscando: "' + titleStr + '" (plataforma: ' + igdbPlatformId + ')');
    
    var results = executeIgdbQuery_(searchQuery);
    if (!results || results.length === 0) return emptyResult;

    var candidates = results.slice();
    var sheetBaseTitle = normalizeToBaseTitle_(titleStr);
    var sheetHasPartTerms = containsPartTerms_(titleStr);
    var sheetHasEditionTerms = containsEditionTerms_(titleStr);

    // Filtro familia
    var familyFiltered = candidates.filter(function(g) {
      return normalizeToBaseTitle_(g.name) === sheetBaseTitle;
    });
    if (familyFiltered.length > 0) candidates = familyFiltered;

    // Filtro año
    if (hasDesiredYear && candidates.length > 1) {
      var yearFiltered = candidates.filter(function(g) {
        return getYearFromGame_(g) === desiredYear;
      });
      if (yearFiltered.length > 0) candidates = yearFiltered;
    }

    // Filtro plataforma
    if (candidates.length > 1 && igdbPlatformId) {
      var platformFiltered = candidates.filter(function(g) {
        return hasPlatform_(g, igdbPlatformId);
      });
      if (platformFiltered.length > 0) candidates = platformFiltered;
    }

    // Filtro variantes
    var beforeVariantFilter = candidates.slice();
    if (candidates.length > 1 && !sheetHasPartTerms) {
      var noPartFiltered = candidates.filter(function(g) { return !containsPartTerms_(g.name); });
      if (noPartFiltered.length > 0) candidates = noPartFiltered;
    }
    if (candidates.length > 1 && !sheetHasEditionTerms) {
      var noEditionFiltered = candidates.filter(function(g) { return !containsEditionTerms_(g.name); });
      if (noEditionFiltered.length > 0) candidates = noEditionFiltered;
    }
    if (candidates.length === 0) candidates = beforeVariantFilter;

    // Desempate por antigüedad
    if (candidates.length > 1) {
      candidates.sort(function(a, b) {
        return (getYearFromGame_(a) || 9999) - (getYearFromGame_(b) || 9999);
      });
    }

    Logger.log('[IGDB] Seleccionado: ' + candidates[0].name + ' (ID: ' + candidates[0].id + ')');
    return gameToResult_(candidates[0]);

  } catch (e) {
    Logger.log('[IGDB] Excepción: ' + e);
    return emptyResult;
  }
}

// ============================================
// ENTRY POINT: ACTUALIZAR DESDE IGDB (FILA ACTUAL)
// ============================================

// ============================================
// CAMBIO 2: NUEVA FUNCIÓN menuActualizarFilaActual()
// (Reemplaza la función menuActualizarFilaActual existente)
// Ahora incluye la generación de ficha lateral como ZX Spectrum
// ============================================

function menuActualizarFilaActual() {
  const ui = SpreadsheetApp.getUi();
  const sh = SpreadsheetApp.getActiveSheet();
  const row = sh.getActiveCell() ? sh.getActiveCell().getRow() : 0;
  
  if (!row || row === 1) {
    return uiAlert_('Selecciona una fila con datos (no la cabecera).');
  }
  
  const cfg = getActivePlatformConfig_();
  
  if (!cfg) {
    return uiAlert_('La hoja "' + sh.getName() + '" no está configurada en CONFIG_PLATAFORMAS.\n\nHojas válidas: PS3, SWITCH, ZX_SPECTRUM');
  }
  
  Logger.log('[MENU] Plataforma: ' + cfg.platformKey + ' (SOURCE_TYPE=' + cfg.sourceType + ')');
  
  // ============================================
  // FLUJO IGDB (PS3, SWITCH, futuras plataformas)
  // ============================================
  if (cfg.sourceType === 'IGDB') {
    if (!cfg.igdbPlatformId) {
      return uiAlert_('Error: La plataforma "' + cfg.platformKey + '" no tiene IGDB_PLATFORM_ID configurado.');
    }
    
    const headers = sh.getRange(1, 1, 1, Math.max(1, sh.getLastColumn())).getValues()[0];
    
    const normalizeHeader = (s) => String(s || '').trim().toUpperCase()
      .normalize('NFD').replace(/[\u0300-\u036f]/g, '').replace(/\s+/g, '_');
    
    const get = (h) => {
      let i = headers.indexOf(h);
      if (i > -1) return sh.getRange(row, i + 1).getValue();
      const hNorm = normalizeHeader(h);
      for (let j = 0; j < headers.length; j++) {
        if (normalizeHeader(headers[j]) === hNorm) return sh.getRange(row, j + 1).getValue();
      }
      return '';
    };
    
    // ====================================
    // LEER TÍTULO Y URL
    // ====================================
    const titulo = get('TÍTULO') || get('TITULO');
    if (!titulo) return uiAlert_('Falta el campo "TÍTULO" / "TITULO" en la fila.');
    
    const igdbUrl = get('IGDB_URL') || '';
    const anioHoja = String(get('AÑO') || '').trim();
    
    Logger.log('[IGDB] Título: ' + titulo + ' | IGDB_URL: ' + igdbUrl);
    
    // ====================================
    // LEER COLUMNAS MANUALES (varían por plataforma)
    // ====================================
    const prefijo = cfg.platformKey; // PS3, SWITCH, etc.
    const columnasManual = {
      ubicacion: String(get(prefijo + '_UBICACION') || '').trim(),
      tipoFormato: String(get(prefijo + '_TIPO_FORMATO') || '').trim(),
      favorito: String(get('FAVORITO') || '').trim(),
      terminado: String(get('TERMINADO') || '').trim(),
      masInfo: String(get('MAS_INFO') || ''),
      formato: '',
      zx2a: '',
      tspec: ''
    };
    
    // ====================================
    // LEER VALORES EXISTENTES EN LA HOJA
    // ====================================
    const videoHoja = String(get('VIDEO') || '').trim();
    const argumentoHoja = String(get('ARGUMENTO') || '');
    const sinopsisHoja = String(get('SINOPSIS') || '');
    const caratulaHoja = String(get('CARÁTULA') || get('CARATULA') || '').trim();
    const screenshotsHoja = String(get('SCREENSHOTS') || '').trim();
    const anioHoja_existente = String(get('AÑO') || '').trim();
    const generoHoja = String(get('GÉNERO') || get('GENERO') || '').trim();
    const subgeneroHoja = String(get('SUBGÉNERO') || get('SUBGENERO') || '').trim();
    const publisherHoja = String(get('PUBLISHER') || '').trim();
    const desarrolladorHoja = String(get('DESARROLLADOR') || get('DESARROLLO') || '').trim();
    const jugadoresHoja = String(get('JUGADORES') || '').trim();
    const controlesHoja = String(get('CONTROLES') || '').trim();
    const versionHoja = String(get('VERSIÓN') || get('VERSION') || '').trim();
    const distribuidorasHoja = String(get('DISTRIBUIDORAS') || '').trim();
    const puntuacionHoja = String(get('PUNTUACIÓN') || get('PUNTUACION') || '').trim();
    
    // ====================================
    // OBTENER DATOS DE IGDB
    // ====================================
    const nombrePlataforma = cfg.nombreVisible || cfg.platformKey;
    const data = fetchIGDB_(cfg.igdbPlatformId, titulo, igdbUrl, anioHoja, nombrePlataforma);
    
    // ====================================
    // RESPETAR VALORES EXISTENTES EN LA HOJA
    // ====================================
    if (videoHoja) {
      data.video = videoHoja;
      Logger.log('[IGDB] Video manual respetado');
    }
    
    if (caratulaHoja) {
      data.caratula = caratulaHoja;
      Logger.log('[IGDB] Carátula manual respetada');
    }
    
    if (screenshotsHoja) {
      data.screenshots = screenshotsHoja.split(',').map(s => s.trim()).filter(Boolean);
      Logger.log('[IGDB] Screenshots manuales respetados');
    }
    
    if (anioHoja_existente) {
      data.anio = anioHoja_existente;
      Logger.log('[IGDB] Año manual respetado');
    }
    
    if (generoHoja) {
      data.generoAnchors = [{text: generoHoja, href: ''}];
      Logger.log('[IGDB] Género manual respetado');
    }
    
    if (subgeneroHoja) {
      data.subgeneroAnchors = [{text: subgeneroHoja, href: ''}];
      Logger.log('[IGDB] Subgénero manual respetado');
    }
    
    if (publisherHoja) {
      data.publisherAnchors = [{text: publisherHoja, href: ''}];
      Logger.log('[IGDB] Publisher manual respetado');
    }
    
    if (desarrolladorHoja) {
      data.desarrolladorAnchors = [{text: desarrolladorHoja, href: ''}];
      Logger.log('[IGDB] Desarrollador manual respetado');
    }
    
    if (jugadoresHoja) {
      data.jugadoresAnchors = [{text: jugadoresHoja, href: ''}];
      Logger.log('[IGDB] Jugadores manual respetado');
    }
    
    if (controlesHoja) {
      data.controlesAnchors = [{text: controlesHoja, href: ''}];
      Logger.log('[IGDB] Controles manual respetado');
    }
    
    if (versionHoja) {
      data.versionAnchors = [{text: versionHoja, href: ''}];
      Logger.log('[IGDB] Versión manual respetada');
    }
    
    if (distribuidorasHoja) {
      data.distribuidorasAnchors = [{text: distribuidorasHoja, href: ''}];
      Logger.log('[IGDB] Distribuidoras manual respetado');
    }
    
    if (puntuacionHoja) {
      data.ratingDisplay = puntuacionHoja;
      Logger.log('[IGDB] Puntuación manual respetada');
    }
    
    // ====================================
    // TRADUCIR SINOPSIS Y ARGUMENTO
    // ====================================
    if (sinopsisHoja.trim()) {
      data.sinopsis = sinopsisHoja;
      Logger.log('[IGDB] Sinopsis manual respetada');
    } else if (data.sinopsis && data.sinopsis.trim()) {
      Logger.log('[IGDB] Traduciendo sinopsis...');
      data.sinopsis = translateTextToSpanish_(data.sinopsis);
    }
    
    if (argumentoHoja.trim()) {
      data.argumento = argumentoHoja;
      Logger.log('[IGDB] Argumento manual respetado');
    } else if (data.argumento && data.argumento.trim()) {
      Logger.log('[IGDB] Traduciendo argumento...');
      data.argumento = translateTextToSpanish_(data.argumento);
    }
    
    // ====================================
    // ESCRIBIR DATOS EN LA HOJA
    // ====================================
    writeBackIGDBRowFromData_(sh, row, headers, data);
    
    // ====================================
    // GENERAR FICHA LATERAL (SIDEBAR)
    // ====================================
const html = buildPreviewHtml_(titulo, nombrePlataforma, igdbUrl, data, columnasManual, data.sinopsis);
Logger.log('[DEBUG] HTML length: ' + (html ? html.length : 'NULL'));
Logger.log('[DEBUG] HTML preview: ' + (html ? html.substring(0, 500) : 'NULL'));
SpreadsheetApp.getUi().showSidebar(HtmlService.createHtmlOutput(html).setTitle('Ficha ' + cfg.platformKey));
    
    return;
  }
  
  // ============================================
  // FLUJO ZX SPECTRUM - Redirigir al menú ZX SP
  // ============================================
  if (cfg.sourceType === 'ZX_SC') {
    ui.alert('ZX Spectrum', 
      'Para ZX Spectrum usa el menú "ZX SP > Vista previa de ficha".\n\nLa columna de URL para ZX es "LINK" (no IGDB_URL).',
      ui.ButtonSet.OK);
    return;
  }
  
  uiAlert_('SOURCE_TYPE "' + cfg.sourceType + '" no implementado.');
}

// ============================================
// ESCRITURA GENÉRICA IGDB
// ============================================

function writeBackIGDBRowFromData_(sh, row, headers, data) {
  if (!data) return;

  function normalizeHeaderKey_(s) {
    let t = String(s || '').toLowerCase().trim();
    t = t.replace(/[áàäâ]/g, 'a').replace(/[éèëê]/g, 'e').replace(/[íìïî]/g, 'i')
         .replace(/[óòöô]/g, 'o').replace(/[úùüû]/g, 'u').replace(/ñ/g, 'n');
    return t.replace(/\s+/g, ' ');
  }

  function colIndex_(name) {
    const target = normalizeHeaderKey_(name || '');
    for (let i = 0; i < headers.length; i++) {
      if (normalizeHeaderKey_(headers[i]) === target) return i + 1;
    }
    return 0;
  }

  function cleanValue_(v) {
    if (v == null) return '';
    let t = String(v).trim();
    if (!t || t === '????' || /^dato no disponible$/i.test(t)) return '';
    return t;
  }

  function writeIfEmpty_(colName, value) {
    const col = colIndex_(colName);
    const v = cleanValue_(value);
    if (!col || !v) return;
    const rng = sh.getRange(row, col);
    if (!String(rng.getValue() || '').trim()) rng.setValue(v);
  }

  function anchorsToText_(arr) {
    return (Array.isArray(arr) ? arr : [])
      .map(a => (a && a.text) ? String(a.text) : '').filter(Boolean).join(', ');
  }

  writeIfEmpty_('AÑO', data.anio);
  writeIfEmpty_('PUNTUACIÓN', data.ratingDisplay);
  writeIfEmpty_('PUNTUACION', data.ratingDisplay);
  writeIfEmpty_('GÉNERO', anchorsToText_(data.generoAnchors));
  writeIfEmpty_('GENERO', anchorsToText_(data.generoAnchors));
  writeIfEmpty_('SUBGÉNERO', anchorsToText_(data.subgeneroAnchors));
  writeIfEmpty_('SUBGENERO', anchorsToText_(data.subgeneroAnchors));
  writeIfEmpty_('PUBLISHER', anchorsToText_(data.publisherAnchors));
  writeIfEmpty_('DESARROLLO', anchorsToText_(data.desarrolladorAnchors));
  writeIfEmpty_('DESARROLLADOR', anchorsToText_(data.desarrolladorAnchors));
  writeIfEmpty_('JUGADORES', anchorsToText_(data.jugadoresAnchors));
  writeIfEmpty_('CARÁTULA', data.caratula);
  writeIfEmpty_('CARATULA', data.caratula);
  writeIfEmpty_('SCREENSHOTS', Array.isArray(data.screenshots) ? data.screenshots.join(', ') : '');
  writeIfEmpty_('SINOPSIS', data.sinopsis);
  writeIfEmpty_('VIDEO', data.video);
  writeIfEmpty_('ARGUMENTO', data.argumento);
}

// ============================================
// IDs GENÉRICOS POR PLATFORM_KEY
// ============================================

function menuRellenarIdFilaActual() {
  const ss = SpreadsheetApp.getActive();
  const shActiva = ss.getActiveSheet();
  const nombreHoja = shActiva ? shActiva.getName().trim() : '';
  
  const cfg = getPlatformConfigByDataSheet_(nombreHoja);
  
  if (cfg && cfg.sourceType === 'IGDB') {
    return rellenarIdIGDBFilaActual_(shActiva, cfg.platformKey);
  }
  
  if (nombreHoja.toUpperCase() === 'ZX_SPECTRUM') {
    return rellenarIdsZXLista();
  }

  if (nombreHoja.toUpperCase() === 'C64' || /commodore.*64/i.test(nombreHoja)) {
    return rellenarIdIGDBFilaActual_(shActiva, 'C64');
  }
  
  if (nombreHoja.toUpperCase().includes('PS3')) {
    return rellenarIdIGDBFilaActual_(shActiva, 'PS3');
  }
  
  uiAlert_('No se puede generar ID para "' + nombreHoja + '".');
}

function rellenarIdIGDBFilaActual_(sh, platformKey) {
  const activeCell = sh.getActiveCell();
  const row = activeCell ? activeCell.getRow() : 0;

  if (!row || row === 1) {
    return uiAlert_('Selecciona una fila con datos (no la cabecera).');
  }

  const headers = sh.getRange(1, 1, 1, Math.max(1, sh.getLastColumn())).getValues()[0];
  const colIdIndex = headers.indexOf('ID');

  if (colIdIndex === -1) {
    return uiAlert_('No se encontró la columna "ID".');
  }

  const colId = colIdIndex + 1;
  const numRows = Math.max(0, sh.getLastRow() - 1);
  let ids = numRows > 0 ? sh.getRange(2, colId, numRows, 1).getValues() : [];

  const prefix = platformKey + '_';
  let ultimoNumero = 0;

  for (let i = 0; i < ids.length; i++) {
    const val = String(ids[i][0] || '').trim();
    if (val.startsWith(prefix)) {
      const match = val.match(/(\d+)$/);
      if (match) {
        const num = parseInt(match[1], 10);
        if (num > ultimoNumero) ultimoNumero = num;
      }
    }
  }

  const currentId = String(sh.getRange(row, colId).getValue() || '').trim();
  if (currentId) {
    return uiAlert_('La fila ya tiene ID: ' + currentId);
  }
  
  const nuevoId = prefix + String(ultimoNumero + 1).padStart(4, '0');
  sh.getRange(row, colId).setValue(nuevoId);
  Logger.log('[ID] Nuevo ID: ' + nuevoId);
}

// ============================================
// NUEVA FUNCIÓN onOpen() - REEMPLAZA LA EXISTENTE
// ============================================

function onOpen() {
  const ui = SpreadsheetApp.getUi();
  
  // Menú 1: ID
  ui.createMenu('ID')
    .addItem('Rellenar ID (fila actual)', 'menuRellenarIdFilaActual')
    .addToUi();
  
  // Menú 2: RETRO (antes era "ZX SP")
  ui.createMenu('RETRO')
    .addItem('Crear ficha RETRO', 'menuPreviewFichaActual')
    .addToUi();
    
  // Menú 3: IGDB
  ui.createMenu('IGDB')
    .addItem('Crear ficha IGDB', 'menuActualizarFilaActual')
    .addToUi();
}


// ============================================
// FIN DEL BLOQUE NUEVO v3.0
// ============================================


// ============================================
// FUNCIÓN PRINCIPAL - PREVIEW DE FICHA
// ============================================

function menuPreviewFichaActual() {
  const ui = SpreadsheetApp.getUi();
  const sh = SpreadsheetApp.getActiveSheet();
  const row = sh.getActiveCell() ? sh.getActiveCell().getRow() : 0;
  
  // Validaciones básicas
  if (!row || row === 1) {
    return uiAlert_('Selecciona una fila con datos (no la cabecera).');
  }

  const headers = sh.getRange(1, 1, 1, Math.max(1, sh.getLastColumn())).getValues()[0];
  
  // Función auxiliar para normalizar texto (quitar acentos, espacios extra)
  const normalizeHeader = (s) => {
    return String(s || '').trim().toUpperCase()
      .normalize('NFD').replace(/[\u0300-\u036f]/g, '') // quitar acentos
      .replace(/\s+/g, '_'); // espacios a guiones bajos
  };
  
  const get = (h) => {
    // Primero buscar coincidencia exacta
    let i = headers.indexOf(h);
    if (i > -1) return sh.getRange(row, i + 1).getValue();
    
    // Si no, buscar coincidencia normalizada
    const hNorm = normalizeHeader(h);
    for (let j = 0; j < headers.length; j++) {
      if (normalizeHeader(headers[j]) === hNorm) {
        return sh.getRange(row, j + 1).getValue();
      }
    }
    return '';
  };

  // ===============================
  // DETECTAR PLATAFORMA
  // ===============================
  const sheetName = sh.getName().trim().toUpperCase();

  // ====================================
  // FLUJO COMMODORE 64 (LEMON64 + LAUNCHBOX)
  // ====================================
  const isC64 = /c64|commodore.*64/i.test(sh.getName());
  
  if (isC64) {
    const titulo = get('TÍTULO') || get('TITULO');
    
    if (!titulo) return uiAlert_('Falta el campo "TÍTULO" en la fila.');

    // ====================================
    // LEER DATOS TÉCNICOS DESDE LA HOJA
    // ====================================
    const tecnicos = {
      formato: String(get('FORMATO') || '').trim(),
      funciona: String(get('FUNCIONA') || '').trim(),
      favorito: String(get('FAVORITO') || '').trim(),
      terminado: String(get('TERMINADO') || '').trim(),
      zx2a: '',
      tspec: '',
      ubicacion: '',
      tipoFormato: '',
      masInfo: ''
    };

    // ====================================
    // LEER OVERRIDES MANUALES DESDE LA HOJA
    // ====================================
    const overrides = {
      caratula: String(get('CARÁTULA') || get('CARATULA') || '').trim(),
      anio: String(get('AÑO') || get('ANO') || '').trim(),
      publisher: String(get('PUBLISHER') || '').trim(),
      desarrollador: String(get('DESARROLLADOR') || '').trim(),
      autores: String(get('AUTORES') || '').trim(),
      video: String(get('VIDEO') || '').trim(),
      genero: String(get('GÉNERO') || get('GENERO') || '').trim(),
      subgenero: String(get('SUBGÉNERO') || get('SUBGENERO') || '').trim(),
      jugadores: String(get('JUGADORES') || '').trim(),
      controles: String(get('CONTROLES') || '').trim(),
      screenshots: String(get('SCREENSHOTS') || '').trim(),
      imagenesExtra: String(get('IMÁGENES') || get('IMAGENES') || '').trim(),
      instrucciones: String(get('INSTRUCCIONES') || '').trim(),
      puntuacion: String(get('PUNTUACIÓN') || get('PUNTUACION') || '').trim(),
      sinopsis: String(get('SINOPSIS') || '').trim(),
      revistas: String(get('REVISTAS') || '').trim()
    };

    // ====================================
    // DETECTAR FUENTE: LEMON64 O LAUNCHBOX
    // ====================================
    let link = get('LINK');
    const fuenteLink = detectarFuenteDeLink_(link);
    let data = null;
    let fuenteDatos = 'MANUAL';
    
    Logger.log('[C64] Título: ' + titulo);
    Logger.log('[C64] Link manual: ' + (link || '[vacío]'));
    Logger.log('[C64] Fuente detectada: ' + fuenteLink);

    // ====================================
    // CASO 1: URL MANUAL DE LAUNCHBOX
    // ====================================
    if (fuenteLink === 'LAUNCHBOX') {
      const gameId = extraerIdDeLaunchBoxUrl_(link);
      
      if (gameId) {
        Logger.log('[C64] Usando LaunchBox con ID directo: ' + gameId);
        data = fetchC64_fromLaunchBox_(titulo, overrides, gameId);
        
        if (data && data.encontrado) {
          fuenteDatos = 'LAUNCHBOX';
        } else {
          Logger.log('[C64] Error al obtener datos de LaunchBox, usando datos manuales');
          data = crearDataC64Vacia_(titulo, overrides);
          fuenteDatos = 'MANUAL';
        }
      } else {
        Logger.log('[C64] No se pudo extraer ID de LaunchBox, usando datos manuales');
        data = crearDataC64Vacia_(titulo, overrides);
        fuenteDatos = 'MANUAL';
      }
    }
    
    // ====================================
    // CASO 2: URL MANUAL DE LEMON64 O VACÍA
    // ====================================
    else {
      // Si no hay link, construir automáticamente
      if (!link || fuenteLink === 'NONE') {
        const slug = makeLemon64Slug_(titulo);
        link = 'https://www.lemon64.com/game/' + slug;
        Logger.log('[C64] Link construido automáticamente: ' + link);
      }
      
      // Verificar disponibilidad de Lemon64
      const lemon64Disponible = verificarLemon64Disponible_(link);
      Logger.log('[C64] Lemon64 disponible: ' + (lemon64Disponible ? 'SÍ' : 'NO'));
      
      // SUBCASO 2A: LEMON64 DISPONIBLE
      if (lemon64Disponible) {
        Logger.log('[C64] Scrapeando de Lemon64: ' + link);
        data = fetchC64_fromLemon64_(titulo, link, overrides);
        fuenteDatos = 'LEMON64';
        
        // MEJORA: Obtener sinopsis de LaunchBox si Lemon64 no la tiene
        if (!overrides.sinopsis && (!data.sinopsis || !data.sinopsis.trim())) {
          Logger.log('[C64] Lemon64 sin sinopsis, intentando LaunchBox como complemento...');
          
          const lbSinopsis = fetchC64_fromLaunchBox_SOLO_SINOPSIS_(titulo);
          
          if (lbSinopsis && lbSinopsis.sinopsis) {
            data.sinopsis = lbSinopsis.sinopsis;
            Logger.log('[C64] ✓ Sinopsis obtenida de LaunchBox (complementaria)');
          } else {
            Logger.log('[C64] LaunchBox tampoco tiene sinopsis');
          }
        }
        
        // MEJORA: Priorizar carátula de LaunchBox si es mejor
        if (!overrides.caratula) {
          Logger.log('[C64] Buscando carátula de LaunchBox para mejor calidad...');
          
          const lbCaratula = fetchC64_fromLaunchBox_(titulo, null, null);
          
          if (lbCaratula && lbCaratula.encontrado && lbCaratula.caratula && 
              lbCaratula.caratula !== FALLBACK_COVER_URL_C64) {
            Logger.log('[C64] ✓ Usando carátula de LaunchBox (mejor calidad)');
            data.caratula = lbCaratula.caratula;
          }
        }
      }
      
      // SUBCASO 2B: LEMON64 NO DISPONIBLE → FALLBACK A LAUNCHBOX
      else {
        Logger.log('[C64] Lemon64 no disponible, buscando en LaunchBox...');
        data = fetchC64_fromLaunchBox_(titulo, overrides, null);
        
        if (data && data.encontrado) {
          fuenteDatos = 'LAUNCHBOX';
          Logger.log('[C64] ✓ Datos obtenidos de LaunchBox');
        } else {
          Logger.log('[C64] Juego no encontrado en ninguna fuente, usando solo datos manuales');
          data = crearDataC64Vacia_(titulo, overrides);
          fuenteDatos = 'MANUAL';
        }
      }
    }

    // ====================================
    // PROCESAR IMÁGENES ADICIONALES
    // ====================================
    if (overrides.imagenesExtra) {
      const extraImages = getExtraImagesForGame(overrides.imagenesExtra, data.caratula, data.screenshots);
      const allExtra = Array.from(new Set((data.imagenesAdicionales || []).concat(extraImages)));
      data.imagenesAdicionales = allExtra;
    }

    // ====================================
    // COMBINAR REVISTAS (AUTO + MANUAL)
    // ====================================
    const revistasUser = parseSheetRevistas_(overrides.revistas);
    if (Array.isArray(data.revistas)) {
      data.revistas = data.revistas.concat(revistasUser);
    } else {
      data.revistas = revistasUser;
    }

    // ====================================
    // FORMATEAR PUNTUACIÓN
    // ====================================
    if (!overrides.puntuacion && data.ratingScore10) {
      data.ratingDisplay = data.ratingScore10 + '/10';
    }

    // ====================================
    // SINOPSIS (prioridad: manual > auto)
    // ====================================
    let sinopsisText = overrides.sinopsis || data.sinopsis || '';

    // ====================================
    // ESCRIBIR DATOS EN LA HOJA (SOLO CELDAS VACÍAS)
    // ====================================
    if (fuenteDatos !== 'MANUAL') {
      writeBackC64RowFromData_(sh, row, headers, data, {
        sinopsis: sinopsisText
      });
    }

    // ====================================
    // GENERAR Y MOSTRAR FICHA HTML
    // ====================================
    const html = buildPreviewHtml_(titulo, 'Commodore 64', link || '', data, tecnicos, sinopsisText);
    SpreadsheetApp.getUi()
      .showSidebar(HtmlService.createHtmlOutput(html).setTitle('Ficha C64'));
    
    Logger.log('[C64] Ficha generada exitosamente (fuente: ' + fuenteDatos + ')');
    return;
  }

  // ===============================
  // FLUJO ORIGINAL ZX SPECTRUM
  // ===============================
  const isZX = /spectrum/i.test(sh.getName());
  const titulo = get('TÍTULO');
  
  if (!titulo) return uiAlert_('Falta el campo "TÍTULO" en la fila.');
  if (!isZX) return uiAlert_('Esta vista previa está pensada para la hoja "ZX Spectrum".');

  const link = get('LINK');
  if (!link) return uiAlert_('Falta el campo "LINK".');

  // ====================================
  // LEER DATOS TÉCNICOS DESDE LA HOJA
  // ====================================
  const tecnicos = {
    formato: String(get('FORMATO') || '').trim(),
    zx2a: String(get('ZX +2A') || '').trim(),
    tspec: String(get('TSPEC') || '').trim(),
    terminado: normalizarTerminado_(get('TERMINADO'))
  };

  // ====================================
  // LEER OVERRIDES MANUALES DESDE LA HOJA
  // ====================================
  const overrides = {
    caratula: String(get('CARÁTULA') || '').trim(),
    anio: String(get('AÑO') || '').trim(),
    publisher: String(get('PUBLISHER') || '').trim(),
    autor: String(get('AUTOR') || '').trim(),
    desarrollador: String(get('DESARROLLADOR') || '').trim(),
    video: String(get('VIDEO') || '').trim(),
    genero: String(get('GÉNERO') || '').trim(),
    subgenero: String(get('SUBGÉNERO') || '').trim(),
    contribuciones: String(get('CONTRIBUCIONES') || '').trim(),
    jugadores: String(get('JUGADORES') || '').trim(),
    controles: String(get('CONTROLES') || '').trim(),
    version: String(get('VERSIÓN') || get('VERSION') || '').trim(),
    distribuidoras: String(get('DISTRIBUIDORAS') || '').trim(),
    screenshots: String(get('SCREENSHOTS') || '').trim(),
    imagenesExtra: String(get('IMÁGENES') || get('IMAGENES') || '').trim(),
    mapa: String(get('MAPA') || '').trim(),
    instrucciones: String(get('INSTRUCCIONES') || '').trim(),
    puntuacion: String(get('PUNTUACIÓN') || get('PUNTUACION') || '').trim(),
    sinopsis: String(get('SINOPSIS') || '').trim(),
    revistas: String(get('REVISTAS') || '').trim()
  };

  // ====================================
  // SCRAPING DE SPECTRUM COMPUTING
  // ====================================
  const data = fetchZX_fromSpectrumComputing_(titulo, link, overrides.caratula);
  
  // Guardamos screenshots auto-detectados ANTES de aplicar overrides
  const autoScreens = Array.isArray(data.screenshots) ? data.screenshots.slice(0, 2) : [];

  // ====================================
  // APLICAR OVERRIDES MANUALES
  // ====================================
  aplicarOverrides_(data, overrides, link);

  // ====================================
  // OBTENER DESARROLLADOR DESDE ZXART
  // ====================================
  if (!overrides.desarrollador) {
    const zx = getDeveloperFromZXART_(titulo);
    if (zx && zx.text) {
      data.desarrolladorAnchors = splitByCommaToAnchors_(zx.text, link);
    }
  }

  // ====================================
  // OBTENER PUNTUACIÓN
  // ====================================
  if (overrides.puntuacion) {
    data.ratingDisplay = overrides.puntuacion;
  } else {
    data.ratingDisplay = formatRatingDisplay_(data.ratingScore10, data.ratingVotes);
  }

  // ====================================
  // OBTENER SINOPSIS (PRIORIDAD: HOJA > ZXART)
  // ====================================
  let sinopsisText = overrides.sinopsis || obtenerSinopsisZXArt_(titulo);

  // ====================================
  // PROCESAR IMÁGENES ADICIONALES
  // ====================================
  const imagenesInput = overrides.imagenesExtra || (data.imagenesAdicionales || []).join('\n');
  data.imagenesAdicionales = getExtraImagesForGame(imagenesInput, data.caratula, data.screenshots);

  // ====================================
  // COMBINAR REVISTAS (AUTO + MANUAL)
  // ====================================
  const revistasUser = parseSheetRevistas_(overrides.revistas);
  if (Array.isArray(data.revistas)) {
    data.revistas = data.revistas.concat(revistasUser);
  } else {
    data.revistas = revistasUser;
  }

  // ====================================
  // ESCRIBIR DATOS EN LA HOJA (SOLO CELDAS VACÍAS)
  // ====================================
  writeBackZXRowFromData_(sh, row, headers, data, {
    autoScreenshots: autoScreens,
    sinopsis: sinopsisText
  });

  // ====================================
  // GENERAR Y MOSTRAR FICHA HTML
  // ====================================
  const html = buildPreviewHtml_(titulo, 'ZX Spectrum', link, data, tecnicos, sinopsisText);
  SpreadsheetApp.getUi()
    .showSidebar(HtmlService.createHtmlOutput(html).setTitle('Ficha'));
}


  // Cierre de la función principal de menú


// ============================================
// HELPER: APLICAR OVERRIDES MANUALES
// ============================================

function aplicarOverrides_(data, overrides, link) {
  // Año
  if (overrides.anio) data.anio = overrides.anio;
  
  // Vídeo
  if (overrides.video) data.video = overrides.video;

  // Publisher (con normalización)
  if (overrides.publisher) {
    data.publisherAnchors = splitByCommaToAnchors_(overrides.publisher, link, 'Publisher')
      .map(a => ({ ...a, text: normalizePublisherName_(a.text) }));
  } else if (Array.isArray(data.publisherAnchors)) {
    data.publisherAnchors = data.publisherAnchors.map(a => ({ ...a, text: normalizePublisherName_(a.text) }));
  }

  // Autor
  if (overrides.autor) {
    data.autorAnchors = splitByCommaToAnchors_(overrides.autor, link);
  }

  // Desarrollador
  if (overrides.desarrollador) {
    data.desarrolladorAnchors = splitByCommaToAnchors_(overrides.desarrollador, link);
  }

  // Contribuciones
  if (overrides.contribuciones) {
    data.contributorsAnchors = splitByCommaToAnchors_(overrides.contribuciones, link);
  }

  // Género
  if (overrides.genero) {
    data.generoAnchors = splitByCommaToAnchors_(overrides.genero.replace(/;/g, ','), link);
  }

  // Subgénero
  if (overrides.subgenero) {
    data.subgeneroAnchors = splitByCommaToAnchors_(overrides.subgenero.replace(/;/g, ','), link);
  }

  // Jugadores
  if (overrides.jugadores) {
    data.jugadoresAnchors = splitByCommaToAnchors_(overrides.jugadores.replace(/;/g, ','), link, 'Maximum Players');
  }

  // Controles
  if (overrides.controles) {
    data.controlesAnchors = splitByCommaToAnchors_(overrides.controles.replace(/;/g, ','), link, 'Controls');
  }

  // Versión
  if (overrides.version) {
    data.versionAnchors = splitByCommaToAnchors_(overrides.version.replace(/;/g, ','), link, 'Machine Type');
  }

  // Distribuidoras
  if (overrides.distribuidoras) {
    data.distribuidorasAnchors = splitByCommaToAnchors_(overrides.distribuidoras.replace(/;/g, ','), link, 'Publisher');
  }

  // Mapa
  if (overrides.mapa) {
    data.mapa = overrides.mapa;
  }

  // Instrucciones
  if (overrides.instrucciones) {
    data.instrucciones = overrides.instrucciones;
  }

  // Screenshots (si el usuario pone algo manual, reemplaza los auto-detectados)
  if (overrides.screenshots) {
    const parts = overrides.screenshots.split(/\s*,\s*/).map(x => x.trim()).filter(Boolean);
    data.screenshots = parts.slice(0, 2);
  }
}

// ============================================
// HELPER: NORMALIZAR CAMPO "TERMINADO"
// ============================================

function normalizarTerminado_(valor) {
  const v = String(valor || '').trim();
  if (!v) return '';
  if (/^si$/i.test(v)) return 'SI';
  if (/^no$/i.test(v)) return 'NO';
  return v;
}

// ============================================
// HELPER: OBTENER SINOPSIS DESDE ZXART
// ============================================

function obtenerSinopsisZXArt_(titulo) {
  try {
    const zxSyn = getZXArtSynopsisTranslated_(titulo);
    if (zxSyn) {
      if (zxSyn.es && String(zxSyn.es).trim()) {
        return String(zxSyn.es).trim();
      } else if (zxSyn.en && String(zxSyn.en).trim()) {
        return String(zxSyn.en).trim();
      }
    }
  } catch (e) {
    Logger.log('[ERROR] obtenerSinopsisZXArt_: ' + e);
  }
  return 'Sinopsis no disponible en ZXArt.';
}

/**
 * ============================================
 * PARTE 2: SCRAPING SPECTRUM COMPUTING
 * ============================================
 * 
 * Extrae todos los datos desde SpectrumComputing.co.uk:
 * - Datos básicos (año, género, publisher, autor)
 * - Carátula (Inlay - Front)
 * - Screenshots (Loading + Running)
 * - Puntuación (User Score)
 * - Imágenes adicionales
 * - Instrucciones, mapa, vídeo
 * - Revistas (Magazine Reviews)
 * 
 * ============================================
 */

function fetchZX_fromSpectrumComputing_(titulo, link, coverManual) {
  try {
    const res = UrlFetchApp.fetch(link, { muteHttpExceptions: true });
    const html = res.getContentText();
    const data = {};

    // ====================================
    // HELPERS PARA EXTRAER DATOS DEL HTML
    // ====================================
    
    // Extrae texto plano de un campo
    const rowVal = (labels) => {
      const alts = (Array.isArray(labels) ? labels : [labels]).map(escapeRegex_).join('|');
      const patterns = [
        `<div\\s+class="col-sm-4">\\s*<b>\\s*(?:${alts})\\s*:?\\s*</b>\\s*</div>\\s*<div\\s+class="col-sm-8">([\\s\\S]*?)</div>`,
        `<dt[^>]*>\\s*(?:${alts})\\s*:?\\s*<\\/dt>\\s*<dd[^>]*>([\\s\\S]*?)<\\/dd>`,
        `<t[hd][^>]*>\\s*(?:${alts})\\s*:?\\s*<\\/t[hd]>\\s*<t[hd][^>]*>([\\s\\S]*?)<\\/t[hd]>`
      ];
      
      for (const pattern of patterns) {
        const m = new RegExp(pattern, 'i').exec(html);
        if (m) return stripTags_(m[1]).replace(/\s+/g, ' ').trim();
      }
      return '';
    };

    // Extrae HTML interno de un campo (con enlaces)
    const rowValHtml = (labels) => {
      const alts = (Array.isArray(labels) ? labels : [labels]).map(escapeRegex_).join('|');
      const patterns = [
        `<div\\s+class="col-sm-4">\\s*<b>\\s*(?:${alts})\\s*:?\\s*</b>\\s*</div>\\s*<div\\s+class="col-sm-8">([\\s\\S]*?)</div>`,
        `<dt[^>]*>\\s*(?:${alts})\\s*:?\\s*<\\/dt>\\s*<dd[^>]*>([\\s\\S]*?)<\\/dd>`,
        `<t[hd][^>]*>\\s*(?:${alts})\\s*:?\\s*<\\/t[hd]>\\s*<t[hd][^>]*>([\\s\\S]*?)<\\/t[hd]>`
      ];
      
      for (const pattern of patterns) {
        const m = new RegExp(pattern, 'i').exec(html);
        if (m) return m[1];
      }
      return '';
    };

    // ====================================
    // EXTRAER DATOS BÁSICOS
    // ====================================
    
    data.anio = rowVal(['Release Date', 'Release']);
    data.generoAnchors = parseAnchors_(rowValHtml('Genre'), link);
    
    // Themes / Subgénero
    let themesHtml = rowValHtml(['Themes?', 'Theme', 'Themes']);
    if (!themesHtml) themesHtml = findLabelBlock_(html, 'Themes?');
    data.subgeneroAnchors = parseAnchors_(themesHtml, link);

    // ====================================
    // PUBLISHER (CON NORMALIZACIÓN)
    // ====================================
    
    const pubHtml = rowValHtml(['Original Publisher', 'Original\\s*Publisher']);
    data.publisherAnchors = parseAnchors_(pubHtml, link);
    
    if (!data.publisherAnchors.length) {
      const pubText = rowVal(['Original Publisher', 'Original\\s*Publisher']);
      data.publisherAnchors = splitByCommaToAnchors_(pubText, link);
    }
    
    // Normalizar nombres de publishers
    data.publisherAnchors = data.publisherAnchors.map(a => ({
      ...a,
      text: normalizePublisherName_(a.text)
    }));

    // ====================================
    // AUTORES Y CONTRIBUCIONES
    // ====================================
    
    // Autores (Creators)
    data.autorAnchors = parseAnchors_(rowValHtml(['Creator', 'Creators']), link);
    if (!data.autorAnchors.length) {
      data.autorAnchors = splitByCommaToAnchors_(rowVal(['Creator', 'Creators']), link);
    }

    // Contribuciones (Contributors)
    data.contributorsAnchors = parseAnchors_(rowValHtml(['Contributor', 'Contributors']), link);
    if (!data.contributorsAnchors.length) {
      data.contributorsAnchors = splitByCommaToAnchors_(rowVal(['Contributor', 'Contributors']), link);
    }

    // ====================================
    // JUGADORES, CONTROLES, VERSIÓN
    // ====================================
    
    const jugadoresTxt = rowVal(['Maximum Players', 'Players', 'Max. Players', 'Number of Players']);
    data.jugadoresAnchors = splitByCommaToAnchors_(jugadoresTxt, link, 'Maximum Players');

    data.controlesAnchors = parseAnchors_(rowValHtml(['Controls?', 'Controls']), link);
    if (!data.controlesAnchors.length) {
      data.controlesAnchors = splitByCommaToAnchors_(rowVal(['Controls?', 'Controls']), link, 'Controls');
    }

    data.versionAnchors = splitByCommaToAnchors_(rowVal('Machine Type'), link, 'Machine Type');

    // ====================================
    // DISTRIBUIDORAS (RE-RELEASES)
    // ====================================
    
    data.releases = [];
    const reRe = /<div class="hidden-xs col-md-2">Re-release[^<]*<\/div>\s*<div class="col-sm-4 col-md-3">[\s\S]*?>([^<]+)<\/a>/ig;
    let rm;
    while ((rm = reRe.exec(html))) {
      data.releases.push(stripTags_(rm[1]).trim());
    }
    data.distribuidorasAnchors = splitByCommaToAnchors_(data.releases.join(', '), link, 'Publisher');

    // ====================================
    // PUNTUACIÓN (USER SCORE)
    // ====================================
    
    const scoreTxt = rowVal(['Score']);
    const votesTxt = rowVal(['Total votes', 'Votes']);
    
    if (scoreTxt) {
      const m = scoreTxt.replace(',', '.').match(/-?\d+(?:\.\d+)?/);
      if (m) data.ratingScore10 = parseFloat(m[0]);
    }
    
    if (votesTxt) {
      const m2 = votesTxt.match(/\d+/);
      if (m2) data.ratingVotes = parseInt(m2[0], 10);
    }

    // ====================================
    // CARÁTULA (INLAY - FRONT)
    // ====================================
    
    let autoCover = '';

    // Estrategia 1: <a href="URL.jpg">...<small>Inlay - Front</small>
    const pattern1 = /<a[^>]+href=["']([^"']+\.(?:jpg|jpeg|png|webp))["'][^>]*>[\s\S]*?<small>Inlay\s*-\s*Front<\/small>/i;
    const match1 = pattern1.exec(html);
    
    if (match1 && match1[1]) {
      autoCover = absolutize_(link, match1[1]);
    }

    // Estrategia 2: Loop por todos los <a> que contengan "Inlay - Front"
    if (!autoCover) {
      const linkRegex = /<a[^>]+href=["']([^"']+)["'][^>]*>([\s\S]*?)<\/a>/gi;
      let linkMatch;
      
      while ((linkMatch = linkRegex.exec(html)) !== null) {
        const href = linkMatch[1];
        const content = linkMatch[2];
        
        if (/Inlay\s*-\s*Front/i.test(content) && /\.(?:jpg|jpeg|png|webp|gif)$/i.test(href)) {
          autoCover = absolutize_(link, href);
          break;
        }
      }
    }

    // Prioridad: Manual > Auto > Fallback
    const manualTrim = String(coverManual || '').trim();
    if (manualTrim) {
      data.caratula = manualTrim;
    } else if (autoCover) {
      data.caratula = autoCover;
    } else {
      data.caratula = FALLBACK_COVER_URL;
    }

// ====================================
// IMÁGENES ADICIONALES
// ====================================

const addImgs = new Map();

const pushAdditional = (u) => {
  if (!u) return;
  const abs = absolutize_(link, u);
  const imgSrc = scrToImg_(abs);
  const key = normalizeKey_(imgSrc);
  const isTop = (data.screenshots || []).some(s => normalizeKey_(s) === key);
  if (!isTop && !addImgs.has(key)) addImgs.set(key, imgSrc);
};

// Buscar en panel de Screenshots
const shotsPanel = getPanel_(html, 'Screenshots');
if (shotsPanel) {
  [...shotsPanel.matchAll(/<a[^>]+href=["']([^"']+)["'][^>]*>/ig)].forEach(m => pushAdditional(m[1]));
  [...shotsPanel.matchAll(/<img[^>]+src=["']([^"']+)["']/ig)].forEach(m => pushAdditional(m[1]));
}

// Buscar todas las imágenes .scr, .png, .jpg en el HTML
[...html.matchAll(/<a[^>]+href=["']([^"']+\.(?:scr|png|jpe?g|webp|gif))["'][^>]*>/ig)]
  .forEach(m => pushAdditional(m[1]));

data.imagenesAdicionales = Array.from(addImgs.values());

    // ====================================
    // INSTRUCCIONES (PDF O TXT)
    // ====================================
    
    const instPdf = /<a[^>]+href=["']([^"']+\.(?:pdf))["'][^>]*>[\s\S]*?<small>\s*Instructions\s*<\/small>/i.exec(html);
    const instTxt = /<a[^>]+href=["']([^"']+\.(?:txt))["'][^>]*>[\s\S]*?<small>\s*Instructions\s*<\/small>/i.exec(html);
    
    if (instPdf && instPdf[1]) {
      data.instrucciones = absolutize_(link, instPdf[1]);
    } else if (instTxt && instTxt[1]) {
      data.instrucciones = absolutize_(link, instTxt[1]);
    } else {
      data.instrucciones = '';
    }

    // ====================================
    // MAPA
    // ====================================
    
    const mapsPanel = getPanel_(html, 'Speccy\\s*Screenshot\\s*Maps');
    if (mapsPanel) {
      const m = /<a[^>]+href=["']([^"']+)["'][^>]*>/i.exec(mapsPanel);
      if (m && m[1]) {
        data.mapa = absolutize_(link, m[1]);
      } else {
        data.mapa = '';
      }
    } else {
      data.mapa = '';
    }

    // ====================================
    // VÍDEO (YOUTUBE)
    // ====================================
    
    const y1 = /<iframe[^>]+src=["']([^"']*youtube[^"']+)["']/i.exec(html);
    data.video = (y1 && y1[1]) ? y1[1] : '';

    // ====================================
    // REVISTAS (MAGAZINE REVIEWS)
    // ====================================
    
    data.revistas = extractSCMagazineReviewsFromHtml_(html);

    return data;
    
  } catch (e) {
    Logger.log('[ERROR] fetchZX_fromSpectrumComputing_: ' + e);
    return {};
  }
}

/**
 * ============================================
 * SCRAPING LEMON64 PARA COMMODORE 64
 * ============================================
 * 
 * Extrae datos desde Lemon64.com:
 * - Datos básicos (año, publisher, desarrollador, autores)
 * - Carátula (Front Cover desde sección SCANS)
 * - Screenshots (2 primeras)
 * - Imágenes adicionales (desde la 3ª)
 * - Puntuación (Score con imágenes)
 * - Género, tags, jugadores, controles
 * - Vídeo YouTube
 * - Revistas
 * - Instrucciones
 * 
 * ============================================
 */

function fetchC64_fromLemon64_(titulo, link, overrides) {
  /**
   * Scrapea datos desde Lemon64.com para Commodore 64
   * 
   * PRIORIDADES DE DATOS:
   * - CARÁTULA: Manual > LaunchBox > Lemon64 > Fallback
   * - SINOPSIS: Manual > LaunchBox traducido > Vacío (Lemon64 no tiene)
   * - PUNTUACIÓN: Manual > Lemon64 (LaunchBox no tiene)
   * - REVISTAS: Manual > Lemon64 (LaunchBox no tiene)
   * - JUGADORES: Manual > Lemon64 > LaunchBox convertido
   * - RESTO CAMPOS: Manual > Lemon64 > LaunchBox
   * 
   * NOTA: Esta función se complementa con LaunchBox cuando Lemon64 no tiene datos.
   * El flujo de cascada se maneja en menuPreviewFichaActual().
   */
  try {
    const res = UrlFetchApp.fetch(link, { muteHttpExceptions: true });
    const html = res.getContentText();
    const data = {};

    // ====================================
    // HELPERS PARA EXTRAER DATOS
    // ====================================
    
    // Buscar fila por etiqueta (ej: "Developer:", "Year:")
    const findRow = (label) => {
      const escaped = label.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
      const pattern = `<td[^>]*class="[^"]*align-top[^"]*text-nowrap[^"]*"[^>]*>\\s*${escaped}\\s*:?\\s*</td>\\s*<td[^>]*class="[^"]*credits-data[^"]*"[^>]*>([\\s\\S]*?)</td>`;
      const m = new RegExp(pattern, 'i').exec(html);
      return m ? m[1] : '';
    };

    // ====================================
    // ID LEMON64
    // ====================================
    const idMatch = html.match(/Game ID:\s*(\d+)/i);
    data.idLemon64 = idMatch ? idMatch[1] : '';

    // ====================================
    // AÑO
    // ====================================
    const yearHtml = findRow('Released');
    let yearMatch = yearHtml.match(/list_year=(\d{4})/);
    if (!yearMatch) {
      yearMatch = yearHtml.match(/\b(19\d{2}|20\d{2})\b/);
    }
    data.anio = yearMatch ? yearMatch[1] : '';
    Logger.log('[C64 AÑO] Extraído: ' + data.anio);

// ====================================
// PUBLISHER
// ====================================
let publisherHtml = findRow('Publisher');
// Limpiar botones "Info / logo" que no son datos reales
publisherHtml = publisherHtml.replace(/<span[^>]*class="[^"]*button-clean[^"]*"[^>]*>[\s\S]*?<\/span>/gi, '');
const pubAnchors = parseAnchors_(publisherHtml, link);
data.publisherAnchors = pubAnchors.length ? pubAnchors : [];

// ====================================
// DESARROLLADOR
// ====================================
let devHtml = findRow('Developer');
devHtml = devHtml.replace(/<span[^>]*class="[^"]*button-clean[^"]*"[^>]*>[\s\S]*?<\/span>/gi, '');
const devAnchors = parseAnchors_(devHtml, link);

data.desarrolladorAnchors = devAnchors.length 
  ? devAnchors 
  : (pubAnchors.length ? pubAnchors : []);

    // ====================================
    // AUTORES (con roles: Coder, Musician, etc.)
    // ====================================
    const autoresRegex = /<td[^>]*class="[^"]*align-top[^"]*text-nowrap[^"]*"[^>]*>\s*([^<:]+)\s*:\s*<\/td>\s*<td[^>]*class="[^"]*credits-data[^"]*"[^>]*>\s*<a[^>]+href=["'][^"']*list_individual[^"']*["'][^>]*>([^<]+)<\/a>/gi;
    const autores = [];
    let autorMatch;
    
    while ((autorMatch = autoresRegex.exec(html)) !== null) {
      const rol = stripTags_(autorMatch[1]).trim();
      const nombre = stripTags_(autorMatch[2]).trim();
      
      const rolesExcluidos = /publisher|copyright|released|distributor/i;
      if (!rolesExcluidos.test(rol) && nombre) {
        autores.push(`${nombre} (${rol})`);
      }
    }
    
    data.autores = autores.join(', ');
    data.autorAnchors = autores.map(a => ({ text: a, href: '#' }));

    // ====================================
    // GÉNERO
    // ====================================
    const genreRegex = /<a[^>]+href=["'][^"']*list_genre=([^"'&]+)[^"']*["'][^>]*>([^<]+)<\/a>/gi;
    const genres = [];
    let genreMatch;
    
    while ((genreMatch = genreRegex.exec(html)) !== null) {
      const genreName = stripTags_(genreMatch[2]).trim();
      if (genreName) genres.push({ text: genreName, href: '#' });
    }
    
    data.generoAnchors = genres;

    // ====================================
    // SUBGÉNERO (Tags)
    // ====================================
    const tagRegex = /<a[^>]+href=["'][^"']*list_tag=([^"']+)["'][^>]*class=["'][^"']*game_tag[^"']*["'][^>]*>([^<]+)<\/a>/gi;
    const tags = [];
    let tagMatch;
    
    while ((tagMatch = tagRegex.exec(html)) !== null) {
      const tagName = stripTags_(tagMatch[2]).trim();
      if (tagName) tags.push({ text: tagName, href: '#' });
    }
    
    data.subgeneroAnchors = tags;

    // ====================================
    // JUGADORES
    // ====================================
    const playersHtml = findRow('Players');
    const playersText = stripTags_(playersHtml).trim();
    const jugadores = [];
    
    if (playersText) {
      if (/\b1\b/.test(playersText) && !/1[0-9]/.test(playersText)) {
        jugadores.push('Single Player');
      }
      if (/[2-9]/.test(playersText) || /simultaneous/i.test(playersText)) {
        jugadores.push('Multiple Players');
      }
    }
    
    data.jugadoresAnchors = jugadores.map(j => ({ text: j, href: '#' }));

    // ====================================
    // CONTROLES
    // ====================================
    const controlHtml = findRow('Main Control');
    const controlText = stripTags_(controlHtml).trim();
    data.controlesAnchors = controlText ? [{ text: controlText, href: '#' }] : [];

    // ====================================
// CARÁTULA (Front Cover desde SCANS)
// ====================================
let autoCover = '';

// Estrategia 1: Buscar enlace a covers/large que contenga "Front Cover" en data-glightbox
const frontCoverGlightbox = html.match(/<a[^>]+href=["']([^"']*\/assets\/images\/games\/covers\/large\/[^"']+\.jpg)["'][^>]+data-glightbox=["'][^"']*Front Cover[^"']*["']/i);

if (frontCoverGlightbox && frontCoverGlightbox[1]) {
  autoCover = frontCoverGlightbox[1].startsWith('http') 
    ? frontCoverGlightbox[1] 
    : 'https://www.lemon64.com' + frontCoverGlightbox[1];
  Logger.log('[C64 COVER] Encontrada via data-glightbox: ' + autoCover);
}

// Estrategia 2 (fallback): Buscar cualquier enlace a /covers/large/
if (!autoCover) {
  const coverLargeAny = html.match(/href=["']([^"']*\/assets\/images\/games\/covers\/large\/[^"']+\.jpg)["']/i);
  if (coverLargeAny && coverLargeAny[1]) {
    autoCover = coverLargeAny[1].startsWith('http') 
      ? coverLargeAny[1] 
      : 'https://www.lemon64.com' + coverLargeAny[1];
    Logger.log('[C64 COVER] Encontrada via covers/large: ' + autoCover);
  }
}

// Estrategia 3 (fallback): Buscar imagen con alt "Front Cover"
if (!autoCover) {
  const frontCoverImg = html.match(/<img[^>]+src=["']([^"']*\/assets\/images\/games\/covers\/[^"']+\.jpg)["'][^>]*alt=["'][^"']*Front Cover[^"']*["']/i);
  if (frontCoverImg && frontCoverImg[1]) {
    autoCover = frontCoverImg[1].startsWith('http') 
      ? frontCoverImg[1] 
      : 'https://www.lemon64.com' + frontCoverImg[1];
    Logger.log('[C64 COVER] Encontrada via img alt: ' + autoCover);
  }
}

// Aplicar override manual si existe
const manualCover = (overrides && overrides.caratula) ? String(overrides.caratula).trim() : '';
data.caratula = manualCover || autoCover || FALLBACK_COVER_URL_C64;
Logger.log('[C64 COVER] Final: ' + data.caratula);
    // ====================================
    // SCREENSHOTS
    // ====================================
    const allScreenshots = [];
    const imgRegex = /<img[^>]+src=["']([^"']*\/assets\/images\/games\/screens\/[^"']+)["']/gi;
    let imgMatch;
    
    while ((imgMatch = imgRegex.exec(html)) !== null) {
      let url = imgMatch[1];
      if (!url.startsWith('http')) {
        url = 'https://www.lemon64.com' + url;
      }
      allScreenshots.push(url);
    }
    
    const uniqueScreenshots = [...new Set(allScreenshots)];
    data.screenshots = uniqueScreenshots.slice(0, 2);
    data.imagenesAdicionales = uniqueScreenshots.slice(2);

    // ====================================
    // VIDEO (YouTube)
    // ====================================
    const videoMatch = html.match(/<a[^>]+href=["'](https?:\/\/(?:www\.)?youtube\.com\/watch\?v=[^"']+)["']/i);
    data.video = videoMatch ? videoMatch[1] : '';

    // ====================================
    // REVISTAS
    // ====================================
    data.revistas = extractLemon64MagazineReviews_(html);

    // ====================================
    // INSTRUCCIONES (primer documento)
    // ====================================
    const docMatch = html.match(/<a[^>]+href=["']([^"']*\/doc\/[^"']+)["']/i);
    if (docMatch && docMatch[1]) {
      data.instrucciones = docMatch[1].startsWith('http') 
        ? docMatch[1] 
        : 'https://www.lemon64.com' + docMatch[1];
    } else {
      data.instrucciones = '';
    }

// ====================================
// PUNTUACIÓN (extraer de imágenes PNG)
// ====================================
const scoreImgsRegex = /<div[^>]*class=["'][^"']*votes-score[^"']*["'][^>]*>([\s\S]*?)<\/div>/i;
const scoreBlock = scoreImgsRegex.exec(html);

if (scoreBlock && scoreBlock[1]) {
  const scoreHtml = scoreBlock[1];
  const scoreImgRegex = /<img[^>]+src=["'][^"']*\/score\/([^"']+)\.png["']/gi;
  const digits = [];
  let scoreImgMatch;
  
  while ((scoreImgMatch = scoreImgRegex.exec(scoreHtml)) !== null) {
    const filename = scoreImgMatch[1];
    if (filename.includes('score')) continue;
    if (filename === 'dot') {
      digits.push('.');
    } else {
      digits.push(filename);
    }
  }
  
  const scoreValue = digits.join('');
  const numScore = parseFloat(scoreValue);
  
  if (!isNaN(numScore)) {
    data.ratingScore10 = numScore;
    // Forzar decimal para evitar que Sheets lo interprete como fecha
    data.ratingDisplay = numScore.toFixed(1) + '/10';
  } else {
    data.ratingDisplay = scoreValue || '';
  }
} else {
  data.ratingDisplay = '';
}

    // ====================================
    // APLICAR OVERRIDES MANUALES
    // ====================================
    if (overrides) {
      if (overrides.anio) data.anio = overrides.anio;
      if (overrides.video) data.video = overrides.video;
      if (overrides.genero) {
        data.generoAnchors = splitByCommaToAnchors_(overrides.genero, link);
      }
      if (overrides.subgenero) {
        data.subgeneroAnchors = splitByCommaToAnchors_(overrides.subgenero, link);
      }
      if (overrides.publisher) {
        data.publisherAnchors = splitByCommaToAnchors_(overrides.publisher, link);
      }
      if (overrides.desarrollador) {
        data.desarrolladorAnchors = splitByCommaToAnchors_(overrides.desarrollador, link);
      }
      if (overrides.autores) {
        data.autores = overrides.autores;
        data.autorAnchors = splitByCommaToAnchors_(overrides.autores, link);
      }
      if (overrides.jugadores) {
        data.jugadoresAnchors = splitByCommaToAnchors_(overrides.jugadores, link);
      }
      if (overrides.controles) {
        data.controlesAnchors = splitByCommaToAnchors_(overrides.controles, link);
      }
      if (overrides.screenshots) {
        const parts = overrides.screenshots.split(/\s*,\s*/).map(x => x.trim()).filter(Boolean);
        data.screenshots = parts.slice(0, 2);
        data.imagenesAdicionales = parts.slice(2);
      }
      if (overrides.imagenesExtra) {
        const extraUrls = overrides.imagenesExtra.split(/[\n,;]+/).map(s => s.trim()).filter(Boolean);
        data.imagenesAdicionales = [...new Set([...data.imagenesAdicionales, ...extraUrls])];
      }
      if (overrides.instrucciones) {
        data.instrucciones = overrides.instrucciones;
      }
      if (overrides.puntuacion) {
        data.ratingDisplay = overrides.puntuacion;
      }
    }

    // ====================================
    // CAMPOS VACÍOS/NO APLICABLES
    // ====================================
    data.contributorsAnchors = [];
    data.versionAnchors = [];
    data.distribuidorasAnchors = [];
    data.mapa = '';
    data.sinopsis = '';

    return data;

  } catch (e) {
    Logger.log('[ERROR] fetchC64_fromLemon64_: ' + e);
    return {};
  }
}

// ====================================
// HELPER: EXTRAER REVISTAS DE LEMON64
// ====================================
function extractLemon64MagazineReviews_(html) {
  const revistas = [];
  
  // Buscar desde "Magazine Reviews" hasta "YouTube Links" (siguiente sección)
  const magazineSectionRegex = /Magazine Reviews[\s\S]*?<table[^>]*class=["'][^"']*table-common[^"']*table-stripes[^"']*["'][^>]*>([\s\S]*?)<\/table>[\s\S]*?YouTube Links/i;
  
  const sectionMatch = html.match(magazineSectionRegex);
  
  if (!sectionMatch) {
    Logger.log('[C64 REVISTAS] No se encontró sección Magazine Reviews');
    return revistas;
  }
  
  const magazineHtml = sectionMatch[1];
  Logger.log('[C64 REVISTAS] Sección encontrada, longitud: ' + magazineHtml.length);
  
  // Buscar directamente enlaces con <strong>NOMBRE</strong>
  const linkRegex = /<a[^>]+href=["']([^"']+)["'][^>]*>[\s\S]*?<strong>([^<]+)<\/strong>([^<]*)<\/a>/gi;
  let linkMatch;
  let contador = 0;
  
  while ((linkMatch = linkRegex.exec(magazineHtml)) !== null) {
    contador++;
    const url = linkMatch[1];
    const nombreRevista = stripTags_(linkMatch[2]).trim();
    const detalles = stripTags_(linkMatch[3]).trim();
    
    Logger.log('[C64 REVISTAS] Candidato #' + contador + ': "' + nombreRevista + '"');
    
    // Ignorar basura y promedio
    if (!nombreRevista || nombreRevista.length < 2) {
      Logger.log('  → Descartado: nombre muy corto');
      continue;
    }
    if (/^(Info|photo|Longplay|video|screenshot)$/i.test(nombreRevista)) {
      Logger.log('  → Descartado: basura conocida');
      continue;
    }
    if (/average.*rating/i.test(nombreRevista)) {
      Logger.log('  → Descartado: es el promedio');
      continue;
    }
    
    revistas.push({
      mag: nombreRevista,
      title: detalles ? `${nombreRevista} ${detalles}` : nombreRevista,
      href: url.startsWith('http') ? url : 'https://www.lemon64.com' + url
    });
    
    Logger.log('  → ✓ AÑADIDA');
  }
  
  Logger.log('[C64 REVISTAS] Total revistas extraídas: ' + revistas.length);
  return revistas;
}

// ====================================
// HELPER: EXTRAER LOADING + RUNNING SCREENS
// ====================================

function extractTopScreens_(html, link) {
  const found = new Map();
  const re = /<a[^>]+href=["']([^"']+)["'][^>]*>\s*<div[^>]*>\s*<div[^>]*title=["'](Loading screen|Running screen)["'][^>]*><\/div>[\s\S]*?<\/div>\s*<\/a>/ig;
  let m;
  
  while ((m = re.exec(html))) {
    const href = absolutize_(link, m[1]);
    const key = /loading/i.test(m[2]) ? 'loading' : 'running';
    const existing = found.get(key);
    
    if (!existing) {
      found.set(key, href);
    } else if (isScr_(href) && !isScr_(existing)) {
      // Priorizar archivos .scr sobre otros formatos
      found.set(key, href);
    }
  }
  
  const list = [];
  ['loading', 'running'].forEach(k => {
    const u = found.get(k);
    if (u) list.push(scrToImg_(u));
  });
  
  return list;
}

// ====================================
// HELPER: PROCESAR IMÁGENES ADICIONALES
// ====================================

function getExtraImagesForGame(rawCellValue, caratulaUrl, screenshotUrls) {
  if (!rawCellValue) return [];
  
  // Separar URLs por saltos de línea, comas o punto y coma
  let urls = rawCellValue
    .split(/[\n,;]+/g)
    .map(s => s.trim())
    .filter(s => s.length > 0);

  // Filtrar solo URLs válidas de imágenes
  urls = urls.filter(url => 
    /^https?:\/\//i.test(url) && 
    /\.(jpg|jpeg|png|gif|webp|scr)$/i.test(url)
  );

  // Eliminar duplicados
  const seen = new Set();
  urls = urls.filter(url => {
    const key = url.toLowerCase().replace(/(\?|\#).*/, '');
    if (seen.has(key)) return false;
    seen.add(key);
    return true;
  });

  // Excluir la carátula
  if (caratulaUrl) {
    const cKey = caratulaUrl.toLowerCase().replace(/(\?|\#).*/, '');
    urls = urls.filter(url => url.toLowerCase().replace(/(\?|\#).*/, '') !== cKey);
  }

  // Excluir screenshots principales
  if (Array.isArray(screenshotUrls)) {
    const sKeys = screenshotUrls.map(s => s.toLowerCase().replace(/(\?|\#).*/, ''));
    urls = urls.filter(url => !sKeys.includes(url.toLowerCase().replace(/(\?|\#).*/, '')));
  }

  // Limitar a 40 imágenes máximo
  if (urls.length > 40) urls = urls.slice(0, 40);
  
  return urls;
}

/**
 * ============================================
 * PARTE 3: SCRAPING DE REVISTAS
 * ============================================
 * 
 * Extrae información de revistas desde dos fuentes:
 * 1. SpectrumComputing (Magazine Reviews) - Automático
 * 2. Columna REVISTAS de la hoja - Manual
 * 
 * Formato de salida:
 * { mag: "CRASH", title: "Nº48 (1985/Oct).", href: "URL" }
 * 
 * ============================================
 */

// ====================================
// REVISTAS DESDE SPECTRUM COMPUTING
// ====================================

function extractSCMagazineReviewsFromHtml_(html) {
  if (!html) return [];

  const block = extractMagazineReviewsBlock_(html);
  if (!block) return [];

  const reviewsRaw = extractMagazineReviewsFromBlock_(block);
  if (!reviewsRaw || !reviewsRaw.length) return [];

  const out = [];
  for (const r of reviewsRaw) {
    if (!r) continue;
    
    const revista = String(r.revista || '').trim();
    const href = String(r.enlace || '').trim();
    const label = formatReviewLabelForFicha_(r);
    
    if (revista && href && label) {
      out.push({
        mag: revista,      // "Sinclair User"
        title: label,      // "Nº55 (1986/Oct)."
        href: href         // URL al PDF/VIEW
      });
    }
  }
  
  return out;
}

// ====================================
// EXTRAER BLOQUE "MAGAZINE REVIEWS"
// ====================================

function extractMagazineReviewsBlock_(html) {
  const markerStart = "Magazine Reviews";
  const startIdx = html.indexOf(markerStart);
  
  if (startIdx < 0) return null;

  // Buscar dónde termina el bloque (siguiente sección)
  const endMarkers = [
    "Magazine References",
    "Magazine Advertisements",
    "Related Magazine References",
    "Magazine related titles",
    "Scrapped File Downloads"
  ];
  
  let endIdx = html.length;
  endMarkers.forEach(m => {
    const idx = html.indexOf(m, startIdx + markerStart.length);
    if (idx > 0 && idx < endIdx) endIdx = idx;
  });

  return html.substring(startIdx, endIdx);
}

// ====================================
// EXTRAER FILAS DE REVISTAS
// ====================================

function extractMagazineReviewsFromBlock_(block) {
  const results = [];
  
  // Localizar todas las filas <div class="row zxdb_stripes">
  const rowOpenRegex = /<div[^>]*class="[^"]*\brow\b[^"]*\bzxdb_stripes\b[^"]*"[^>]*>/gi;
  const rowStarts = [];
  let m;
  
  while ((m = rowOpenRegex.exec(block)) !== null) {
    rowStarts.push(m.index);
  }

  // Procesar cada fila
  for (let i = 0; i < rowStarts.length; i++) {
    const start = rowStarts[i];
    const end = (i + 1 < rowStarts.length) ? rowStarts[i + 1] : block.length;
    const rowHtml = block.substring(start, end);

    // Extraer columnas <div class="...col-md-X...">
    const cols = [];
    const colRegex = /<div[^>]*class="[^"]*col-md-[^"]*"[^>]*>([\s\S]*?)<\/div>/gi;
    let colMatch;
    
    while ((colMatch = colRegex.exec(rowHtml)) !== null) {
      cols.push(colMatch[1]);
    }

    // Necesitamos al menos 4 columnas: Magazine, Issue, Page, Type
    if (cols.length < 4) continue;

    // Columna 1: Revista
    const revista = cleanupText_(stripTags_(cols[0]));

    // Columna 2: Issue + Fecha (formato: "#55 - 1986/Oct")
    const rawIssue = cleanupText_(stripTags_(cols[1]));
    let issue = "", fecha = "";
    
    if (rawIssue) {
      const parts = rawIssue.split(" - ");
      if (parts.length >= 2) {
        issue = parts[0].trim();
        fecha = parts.slice(1).join(" - ").trim();
      } else {
        issue = rawIssue;
      }
    }

    // Columna 3: Página
    const pageCellHtml = cols[2];
    const pageText = cleanupText_(stripTags_(pageCellHtml));
    const firstNumMatch = pageText.match(/\d+(?:-\d+)?/);
    const pagina = firstNumMatch ? firstNumMatch[0] : pageText;

    // Columna 4: Tipo (Review, Preview, etc.)
    const tipo = cleanupText_(stripTags_(cols[3]));

    // Columna 5 (opcional): Score
    const score = cols.length >= 5 ? cleanupText_(stripTags_(cols[4])) : "";

    // Extraer enlace PDF/VIEW desde la celda de página
    let enlace = "";
    const linkMatch = pageCellHtml.match(/href="([^"]+)"/i);
    if (linkMatch && linkMatch[1]) {
      const href = linkMatch[1];
      enlace = /^https?:\/\//i.test(href) 
        ? href 
        : "https://spectrumcomputing.co.uk" + href;
    }

    results.push({
      revista: revista,
      issue: issue,
      fecha: fecha,
      pagina: pagina,
      tipo: tipo,
      score: score,
      enlace: enlace
    });
  }

  return results;
}

// ====================================
// FORMATEAR LABEL PARA LA FICHA
// ====================================

function formatReviewLabelForFicha_(r) {
  if (!r) return "";
  
  const issue = String(r.issue || "").trim();
  const fecha = String(r.fecha || "").trim();
  
  // Extraer solo el número del issue (ej: "#48" → "48")
  const num = issue.match(/\d+/);
  const parts = [];
  
  if (num) parts.push("Nº" + num[0]);
  if (fecha) parts.push("(" + fecha + ")");
  
  let label = parts.join(" ");
  if (label && !label.endsWith(".")) label += ".";
  
  return label.trim();
}

// ====================================
// REVISTAS DESDE LA HOJA (MANUAL)
// ====================================

function parseSheetRevistas_(cellText) {
  const s = String(cellText || '').trim();
  if (!s) return [];
  
  // Separar por saltos de línea o punto y coma
  const items = s.split(/\n|;/).map(x => String(x).trim()).filter(Boolean);
  const out = [];
  
  // Detectar nombre de revista desde texto o URL
  const detectMag = (txt, url) => {
    const hay = (re) => re.test(txt) || re.test(url);
    
    if (hay(/\bcrash\b/i)) return 'CRASH';
    if (hay(/sinclair\s*user/i)) return 'SINCLAIR USER';
    if (hay(/your\s*computer/i)) return 'YOUR COMPUTER';
    if (hay(/your\s*spectrum/i)) return 'YOUR SPECTRUM';
    if (hay(/(?:micro\s*hobby|microhobby)/i)) return 'MICROHOBBY';
    if (hay(/microman[ií]a/i)) return 'MICROMANÍA';
    
    // Si no coincide con ninguna conocida, usar el dominio
    try {
      const h = (new URL(url)).hostname.replace(/^www\./, '');
      return h.toUpperCase();
    } catch (_) {
      return 'REVISTA';
    }
  };

  // Parsear cada línea
  for (const it of items) {
    let label = '', url = '';
    
    // Formato 1: [texto](URL)
    let m = it.match(/\[([^\]]+)\]\((https?:\/\/[^\s)]+)\)/i);
    if (m) {
      label = m[1].trim();
      url = m[2].trim();
    } else {
      // Formato 2: texto | URL
      m = it.match(/^(.+?)\|\s*(https?:\/\/\S+)/i);
      if (m) {
        label = m[1].trim();
        url = m[2].trim();
      } else {
        // Formato 3: solo URL (o texto + URL sin separador claro)
        m = it.match(/(https?:\/\/\S+)/i);
        if (m) {
          url = m[1];
          label = it.replace(m[1], '').trim() || m[1];
        }
      }
    }
    
    if (!url) continue;
    
    const mag = detectMag(label, url);
    out.push({
      mag: mag,
      title: label || url,
      href: url
    });
  }
  
  return out;
}

// ====================================
// HELPER: LIMPIAR TEXTO
// ====================================

function cleanupText_(s) {
  return String(s || "")
    .replace(/&nbsp;/gi, " ")
    .replace(/\s+/g, " ")
    .trim();
}

/**
 * ============================================
 * PARTE 4: SCRAPING ZXART
 * ============================================
 * 
 * Extrae dos datos principales desde ZXArt.ee:
 * 1. Desarrollador (campo "Produced by")
 * 2. Sinopsis (traducida de EN a ES)
 * 
 * Estrategias de búsqueda (en orden):
 * - API de ZXArt
 * - Búsqueda web en el sitio
 * - Slug heurístico
 * 
 * ============================================
 */

// ====================================
// OBTENER DESARROLLADOR DESDE ZXART
// ====================================

function getDeveloperFromZXART_(title) {
  try {
    const q = String(title || '').trim();

    // ESTRATEGIA 1: API de ZXArt
    const apiSearchUrl = `https://zxart.ee/api/search/software?query=${encodeURIComponent(q)}`;
    const searchRes = UrlFetchApp.fetch(apiSearchUrl, { muteHttpExceptions: true });
    
    if (searchRes.getResponseCode() === 200) {
      let hits = [];
      try {
        hits = JSON.parse(searchRes.getContentText());
      } catch (_) {}
      
      if (Array.isArray(hits) && hits.length > 0 && hits[0] && hits[0].id) {
        const dataUrl = `https://zxart.ee/api/software/${hits[0].id}`;
        const dataRes = UrlFetchApp.fetch(dataUrl, { muteHttpExceptions: true });
        
        if (dataRes.getResponseCode() === 200) {
          try {
            const j = JSON.parse(dataRes.getContentText());
            const raw = (j && (j.producedBy || j.productedBy || j.producer || j.author)) || "";
            const text = normalizeProducedBy_(raw);
            if (text) return { text, source: 'zxart_api' };
          } catch (_) {}
        }
      }
    }

    // ESTRATEGIA 2: Búsqueda web en ZXArt
    const webResults = findZxartSoftwarePage_(q);
    if (webResults && webResults.url) {
      const text = fetchZxartProducedByFromPage_(webResults.url);
      if (text) return { text, source: 'zxart_web' };
    }

    // ESTRATEGIA 3: Slug heurístico
    const slug = makeZxartSlug_(q);
    const guessUrl = `https://zxart.ee/eng/software/games/${slug}/`;
    const text3 = fetchZxartProducedByFromPage_(guessUrl);
    if (text3) return { text: text3, source: 'zxart_slug' };

    return { text: "", source: 'none' };
    
  } catch (e) {
    Logger.log('[ERROR] getDeveloperFromZXART_: ' + e);
    return { text: "", source: 'error' };
  }
}

// ====================================
// BUSCAR PÁGINA DE SOFTWARE EN ZXART (WEB)
// ====================================

function findZxartSoftwarePage_(title) {
  try {
    const q = String(title || '').trim();
    const searchUrl = `https://zxart.ee/eng/search/?form=software&query=${encodeURIComponent(q)}`;
    const res = UrlFetchApp.fetch(searchUrl, { muteHttpExceptions: true });
    
    if (res.getResponseCode() !== 200) return null;
    
    const html = res.getContentText();
    const m = html.match(/href=["'](\/eng\/software\/[^"']+)["']/i);
    
    if (m && m[1]) {
      const url = `https://zxart.ee${m[1]}`.replace(/([^:])\/{2,}/g, '$1/').replace('https:/', 'https://');
      return { url, via: 'web_search' };
    }
    
    return null;
  } catch (_) {
    return null;
  }
}

// ====================================
// EXTRAER "PRODUCED BY" DE UNA PÁGINA ZXART
// ====================================

function fetchZxartProducedByFromPage_(url) {
  try {
    const res = UrlFetchApp.fetch(url, { muteHttpExceptions: true });
    if (res.getResponseCode() !== 200) return "";
    
    const html = res.getContentText();
    
    // Buscar el campo "Produced by"
    let cell = findLabelBlock_(html, 'Produced\\s*by');
    if (!cell) cell = findLabelBlock_(html, 'Producido\\s*por');

    if (!cell) {
      const re = /Produced\s*by\s*:<\/[^>]+>\s*<[^>]+>([\s\S]*?)<\/[^>]+>/i;
      const m = re.exec(html);
      if (m) cell = m[1];
    }

    if (!cell) {
      const m2 = /<td[^>]*>\s*Produced\s*by\s*:\s*<\/td>\s*<td[^>]*>([\s\S]*?)<\/td>/i.exec(html);
      if (m2) cell = m2[1];
    }

    if (!cell) return "";

    // Extraer nombres desde enlaces <a>
    const anchors = [];
    for (const a of String(cell).matchAll(/<a[^>]+href=["']([^"']+)["'][^>]*>([\s\S]*?)<\/a>/ig)) {
      const text = stripTags_(a[2]).replace(/\s+/g, ' ').trim();
      if (text) anchors.push(text);
    }
    
    if (anchors.length) return cleanDeveloperList_(anchors.join(', '));
    
    // Si no hay enlaces, usar el texto plano
    const plain = stripTags_(cell).replace(/\s+/g, ' ').trim();
    return cleanDeveloperList_(plain);
    
  } catch (_) {
    return "";
  }
}

// ====================================
// GENERAR SLUG PARA URL ZXART
// ====================================

function makeZxartSlug_(title) {
  return String(title || '')
    .toLowerCase()
    .replace(/[''`´]/g, '')
    .replace(/[^a-z0-9]+/g, '-')
    .replace(/^-+|-+$/g, '')
    .replace(/--+/g, '-');
}

// ====================================
// HELPER: GENERAR SLUG PARA LEMON64
// ====================================

function makeLemon64Slug_(titulo) {
  let slug = String(titulo || '').trim();
  
  // REGLA LEMON64: Eliminar "The " del principio
  if (/^The\s+/i.test(slug)) {
    slug = slug.replace(/^The\s+/i, '');
  }
  
  return slug
    .toLowerCase()
    .normalize('NFD').replace(/[\u0300-\u036f]/g, '') // quitar acentos
    .replace(/[^a-z0-9]+/g, '-') // todo excepto letras/números → guión
    .replace(/^-+|-+$/g, '') // quitar guiones al inicio/final
    .replace(/--+/g, '-'); // múltiples guiones → uno solo
}

// ====================================
// NORMALIZAR DATOS DE "PRODUCED BY"
// ====================================

function normalizeProducedBy_(raw) {
  if (!raw) return "";
  let list = "";
  
  if (Array.isArray(raw)) {
    const names = raw.map(x => 
      (typeof x === 'string') ? x : (x && (x.name || x.title || x.nickname) || '')
    ).filter(Boolean);
    list = names.join(', ');
  } else if (typeof raw === 'object' && raw) {
    list = raw.name || raw.title || raw.nickname || "";
  } else {
    list = String(raw || '');
  }
  
  return cleanDeveloperList_(list);
}

// ====================================
// LIMPIAR LISTA DE DESARROLLADORES
// ====================================

function cleanDeveloperList_(raw) {
  return String(raw || '')
    .split(/[,/]/)
    .map(s => s.trim())
    .filter(s => s.length > 0)
    .map(s => toTitleCase_(s))
    .join(', ');
}

function toTitleCase_(str) {
  return String(str || '').replace(/\w\S*/g, w => 
    w.charAt(0).toUpperCase() + w.slice(1).toLowerCase()
  );
}

// ====================================
// OBTENER SINOPSIS DESDE ZXART (CON TRADUCCIÓN)
// ====================================

function getZXArtSynopsisTranslated_(titulo) {
  const title = (titulo || '').trim();
  
  // Resolver URL del juego en ZXArt
  const url = resolveZXArtUrlForTitle_(title);
  if (!url) {
    return { en: '', es: '', preview: '' };
  }

  // Extraer sinopsis en inglés
  const sinEN = extractZXArtSynopsisFromUrl_(url);
  if (!sinEN || !String(sinEN).trim()) {
    return { en: '', es: '', preview: '' };
  }

  // Normalizar saltos de línea
  const normalizedEn = String(sinEN)
    .replace(/\r\n/g, '\n')
    .replace(/\r/g, '\n')
    .trim();

  // Separar en párrafos
  const paragraphsEn = normalizedEn
    .split(/\n\s*\n+/)
    .map(p => p.replace(/\s+/g, ' ').trim())
    .filter(p => p.length > 0);

  // Si no hay párrafos pero sí texto, usar todo como un párrafo
  if (!paragraphsEn.length && normalizedEn.length) {
    paragraphsEn.push(normalizedEn);
  }

  // Traducir cada párrafo
  let sinES = '';
  if (paragraphsEn.length) {
    const translated = [];
    
    for (let i = 0; i < paragraphsEn.length; i++) {
      const p = paragraphsEn[i];
      let t = '';
      
      try {
        t = LanguageApp.translate(p, 'en', 'es');
      } catch (err) {
        Logger.log('[WARN] Falló traducción de párrafo ' + i + ': ' + err);
        t = p; // Usar original si falla
      }
      
      translated.push(String(t || '').trim());
    }
    
    sinES = translated.join('\n\n');
  } else {
    // Traducción global si no hay párrafos
    try {
      sinES = LanguageApp.translate(normalizedEn, 'en', 'es');
    } catch (err2) {
      Logger.log('[WARN] Falló traducción global: ' + err2);
      sinES = '';
    }
  }

  sinES = String(sinES || '').trim();

  // Si la traducción falla, usar el inglés original
  if (!sinES) {
    sinES = normalizedEn;
  }

  return {
    en: normalizedEn,
    es: sinES,
    preview: normalizedEn.substring(0, 500)
  };
}

// ====================================
// TRADUCCIÓN GENÉRICA DE TEXTO (INGLÉS → ESPAÑOL)
// ====================================
// Usada para traducir sinopsis y argumento de IGDB en PS3
// Sin marcas ni indicadores de traducción

function translateTextToSpanish_(text) {
  if (!text) return '';
  
  const normalizedText = String(text)
    .replace(/\r\n/g, '\n')
    .replace(/\r/g, '\n')
    .trim();
  
  if (!normalizedText) return '';
  
  // Separar en párrafos
  const paragraphs = normalizedText
    .split(/\n\s*\n+/)
    .map(p => p.replace(/\s+/g, ' ').trim())
    .filter(p => p.length > 0);
  
  // Si no hay párrafos pero sí texto, usar todo como un párrafo
  if (!paragraphs.length && normalizedText.length) {
    paragraphs.push(normalizedText);
  }
  
  // Traducir cada párrafo
  let translatedText = '';
  if (paragraphs.length) {
    const translated = [];
    
    for (let i = 0; i < paragraphs.length; i++) {
      const p = paragraphs[i];
      let t = '';
      
      try {
        t = LanguageApp.translate(p, 'en', 'es');
      } catch (err) {
        Logger.log('[WARN] Falló traducción de párrafo ' + i + ': ' + err);
        t = p; // Usar original si falla
      }
      
      translated.push(String(t || '').trim());
    }
    
    translatedText = translated.join('\n\n');
  } else {
    // Traducción global si no hay párrafos
    try {
      translatedText = LanguageApp.translate(normalizedText, 'en', 'es');
    } catch (err2) {
      Logger.log('[WARN] Falló traducción global: ' + err2);
      translatedText = normalizedText; // Usar original si falla
    }
  }
  
  translatedText = String(translatedText || '').trim();
  
  // Si la traducción falla completamente, usar el original
  if (!translatedText) {
    translatedText = normalizedText;
  }
  
  return translatedText;
}

// ====================================
// RESOLVER URL DE ZXART PARA UN TÍTULO
// ====================================

function resolveZXArtUrlForTitle_(rawTitle) {
  const title = (rawTitle || "").trim();
  if (!title) return "";

  const base = "https://zxart.ee";

  // ESTRATEGIA 1: API de ZXArt
  try {
    const apiUrl = base + "/api/search/software?query=" + encodeURIComponent(title);
    const apiResp = UrlFetchApp.fetch(apiUrl, { muteHttpExceptions: true });
    const code = apiResp.getResponseCode();
    const text = apiResp.getContentText("UTF-8") || "";

    const match = text.match(/"?(\/eng\/software\/[^"]+)"/);
    if (code === 200 && match && match[1]) {
      const candidate = base + match[1];
      if (urlExists_(candidate)) return candidate;
    }
  } catch (e) {}

  // ESTRATEGIA 2: Búsqueda web
  try {
    const sUrl = base + "/eng/search/?form=software&query=" + encodeURIComponent(title);
    const resp = UrlFetchApp.fetch(sUrl, { muteHttpExceptions: true });
    const code = resp.getResponseCode();
    const html = resp.getContentText("UTF-8") || "";

    const p = findFirstSoftwareUrlInHtml_(html);
    if (p) {
      const candidate = base + p;
      if (urlExists_(candidate)) return candidate;
    }
  } catch (e) {}

  // ESTRATEGIA 3: Slug heurístico
  try {
    const slug = slugifyForZXArt_(title);
    const candidate = base + "/eng/software/games/" + slug + "/";
    if (urlExists_(candidate)) return candidate;
  } catch (e) {}

  return "";
}

// ====================================
// EXTRAER SINOPSIS DESDE URL DE ZXART
// ====================================

function extractZXArtSynopsisFromUrl_(url) {
  try {
    const resp = UrlFetchApp.fetch(url, { muteHttpExceptions: true });
    const code = resp.getResponseCode();
    const html = resp.getContentText("UTF-8") || "";

    if (code !== 200 || !html.length) return "";

    // Buscar bloque de descripción larga
    const block = extractLongBlock_(html);
    if (block) return cleanSynopsisText_(block);

    // Buscar og:description
    const og = extractMetaContent_(html, "property", "og:description");
    if (og) return cleanSynopsisText_(og);

    // Buscar meta description
    const meta = extractMetaContent_(html, "name", "description");
    if (meta) return cleanSynopsisText_(meta);

    return "";
  } catch (e) {
    Logger.log('[ERROR] extractZXArtSynopsisFromUrl_: ' + e);
    return "";
  }
}

// ====================================
// EXTRAER BLOQUE DE DESCRIPCIÓN LARGA
// ====================================

function extractLongBlock_(html) {
  const regex = /<div class="zxprod_details_description"[^>]*>([\s\S]*?)<\/div>/i;
  const m = html.match(regex);
  if (!m) return "";

  let t = m[1];
  t = t.replace(/<br\s*\/?>/gi, "\n");
  t = t.replace(/<\/p>/gi, "\n\n");
  t = t.replace(/<[^>]+>/g, "");
  
  return t;
}

// ====================================
// EXTRAER META TAG CONTENT
// ====================================

function extractMetaContent_(html, attrName, attrValue) {
  const regex = new RegExp(`<meta[^>]+${attrName}="${attrValue}"[^>]+content="([^"]+)"`, "i");
  const m = html.match(regex);
  return m ? m[1] : "";
}

// ====================================
// LIMPIAR TEXTO DE SINOPSIS
// ====================================

function cleanSynopsisText_(text) {
  if (!text) return '';

  const raw = String(text)
    .replace(/\r\n/g, '\n')
    .replace(/\r/g, '\n');

  const paragraphs = raw
    .split(/\n\s*\n+/)
    .map(p => p.replace(/\n+/g, ' ').replace(/\s+/g, ' ').trim())
    .filter(p => p.length > 0);

  if (!paragraphs.length) {
    return raw.replace(/\s+/g, ' ').trim();
  }

  return paragraphs.join('\n\n');
}

// ====================================
// HELPERS AUXILIARES
// ====================================

function urlExists_(u) {
  try {
    const r = UrlFetchApp.fetch(u, { muteHttpExceptions: true });
    return r.getResponseCode() === 200;
  } catch (e) {
    return false;
  }
}

function findFirstSoftwareUrlInHtml_(html) {
  const re = /href="(\/eng\/software\/[^"]+)"/g;
  let m;
  while ((m = re.exec(html)) !== null) return m[1];
  return "";
}

function slugifyForZXArt_(title) {
  let s = title.toLowerCase();
  const accentMap = {
    "á": "a", "à": "a", "ä": "a", "â": "a",
    "é": "e", "è": "e", "ë": "e", "ê": "e",
    "í": "i", "ì": "i", "ï": "i", "î": "i",
    "ó": "o", "ò": "o", "ö": "o", "ô": "o",
    "ú": "u", "ù": "u", "ü": "u", "û": "u",
    "ñ": "n", "ç": "c"
  };
  s = s.split("").map(ch => accentMap[ch] || ch).join("");
  s = s.replace(/[^a-z0-9 ]+/g, " ").replace(/\s+/g, " ").trim();
  return s.replace(/ /g, "-");
}

/**
 * ============================================
 * ESCRIBIR DATOS EN LA HOJA COMMODORE 64
 * ============================================
 * 
 * Escribe los datos scrapeados desde Lemon64 en la hoja C64.
 * Solo rellena celdas VACÍAS (respeta datos manuales).
 * 
 * Columnas gestionadas:
 * - ID_LEMON64, AÑO, PUBLISHER, DESARROLLADOR, AUTORES
 * - GÉNERO, SUBGÉNERO, JUGADORES, CONTROLES
 * - CARÁTULA, SCREENSHOTS, IMÁGENES, VIDEO
 * - REVISTAS, INSTRUCCIONES, PUNTUACIÓN
 * 
 * ============================================
 */

function writeBackC64RowFromData_(sh, row, headers, data, extras) {
// ========== LOGS DE DEBUGGING C64 ==========
  Logger.log('[C64 WRITE] ========================================');
  Logger.log('[C64 WRITE] Escribiendo datos en fila ' + row);
  Logger.log('[C64 WRITE] Título: ' + (data.titulo || 'N/A'));
  Logger.log('[C64 WRITE] Año: ' + (data.anio || 'N/A'));
  Logger.log('[C64 WRITE] Publisher: ' + (Array.isArray(data.publisherAnchors) && data.publisherAnchors.length > 0 ? data.publisherAnchors.map(a => a.text).join(', ') : 'N/A'));
  Logger.log('[C64 WRITE] Desarrollador: ' + (Array.isArray(data.desarrolladorAnchors) && data.desarrolladorAnchors.length > 0 ? data.desarrolladorAnchors.map(a => a.text).join(', ') : 'N/A'));
  Logger.log('[C64 WRITE] Géneros: ' + (Array.isArray(data.generoAnchors) && data.generoAnchors.length > 0 ? data.generoAnchors.map(a => a.text).join(', ') : 'N/A'));
  Logger.log('[C64 WRITE] Puntuación: ' + (data.ratingDisplay || 'N/A'));
  Logger.log('[C64 WRITE] Carátula: ' + (data.caratula || 'VACÍO'));
  Logger.log('[C64 WRITE] Screenshots: ' + (Array.isArray(data.screenshots) ? data.screenshots.length + ' imágenes' : 'N/A'));
  Logger.log('[C64 WRITE] Imágenes adicionales: ' + (Array.isArray(data.imagenesAdicionales) ? data.imagenesAdicionales.length + ' imágenes' : 'N/A'));
  Logger.log('[C64 WRITE] Video: ' + (data.video ? 'SÍ (' + data.video.substring(0, 50) + '...)' : 'NO'));
  Logger.log('[C64 WRITE] Instrucciones: ' + (data.instrucciones ? 'SÍ' : 'NO'));
  Logger.log('[C64 WRITE] Revistas: ' + (Array.isArray(data.revistas) ? data.revistas.length + ' revistas' : 'N/A'));
  Logger.log('[C64 WRITE] Sinopsis: ' + (extraOpts && extraOpts.sinopsis ? extraOpts.sinopsis.substring(0, 80) + '...' : 'VACÍO'));
  Logger.log('[C64 WRITE] ========================================');
  if (!data) return;

  // ====================================
  // HELPER: NORMALIZAR NOMBRES DE COLUMNAS
  // ====================================
  function normalizeHeaderKey_(s) {
    let t = String(s || '').toLowerCase().trim();
    // Quitar acentos
    t = t.replace(/[áàäâ]/g, 'a').replace(/[éèëê]/g, 'e').replace(/[íìïî]/g, 'i')
         .replace(/[óòöô]/g, 'o').replace(/[úùüû]/g, 'u').replace(/ñ/g, 'n');
    return t.replace(/\s+/g, ' ');
  }

  // ====================================
  // HELPER: ENCONTRAR ÍNDICE DE COLUMNA
  // ====================================
  function colIndex_(name) {
    const target = normalizeHeaderKey_(name || '');
    for (let i = 0; i < headers.length; i++) {
      if (normalizeHeaderKey_(headers[i]) === target) return i + 1;
    }
    return 0;
  }

  // ====================================
  // HELPER: LIMPIAR VALOR
  // ====================================
  function cleanValue_(v) {
    if (v == null) return '';
    let t = String(v).trim();
    if (!t || t === '????' || /^dato no disponible$/i.test(t)) return '';
    return t;
  }

  // ====================================
  // HELPER: ESCRIBIR SI ESTÁ VACÍO
  // ====================================
  function writeIfEmpty_(colName, value) {
    const col = colIndex_(colName);
    const v = cleanValue_(value);
    if (!col || !v) return;
    
    const rng = sh.getRange(row, col);
    const currentValue = String(rng.getValue() || '').trim();
    
    if (!currentValue) {
      rng.setValue(v);
      Logger.log('[C64] Escrito en ' + colName + ': ' + v.substring(0, 50));
    } else {
      Logger.log('[C64] Respetado valor manual en ' + colName);
    }
  }

  // ====================================
  // HELPER: CONVERTIR ANCHORS A TEXTO
  // ====================================
  function anchorsToText_(arr) {
    return (Array.isArray(arr) ? arr : [])
      .map(a => (a && a.text) ? String(a.text) : '')
      .filter(Boolean)
      .join(', ');
  }

  // ====================================
  // HELPER: CONVERTIR REVISTAS A MARKDOWN
  // ====================================
  function revistasToMarkdown_(arr) {
    if (!Array.isArray(arr) || !arr.length) return '';
    
    return arr.map(r => {
      const mag = r.mag || 'Revista';
      const title = r.title || mag;
      const href = r.href || '#';
      
      return `[${mag} - ${title}](${href})`;
    }).join('\n');
  }

  // ====================================
  // ESCRIBIR DATOS EN LA HOJA
  // ====================================

  // ID Lemon64
  writeIfEmpty_('ID_LEMON64', data.idLemon64);

  // Año
  writeIfEmpty_('AÑO', data.anio);
  writeIfEmpty_('ANO', data.anio); // Por si acaso sin tilde

  // Publisher
  writeIfEmpty_('PUBLISHER', anchorsToText_(data.publisherAnchors));

  // Desarrollador
  writeIfEmpty_('DESARROLLADOR', anchorsToText_(data.desarrolladorAnchors));

  // Autores (ya viene como texto con roles)
  writeIfEmpty_('AUTORES', data.autores);

  // Género
  writeIfEmpty_('GÉNERO', anchorsToText_(data.generoAnchors));
  writeIfEmpty_('GENERO', anchorsToText_(data.generoAnchors));

  // Subgénero
  writeIfEmpty_('SUBGÉNERO', anchorsToText_(data.subgeneroAnchors));
  writeIfEmpty_('SUBGENERO', anchorsToText_(data.subgeneroAnchors));

  // Jugadores
  writeIfEmpty_('JUGADORES', anchorsToText_(data.jugadoresAnchors));

  // Controles
  writeIfEmpty_('CONTROLES', anchorsToText_(data.controlesAnchors));

  // Carátula
  writeIfEmpty_('CARÁTULA', data.caratula);
  writeIfEmpty_('CARATULA', data.caratula);

  // Screenshots (primeras 2, separadas por salto de línea)
  if (Array.isArray(data.screenshots) && data.screenshots.length) {
    writeIfEmpty_('SCREENSHOTS', data.screenshots.join('\n'));
  }

  // Imágenes adicionales (desde 3ª, separadas por ", ")
  if (Array.isArray(data.imagenesAdicionales) && data.imagenesAdicionales.length) {
    writeIfEmpty_('IMÁGENES', data.imagenesAdicionales.join(', '));
    writeIfEmpty_('IMAGENES', data.imagenesAdicionales.join(', '));
  }

  // Video
  writeIfEmpty_('VIDEO', data.video);

  // Revistas (formato Markdown con enlaces)
  const revistasMarkdown = revistasToMarkdown_(data.revistas);
  if (revistasMarkdown) {
    writeIfEmpty_('REVISTAS', revistasMarkdown);
  }

  // Instrucciones
  writeIfEmpty_('INSTRUCCIONES', data.instrucciones);

  // Puntuación
  writeIfEmpty_('PUNTUACIÓN', data.ratingDisplay);
  writeIfEmpty_('PUNTUACION', data.ratingDisplay);

  // ====================================
  // EXTRAS (sinopsis si viene en extras)
  // ====================================
  if (extras && extras.sinopsis) {
    writeIfEmpty_('SINOPSIS', extras.sinopsis);
  }

  Logger.log('[C64] Escritura completada en fila ' + row);
}

/**
 * ============================================
 * PARTE 5: GENERACIÓN HTML DE LA FICHA
 * ============================================
 * 
 * Genera el HTML completo de la ficha con:
 * - Información básica (año, publisher, autor, etc.)
 * - Sinopsis (con párrafos)
 * - Datos técnicos
 * - Screenshots
 * - Imágenes adicionales
 * - Gameplay (YouTube)
 * - Revistas
 * - Útiles (mapa, instrucciones, enlace fuente)
 * 
 * ============================================
 */

function buildPreviewHtml_(titulo, plataforma, fuenteUrl, d, tecnicos, sinopsisText) {
  
  // ====================================
  // CSS DE LA FICHA
  // ====================================
  const css = `
    <style>
      body {
        font-family: Arial, Helvetica, sans-serif;
        padding: 14px;
      }
      .h1 {
        font-weight: 700;
        font-size: 20px;
        margin: 0 0 6px;
      }
      .meta {
        color: #666;
        font-size: 12px;
        margin: 0 0 10px;
      }
      .row {
        margin: 8px 0;
      }
      .cover {
        max-width: 100%;
        border-radius: 8px;
      }
      .section-title {
        font-weight: 700;
        margin-top: 10px;
      }
      .grid2 {
        display: grid;
        grid-template-columns: repeat(2, 1fr);
        gap: 6px;
      }
      .shots img, .addimgs img {
        width: 100%;
        border-radius: 6px;
        display: block;
        border: 1px solid #ddd;
      }
      .info {
        font-size: 13px;
        line-height: 1.5;
        color: #222;
        margin-top: 8px;
      }
      .info .line {
        margin: 2px 0;
      }
      .info b {
        font-weight: 700;
      }
      .video {
        position: relative;
        padding-bottom: 56.25%;
        height: 0;
      }
      .video iframe {
        position: absolute;
        left: 0;
        top: 0;
        width: 100%;
        height: 100%;
        border: 0;
        border-radius: 8px;
      }
      a {
        word-break: break-word;
        text-decoration: none;
      }
    </style>`;

  // ====================================
  // HELPERS INTERNOS
  // ====================================
  
  // Convierte array de anchors a HTML con enlaces
  const toJoinedLinks = (arr) => (arr && arr.length)
    ? arr.map(a => `<a href="${escapeAttr_(a.href)}" target="_blank">${escapeHtml_(a.text)}</a>`).join(', ')
    : '';

  // Crea anchors locales desde texto simple
  const makeLocalAnchors = (txt) => {
    const s = String(txt || '').trim();
    if (!s) return [];
    return s.split(/\s*,\s*/).map(t => t.trim()).filter(Boolean).map(t => ({ text: t, href: '#' }));
  };

  // Renderiza una línea con enlaces
  const renderLineLinks = (label, anchors) => {
    if (!anchors || !anchors.length) return '';
    return `<div class="line">· <b>${escapeHtml_(label)}:</b> ${toJoinedLinks(anchors)}</div>`;
  };

  // Renderiza una línea con texto plano
  const renderLineText = (label, text) => {
    return `<div class="line">· <b>${escapeHtml_(label)}:</b> ${escapeHtml_(text || '')}</div>`;
  };

  // ====================================
  // CARÁTULA
  // ====================================
  const cover = d.caratula 
    ? `<div class="row"><img class="cover" src="${escapeAttr_(d.caratula)}" alt="CARÁTULA"/></div>` 
    : '';

  // ====================================
  // PLATAFORMA
  // ====================================
  const plataformaMeta = plataforma 
    ? `<div class="meta">${escapeHtml_(plataforma)}</div>` 
    : '';

  // ====================================
  // SINOPSIS (RESPETA PÁRRAFOS)
  // ====================================
  const sinopsisBlock = (() => {
    const raw = sinopsisText && String(sinopsisText).trim();
    if (!raw) return '';

    // Separar por párrafos (saltos de línea dobles)
    const paragraphs = raw
      .split(/\n\s*\n+/)
      .map(p => p.trim())
      .filter(Boolean);

    const htmlParagraphs = paragraphs
      .map(p => `<div class="line">${escapeHtml_(p)}</div>`)
      .join('');

    return `<div class="row"><div class="section-title">Sinopsis</div><div class="info">${htmlParagraphs}</div></div>`;
  })();

  // ====================================
  // ARGUMENTO (SOLO PS3, desde storyline de IGDB)
  // ====================================
  // Se muestra solo si hay contenido en el campo argumento y es ficha PS3
  const argumentoBlock = (() => {
  const isIGDB = (plataforma && !plataforma.toLowerCase().includes('spectrum'));
    if (!isIGDB) return '';
    
    const argumentoText = (d && d.argumento) ? String(d.argumento).trim() : '';
    if (!argumentoText) return '';
    
    // Convertir saltos de línea a <br> para respetar el formato
    const argumentoFormatted = escapeHtml_(argumentoText).replace(/\n/g, '<br>');
    
    return `<div class="row"><div class="section-title">Argumento</div><div class="info"><div class="line">${argumentoFormatted}</div></div></div>`;
  })();

  // ====================================
  // INFORMACIÓN
  // ====================================
  const infoLinesArr = [
    renderLineLinks('Año', splitByCommaToAnchors_(d.anio, fuenteUrl)),
    renderLineLinks('Publisher', d.publisherAnchors),
    renderLineLinks('Desarrollo', d.desarrolladorAnchors),
    renderLineLinks('Autor', d.autorAnchors),
    renderLineLinks('Contribuciones', d.contributorsAnchors),
    renderLineLinks('Género', d.generoAnchors),
    renderLineLinks('Subgénero', d.subgeneroAnchors),
    renderLineLinks('Controles', d.controlesAnchors),
    renderLineLinks('Versión', d.versionAnchors),
    renderLineLinks('Distribuidoras', d.distribuidorasAnchors),
    renderLineText('Puntuación', (d.ratingDisplay && String(d.ratingDisplay).trim()) ? d.ratingDisplay : 'Dato no disponible')
  ].filter(Boolean);

  const infoHtml = infoLinesArr.length
    ? `<div class="row"><div class="section-title">Información</div><div class="info">${infoLinesArr.join('')}</div></div>`
    : '';

  // ====================================
  // DATOS TÉCNICOS (ADAPTADO A ZX / PS3)
  // ====================================// ====================================
  // DATOS TÉCNICOS
  // ====================================
  const isPS3 = (plataforma && plataforma.toLowerCase().includes('playstation'));
  const isC64 = (plataforma && plataforma.toLowerCase().includes('commodore'));
  const isZX = !isPS3 && !isC64;
  
  let tecnicosLines = '';

  if (isPS3) {
    // Datos técnicos para plataformas IGDB (PS3, Switch, etc.)
    tecnicosLines = [
      renderLineLinks('Modos de juego', d.jugadoresAnchors),
      (tecnicos && tecnicos.ubicacion && tecnicos.ubicacion !== '--') ? renderLineText('Ubicación', tecnicos.ubicacion) : '',
      tecnicos && tecnicos.tipoFormato ? renderLineText('Formato', tecnicos.tipoFormato) : '',
      (tecnicos && tecnicos.favorito && tecnicos.favorito.toUpperCase() === 'SI') ? renderLineText('Favorito', tecnicos.favorito) : '',
      tecnicos && tecnicos.terminado ? renderLineText('Terminado', tecnicos.terminado) : ''
    ].filter(Boolean).join('');
  } else if (isC64) {
    // Datos técnicos para Commodore 64
    tecnicosLines = [
      renderLineLinks('Modos de juego', d.jugadoresAnchors),
      tecnicos && tecnicos.formato ? renderLineText('Formato', tecnicos.formato) : '',
      tecnicos && tecnicos.funciona ? renderLineText('Funciona', tecnicos.funciona) : '',
      (tecnicos && tecnicos.favorito && tecnicos.favorito.toUpperCase() === 'SI') ? renderLineText('Favorito', tecnicos.favorito) : '',
      tecnicos && tecnicos.terminado ? renderLineText('Terminado', tecnicos.terminado) : ''
    ].filter(Boolean).join('');
  } else {
    // Datos técnicos para ZX Spectrum
    tecnicosLines = [
      renderLineLinks('Modos de juego', d.jugadoresAnchors),
      renderLineLinks('Formato', makeLocalAnchors(tecnicos && tecnicos.formato)),
      renderLineLinks('ZX +2A', makeLocalAnchors(tecnicos && tecnicos.zx2a)),
      renderLineLinks('TSPEC', makeLocalAnchors(tecnicos && tecnicos.tspec)),
      renderLineText('Terminado', tecnicos && tecnicos.terminado)
    ].filter(Boolean).join('');
  }

  const tecnicosHtml = tecnicosLines
    ? `<div class="row"><div class="section-title">Datos Técnicos</div><div class="info">${tecnicosLines}</div></div>`
    : '';
  // ====================================
  // MÁS INFO (SOLO PS3, SECCIÓN SEPARADA)
  // ====================================
  // Se muestra solo si hay contenido en MAS_INFO y es ficha PS3
  // Respeta saltos de línea del texto original
 const masInfoHtml = (() => {
    if (!isPS3) return '';
    const masInfoText = (tecnicos && tecnicos.masInfo) ? String(tecnicos.masInfo).trim() : '';
    if (!masInfoText) return '';
    
    // Convertir saltos de línea a <br> para respetar el formato del usuario
    const masInfoFormatted = escapeHtml_(masInfoText).replace(/\n/g, '<br>');
    
    return `<div class="row"><div class="section-title">Más Info</div><div class="info"><div class="line">${masInfoFormatted}</div></div></div>`;
  })();

  // ====================================
  // SCREENSHOTS
  // ====================================
  const shotsHtml = (d.screenshots && d.screenshots.length)
    ? `<div class="row"><div class="section-title">Screenshots</div><div class="grid2 shots">${
        d.screenshots.map(u => `<img src="${escapeAttr_(u)}" alt="">`).join('')
      }</div></div>`
    : '';

  // ====================================
  // IMÁGENES ADICIONALES
  // ====================================
  const addHtml = (d.imagenesAdicionales && d.imagenesAdicionales.length)
    ? `<div class="row"><div class="section-title">Imágenes adicionales</div><div class="grid2 addimgs">${
        d.imagenesAdicionales.map(u => `<img src="${escapeAttr_(u)}" alt="">`).join('')
      }</div></div>`
    : '';

  // ====================================
  // GAMEPLAY (YOUTUBE)
  // ====================================
  const videoBlock = d.video && /youtube\.com|youtu\.be/i.test(d.video)
    ? `<div class="row">
         <div class="section-title">Gameplay</div>
         <div class="video"><iframe src="${escapeAttr_(youtubeEmbedUrl_(d.video))}" allowfullscreen loading="lazy"></iframe></div>
       </div>`
    : (d.video
        ? `<div class="row">
             <div class="section-title">Gameplay</div>
             <a href="${escapeAttr_(d.video)}" target="_blank">▶ Gameplay (YouTube)</a>
           </div>`
        : '');

  // ====================================
  // REVISTAS
  // ====================================
  const revistasLines = (d.revistas || []).map(it =>
    `<div class="line"><b>· ${escapeHtml_(it.mag)}: </b><a href="${escapeAttr_(it.href)}" target="_blank">${escapeHtml_(it.title)}</a></div>`
  ).join('');
  
  const revistasHtml = revistasLines
    ? `<div class="row"><div class="section-title">Revistas</div><div class="info">${revistasLines}</div></div>`
    : '';

  // ====================================
  // ÚTILES (MAPA, INSTRUCCIONES, ENLACE FUENTE)
  // ====================================
  const utilesBlock = (d.mapa || d.instrucciones || fuenteUrl)
    ? `<div class="row">
         <div class="section-title">Útiles</div>
         <div class="info">
           ${d.mapa ? `<div class="line">· <a href="${escapeAttr_(d.mapa)}" target="_blank">🗺️ Mapa</a></div>` : ''}
           ${d.instrucciones ? `<div class="line">· <a href="${escapeAttr_(d.instrucciones)}" target="_blank">📄 Instrucciones</a></div>` : ''}
           ${fuenteUrl ? `<div class="line">· <a href="${escapeAttr_(fuenteUrl)}" target="_blank">🔗 Enlace fuente</a></div>` : ''}
         </div>
       </div>`
    : '';

  // ====================================
  // ENSAMBLAR HTML COMPLETO
  // ====================================
  return `<!DOCTYPE html><html><head><meta charset="UTF-8">${css}</head><body>`
    + `<div class="h1">${escapeHtml_(titulo)}</div>`
    + plataformaMeta
    + cover
    + infoHtml
    + sinopsisBlock
    + argumentoBlock
    + tecnicosHtml
    + masInfoHtml
    + shotsHtml
    + addHtml
    + videoBlock
    + revistasHtml
    + utilesBlock
    + `</body></html>`;
}

// ====================================
// HELPER: FORMATEAR PUNTUACIÓN
// ====================================

function formatRatingDisplay_(score10, votes) {
  const hasScore = (typeof score10 === 'number') && !isNaN(score10);
  const hasVotes = (typeof votes === 'number') && !isNaN(votes);

  if (!hasScore || !hasVotes) {
    return 'Dato no disponible';
  }

  if (score10 === 0 && votes === 0) {
    return 'Dato no disponible';
  }

  // Formateo con coma decimal
  const scoreStr = (Math.round(score10 * 10) / 10).toFixed(1).replace('.', ',');
  const votosStr = `${votes} voto${votes === 1 ? '' : 's'}`;
  
  return `${scoreStr} (${votosStr})`;
}

// ====================================
// HELPER: CONVERTIR URL DE YOUTUBE A EMBED
// ====================================

function youtubeEmbedUrl_(u) {
  try {
    let url = String(u);
    
    // youtu.be/ID
    const m1 = url.match(/youtu\.be\/([A-Za-z0-9_-]{6,})/);
    if (m1) return `https://www.youtube.com/embed/${m1[1]}`;
    
    // youtube.com/watch?v=ID
    const v = (url.match(/[?&]v=([A-Za-z0-9_-]{6,})/) || [])[1];
    if (v) return `https://www.youtube.com/embed/${v}`;
    
    // youtube.com/embed/ID (ya está en formato correcto)
    const m2 = url.match(/\/embed\/([A-Za-z0-9_-]{6,})/);
    if (m2) return `https://www.youtube.com/embed/${m2[1]}`;
    
    return url;
  } catch (e) {
    return u;
  }
}

/**
 * ============================================
 * PARTE 6: ESCRITURA EN SHEET + IDS
 * ============================================
 * 
 * Funciones para:
 * 1. Escribir datos scrapeados en la hoja (solo celdas vacías)
 * 2. Rellenar IDs automáticamente
 * 3. Limpieza de comillas
 * 
 * ============================================
 */

// ====================================
// ESCRIBIR DATOS EN LA HOJA (SOLO CELDAS VACÍAS)
// ====================================

function writeBackZXRowFromData_(sh, row, headers, data, opts) {
  opts = opts || {};
  const autoScreens = Array.isArray(opts.autoScreenshots) ? opts.autoScreenshots : [];
  const sinopsis = String(opts.sinopsis || '').trim();

  // ====================================
  // HELPER: NORMALIZAR NOMBRES DE COLUMNAS
  // ====================================
  function normalizeHeaderKey_(s) {
    let t = String(s || '').toLowerCase().trim();
    
    // Quitar tildes
    t = t
      .replace(/[áàäâ]/g, 'a')
      .replace(/[éèëê]/g, 'e')
      .replace(/[íìïî]/g, 'i')
      .replace(/[óòöô]/g, 'o')
      .replace(/[úùüû]/g, 'u')
      .replace(/ñ/g, 'n');
    
    t = t.replace(/\s+/g, ' ');
    return t;
  }

  // ====================================
  // HELPER: ENCONTRAR ÍNDICE DE COLUMNA
  // ====================================
  function colIndex_(name) {
    const target = normalizeHeaderKey_(name);
    for (let i = 0; i < headers.length; i++) {
      const hKey = normalizeHeaderKey_(headers[i]);
      if (hKey === target) return i + 1;
    }
    return 0;
  }

  // ====================================
  // HELPER: ESCRIBIR SI LA CELDA ESTÁ VACÍA
  // ====================================
  function writeIfEmpty_(colName, value) {
    const col = colIndex_(colName);
    if (!col || value == null) return;

    const rng = sh.getRange(row, col);
    const current = String(rng.getValue() || '').trim();

    // Limpiar comillas del valor
    const v = limpiarComillasExtra_(value);

    if (!current && v) {
      rng.setValue(v);
    }
  }

  // ====================================
  // APLANAR DATOS A STRINGS
  // ====================================
  const anio = data.anio || '';
  const publisher = (data.publisherAnchors || []).map(a => a.text).join(', ');
  const dev = (data.desarrolladorAnchors || []).map(a => a.text).join(', ');
  const genero = (data.generoAnchors || []).map(a => a.text).join(', ');
  const subgenero = (data.subgeneroAnchors || []).map(a => a.text).join(', ');
  const autor = (data.autorAnchors || []).map(a => a.text).join(', ');
  const contrib = (data.contributorsAnchors || []).map(a => a.text).join(', ');
  const jugadores = (data.jugadoresAnchors || []).map(a => a.text).join(', ');
  const controles = (data.controlesAnchors || []).map(a => a.text).join(', ');
  const version = (data.versionAnchors || []).map(a => a.text).join(', ');
  const distrib = (data.distribuidorasAnchors || []).map(a => a.text).join(', ');
  
  const caratula = data.caratula || '';
  const screenshots = autoScreens.join(', ');
  const extraImgs = (data.imagenesAdicionales || []).join('\n');
  const mapa = data.mapa || '';
  const instrucciones = data.instrucciones || '';
  const video = data.video || '';
  const ratingDisp = (data.ratingDisplay && String(data.ratingDisplay).trim()) ? data.ratingDisplay : '';

  // REVISTAS: formato [REVISTA - Título](URL)
  const revistasStr = (data.revistas || []).map(r => {
    if (!r || !r.href) return '';
    const mag = String(r.mag || '').trim();
    const title = String(r.title || '').trim();
    const label = mag ? (mag + (title ? ' - ' + title : '')) : title;
    const finalLabel = label || r.href;
    return '[' + finalLabel + '](' + r.href + ')';
  }).filter(line => line !== '').join('\n');

  // ====================================
  // ESCRIBIR DATOS (SOLO SI CELDAS VACÍAS)
  // ====================================
  
  // Carátula: NO escribir si es el fallback genérico
  if (caratula && caratula !== FALLBACK_COVER_URL) {
    writeIfEmpty_('CARÁTULA', caratula);
  }

  writeIfEmpty_('AÑO', anio);
  writeIfEmpty_('PUBLISHER', publisher);
  writeIfEmpty_('DESARROLLADOR', dev);
  writeIfEmpty_('GÉNERO', genero);
  writeIfEmpty_('SUBGÉNERO', subgenero);
  writeIfEmpty_('AUTOR', autor);
  writeIfEmpty_('CONTRIBUCIONES', contrib);
  writeIfEmpty_('JUGADORES', jugadores);
  writeIfEmpty_('CONTROLES', controles);
  writeIfEmpty_('VERSIÓN', version);
  writeIfEmpty_('DISTRIBUIDORAS', distrib);
  writeIfEmpty_('SCREENSHOTS', screenshots);
  writeIfEmpty_('IMÁGENES', extraImgs);
  writeIfEmpty_('REVISTAS', revistasStr);
  writeIfEmpty_('SINOPSIS', sinopsis);
  writeIfEmpty_('MAPA', mapa);
  writeIfEmpty_('INSTRUCCIONES', instrucciones);
  writeIfEmpty_('VIDEO', video);
  writeIfEmpty_('PUNTUACIÓN', ratingDisp);
}

// ====================================
// LIMPIEZA DE COMILLAS
// ====================================

function limpiarComillasExtra_(t) {
  if (t == null) return "";
  t = String(t);

  // Normalizar comillas dobles "raras" a comillas dobles normales
  t = t.replace(/[""«»„‟]/g, '"');

  // Colapsar grupos de comillas dobles múltiples a una sola
  t = t.replace(/"{2,}/g, '"');

  // Eliminar cualquier comilla doble que quede
  t = t.replace(/"/g, "");

  // Espacios múltiples → uno solo
  t = t.replace(/\s{2,}/g, " ").trim();

  return t;
}

// ====================================
// RELLENAR IDs AUTOMÁTICAMENTE
// ====================================

function rellenarIdsZXLista() {
  const ss = SpreadsheetApp.getActive();
  const shActiva = ss.getActiveSheet();
  const nombreHojaActiva = shActiva ? shActiva.getName().trim().toUpperCase() : '';

  if (nombreHojaActiva.includes('PS3')) {
    return rellenarIdPS3FilaActual_(shActiva);
  }

  const sh = ss.getSheetByName('ZX_SPECTRUM');

  if (!sh) return;

  const lastRow = sh.getLastRow();
  if (lastRow < 2) return;

  // Leer cabeceras
  const headers = sh.getRange(1, 1, 1, sh.getLastColumn()).getValues()[0];

  const colIdIndex = headers.indexOf('ID');
  const colTituloIndex = headers.indexOf('TÍTULO') !== -1
    ? headers.indexOf('TÍTULO')
    : headers.indexOf('TITULO');

  if (colIdIndex === -1 || colTituloIndex === -1) return;

  const colId = colIdIndex + 1;
  const colTitulo = colTituloIndex + 1;
  const numRows = lastRow - 1;

  const idsRange = sh.getRange(2, colId, numRows, 1);
  const titulosRange = sh.getRange(2, colTitulo, numRows, 1);

  const ids = idsRange.getValues();
  const titulos = titulosRange.getValues();

  // Encontrar el ID más alto actual
  let maxId = 0;
  for (let i = 0; i < ids.length; i++) {
    const val = ids[i][0];
    if (typeof val === 'number' && !isNaN(val)) {
      if (val > maxId) maxId = val;
    }
  }

  // Rellenar solo IDs vacíos que tengan título
  for (let i = 0; i < ids.length; i++) {
    const idActual = ids[i][0];
    const tituloActual = String(titulos[i][0] || '').trim();

    if (!tituloActual) continue; // Fila vacía
    
    if (idActual === '' || idActual == null) {
      maxId++;
      ids[i][0] = maxId;
    }
  }

  // Guardar los IDs actualizados
  idsRange.setValues(ids);
}

function rellenarIdPS3FilaActual_(sh) {
  const ui = SpreadsheetApp.getUi();
  const activeCell = sh.getActiveCell();
  const row = activeCell ? activeCell.getRow() : 0;

  if (!row || row === 1) {
    return uiAlert_('Selecciona una fila con datos (no la cabecera).');
  }

  const headers = sh.getRange(1, 1, 1, Math.max(1, sh.getLastColumn())).getValues()[0];
  const colIdIndex = headers.indexOf('ID');

  if (colIdIndex === -1) {
    return uiAlert_('No se ha encontrado la columna "ID" en la hoja PS3.');
  }

  const colId = colIdIndex + 1;
  const numRows = Math.max(0, sh.getLastRow() - 1);
  let ids = [];

  if (numRows > 0) {
    ids = sh.getRange(2, colId, numRows, 1).getValues();
  }

  let ultimoId = '';

  for (let i = ids.length - 1; i >= 0; i--) {
    const val = String(ids[i][0] || '').trim();
    if (val) {
      ultimoId = val;
      break;
    }
  }

  let siguienteNumero = 1;

  if (ultimoId) {
    const match = ultimoId.match(/(\d+)$/);
    if (match) {
      siguienteNumero = parseInt(match[1], 10) + 1;
    }
  }

  const nuevoId = `PS3_${String(siguienteNumero).padStart(4, '0')}`;
  sh.getRange(row, colId).setValue(nuevoId);
}

/**
 * ============================================
 * PARTE 7: HELPERS GENERALES (ÚLTIMA PARTE)
 * ============================================
 * 
 * Funciones auxiliares de bajo nivel:
 * - Manipulación de HTML
 * - Manipulación de URLs
 * - Parsing de anchors
 * - Conversión de archivos .scr
 * - Normalización de nombres
 * - Utilidades diversas
 * 
 * ============================================
 */

// ====================================
// UTILIDADES BÁSICAS
// ====================================

function uiAlert_(m) {
  SpreadsheetApp.getUi().alert(m);
}

function stripTags_(s) {
  return String(s || '').replace(/<[^>]*>/g, '');
}

function escapeHtml_(s) {
  return String(s || '').replace(/[&<>"']/g, c => ({
    "&": "&amp;",
    "<": "&lt;",
    ">": "&gt;",
    "\"": "&quot;",
    "'": "&#39;"
  }[c] || c));
}

function escapeAttr_(s) {
  return String(s || '').replace(/"/g, '&quot;');
}

function escapeRegex_(s) {
  return String(s).replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
}

// ====================================
// MANIPULACIÓN DE URLs
// ====================================

function absolutize_(base, url) {
  if (!url) return url;
  if (/^https?:\/\//i.test(url)) return url;
  
  const root = base.replace(/(https?:\/\/[^\/]+).*/, '$1');
  if (url.charAt(0) !== '/') url = '/' + url;
  
  return root + url;
}

function rootOf_(u) {
  return String(u).replace(/(https?:\/\/[^\/]+).*/, '$1');
}

function pathOf_(u) {
  return String(u).replace(/^https?:\/\/[^\/]+\//, '');
}

// ====================================
// CONVERSIÓN DE ARCHIVOS .SCR
// ====================================

function isScr_(u) {
  return /\.scr(?:\?|#|$)/i.test(String(u));
}

function scrToImg_(u) {
  if (!isScr_(u)) return u;
  
  const root = rootOf_(u);
  const path = pathOf_(u);
  
  return `${root}/SCRtoFace.php?SCR=${encodeURIComponent(path)}`;
}

function normalizeKey_(u) {
  let s = String(u);
  s = s.replace(/^https?:\/\/[^\/]+\//, '');
  s = s.replace(/^SCRtoFace\.php\?SCR=/i, '');
  s = s.replace(/[?#].*$/, '');
  return s.toLowerCase();
}

// ====================================
// EXTRACCIÓN DE PANELES HTML
// ====================================

function getPanel_(html, headingReStr) {
  const re = new RegExp(
    '<div\\s+class="panel-heading[^"]*">\\s*' + headingReStr + 
    '[\\s\\S]*?<div\\s+class="panel-body">([\\s\\S]*?)<\\/div>',
    'i'
  );
  const m = re.exec(html);
  return m ? m[1] : '';
}

function findLabelBlock_(fullHtml, label) {
  const L = escapeRegex_(label);
  const re = new RegExp(
    '(?:' +
    '<dt[^>]*>\\s*' + L + '\\s*:?\\s*<\\/dt>\\s*<dd[^>]*>([\\s\\S]*?)<\\/dd>|' +
    '<div\\s+class="col-sm-4">\\s*<b>\\s*' + L + '\\s*:?\\s*<\\/b>\\s*<\\/div>\\s*<div\\s+class="col-sm-8">([\\s\\S]*?)<\\/div>|' +
    '<t[hd][^>]*>\\s*' + L + '\\s*:?\\s*<\\/t[hd]>\\s*<t[hd][^>]*>([\\s\\S]*?)<\\/t[hd]>' +
    ')',
    'i'
  );
  const m = re.exec(fullHtml);
  if (!m) return '';
  return (m[1] || m[2] || m[3] || '');
}

// ====================================
// PARSING DE ANCHORS (ENLACES)
// ====================================

function parseAnchors_(htmlInner, baseUrl) {
  const out = [];
  const s = String(htmlInner || '');
  
  // Buscar todos los enlaces <a>
  for (const m of s.matchAll(/<a[^>]+href=["']([^"']+)["'][^>]*>([\s\S]*?)<\/a>/ig)) {
    const href = absolutize_(baseUrl, m[1]);
    let text = stripTags_(m[2]).replace(/\s+/g, ' ').trim();
    
    // LIMPIEZA: Eliminar patrones comunes de basura en Lemon64
    text = text.replace(/\bInfo\s*\/\s*\d+\s*logos?\b/gi, '').trim();
    text = text.replace(/\bInfo\s*\/\s*\d+\s*photos?\b/gi, '').trim();
    text = text.replace(/\bphoto\b/gi, '').trim();
    text = text.replace(/\bInfo\b$/gi, '').trim();
    text = text.replace(/^\/\s*/, '').trim(); // Eliminar "/" al inicio
    
    if (text && text.length > 1) out.push({ text, href });
  }
  
  if (out.length) return out;

  // Si no hay enlaces, crear anchors desde texto plano
  let plain = stripTags_(s).replace(/\s*\n\s*/g, '|').replace(/\s*[,;]\s*/g, '|');
  
  // Limpiar basura del texto plano también
  plain = plain.replace(/\bInfo\s*\/\s*\d+\s*logos?\b/gi, '');
  plain = plain.replace(/\bInfo\s*\/\s*\d+\s*photos?\b/gi, '');
  plain = plain.replace(/\bphoto\b/gi, '');
  
  const parts = plain.split('|').map(x => x.trim()).filter(x => x.length > 1);
  
  for (const p of parts) {
    const href = `${rootOf_(baseUrl)}/list?quick=s&text=${encodeURIComponent(p)}`;
    out.push({ text: p, href });
  }
  
  return out;
}

function splitByCommaToAnchors_(txt, baseUrl, labelPrefix) {
  const s = String(txt || '').trim();
  if (!s) return [];
  
  const parts = s.split(/\s*,\s*/).map(t => t.trim()).filter(Boolean);
  const root = rootOf_(baseUrl);
  
  return parts.map(p => {
    const q = labelPrefix ? `${labelPrefix} ${p}` : p;
    return {
      text: p,
      href: `${root}/list?quick=s&text=${encodeURIComponent(q)}`
    };
  });
}

// ====================================
// NORMALIZACIÓN DE NOMBRES
// ====================================

function normalizePublisherName_(t) {
  let s = String(t || '').trim();
  
  // Quitar sufijos geográficos
  s = s.replace(/\s*\((?:UK|USA|US|Spain|Italia|France|Germany|ES|GB)\)\s*$/i, '');
  
  // Quitar palabras comunes de empresas
  s = s.replace(/\b(Software|Ltd\.?|Limited|Inc\.?|S\.?A\.?|S\.?L\.?)\b/ig, '');
  s = s.replace(/\s{2,}/g, ' ').trim();
  
  // Normalizar Ocean
  if (/^ocean\b/i.test(s)) s = 'Ocean';
  
  return s;
}

// ====================================
// PARSING DE URLs (ANÁLISIS DE NOMBRES)
// ====================================

function parseUrlName_(u) {
  const full = String(u);
  const clean = full.split(/[?#]/)[0];
  const file = clean.substring(clean.lastIndexOf('/') + 1);
  const dot = file.lastIndexOf('.');
  const base = dot > 0 ? file.substring(0, dot) : file;
  const ext = dot > 0 ? file.substring(dot + 1) : '';
  
  return { full, file, base, ext };
}

/**
 * ============================================
 * INTEGRACIÓN IGDB: fetchPS3_fromIGDB_
 * ============================================
 * 
 * Busca datos del juego en IGDB y devuelve un objeto
 * compatible con buildPreviewHtml_.
 * 
 * LÓGICA DE SELECCIÓN (v2.0):
 * 1) Si hay URL IGDB → usarla directamente (prioridad absoluta)
 * 2) Si no hay URL → búsqueda por título con filtros inteligentes:
 *    - Familia de título (normalización)
 *    - Filtro por año (si está en la hoja)
 *    - Filtro por plataforma PS3
 *    - Descarte de "Part II", "Remastered", etc. si no están en el título de hoja
 *    - Desempate: juego más antiguo
 * 
 * @param {string} titulo - Título del juego a buscar
 * @param {string} link - URL de IGDB (opcional, pero prioritaria)
 * @param {string} anioHoja - Año de la hoja (opcional, para filtrar/desempatar)
 * @returns {Object} - Objeto con estructura compatible con el sistema de fichas
 */
function fetchPS3_fromIGDB_(titulo, link, anioHoja) {
  // ============================================
  // CONSTANTES Y CONFIGURACIÓN
  // ============================================
  
  // ID de plataforma PS3 en IGDB
  const PS3_PLATFORM_ID = 9;
  
  // Términos a eliminar para obtener el "título base"
  const EDITION_TERMS = [
    'remastered', 'remaster', 'remake', 'remade',
    'definitive edition', 'definitive',
    'game of the year', 'goty', 'goty edition',
    'ultimate edition', 'ultimate',
    'complete edition', 'complete',
    'directors cut', 'director\'s cut',
    'extended edition', 'extended',
    'enhanced edition', 'enhanced',
    'special edition', 'special',
    'gold edition', 'gold',
    'platinum', 'platinum edition',
    'hd', 'hd edition', 'hd collection',
    'collection', 'anthology',
    'deluxe', 'deluxe edition',
    'legendary edition', 'legendary'
  ];
  
  // Términos de "parte/secuela" a detectar
  const PART_TERMS = [
    'part ii', 'part 2', 'part two',
    'part iii', 'part 3', 'part three',
    'part iv', 'part 4', 'part four',
    'ii', 'iii', 'iv', 'v', 'vi', 'vii', 'viii', 'ix', 'x',
    '2', '3', '4', '5', '6', '7', '8', '9', '10'
  ];
  
  // ============================================
  // OBJETO VACÍO (FALLBACK)
  // ============================================
  const emptyResult = {
    plataforma: 'PlayStation 3',
    titulo: titulo || 'Juego PS3',
    anio: '????',
    generoAnchors: [],
    subgeneroAnchors: [],
    publisherAnchors: [],
    desarrolladorAnchors: [],
    autorAnchors: [],
    contributorsAnchors: [],
    jugadoresAnchors: [],
    controlesAnchors: [],
    versionAnchors: [],
    distribuidorasAnchors: [],
    ratingDisplay: '',
    caratula: '',
    screenshots: [],
    imagenesAdicionales: [],
    mapa: '',
    instrucciones: '',
    video: '',
    revistas: [],
    sinopsis: ''
  };

  // ============================================
  // VARIABLES DE ENTRADA
  // ============================================
  const titleStr = String(titulo || '').trim();
  const linkStr = String(link || '').trim();
  const desiredYear = parseInt(String(anioHoja || '').trim(), 10);
  const hasDesiredYear = !isNaN(desiredYear);

  if (!titleStr && !linkStr) {
    Logger.log('[IGDB-PS3] Sin título ni link. Abortando.');
    return emptyResult;
  }

  // ============================================
  // HELPERS INTERNOS
  // ============================================
  
  /**
   * Extrae el año de un juego IGDB
   */
  function getYearFromGame_(game) {
    if (!game || !game.first_release_date) return null;
    const d = new Date(game.first_release_date * 1000);
    const y = d.getFullYear();
    return isNaN(y) ? null : y;
  }

  /**
   * Parsea una URL de IGDB para extraer ID y/o slug
   */
  function parseIgdbLink_(url) {
    if (!url) return { id: null, slug: null };
    try {
      const m = String(url).match(/igdb\.com\/games\/([^/?#]+)/i);
      if (!m) return { id: null, slug: null };
      const part = m[1]; // "1234-the-last-of-us" o "the-last-of-us"

      const idMatch = part.match(/^(\d+)-/);
      let id = null;
      let slug = null;

      if (idMatch) {
        id = parseInt(idMatch[1], 10);
        slug = part.substring(idMatch[0].length) || null;
      } else {
        slug = part || null;
      }

      if (isNaN(id)) id = null;
      Logger.log('[IGDB-PS3] parseIgdbLink_ url=' + url + ' → id=' + id + ', slug=' + slug);
      return { id: id, slug: slug };
    } catch (e) {
      Logger.log('[IGDB-PS3] parseIgdbLink_ EXCEPCIÓN: ' + e);
      return { id: null, slug: null };
    }
  }

  /**
   * Normaliza un título para comparación (título base)
   * - Minúsculas
   * - Sin acentos
   * - Sin puntuación
   * - Sin términos de edición (remastered, goty, etc.)
   * - Sin términos de parte (part ii, etc.) → para agrupar familia
   */
  function normalizeToBaseTitle_(text) {
    if (!text) return '';
    let s = String(text).toLowerCase().trim();
    
    // Quitar acentos
    s = s.normalize('NFD').replace(/[\u0300-\u036f]/g, '');
    
    // Quitar puntuación y caracteres especiales (dejar letras, números, espacios)
    s = s.replace(/[^a-z0-9\s]/g, ' ');
    
    // Quitar términos de edición
    EDITION_TERMS.forEach(function(term) {
      var re = new RegExp('\\b' + term.replace(/[.*+?^${}()|[\]\\]/g, '\\$&') + '\\b', 'gi');
      s = s.replace(re, ' ');
    });
    
    // Quitar términos de parte/secuela (para agrupar en familia)
    // Pero solo los que están al final o separados
    PART_TERMS.forEach(function(term) {
      // Solo quitar si está al final del título o separado
      var re = new RegExp('\\s+' + term.replace(/[.*+?^${}()|[\]\\]/g, '\\$&') + '(?:\\s+|$)', 'gi');
      s = s.replace(re, ' ');
    });
    
    // Colapsar espacios múltiples
    s = s.replace(/\s+/g, ' ').trim();
    
    return s;
  }

  /**
   * Comprueba si un texto contiene alguno de los términos de "parte/secuela"
   */
  function containsPartTerms_(text) {
    if (!text) return false;
    var lower = String(text).toLowerCase();
    
    // Patrones específicos para Part II, Part 2, etc.
    var partPatterns = [
      /\bpart\s*(ii|iii|iv|v|vi|vii|viii|ix|x|2|3|4|5|6|7|8|9|10)\b/i,
      /\b(ii|iii|iv|v|vi|vii|viii|ix|x)\s*$/i,  // Números romanos al final
      /\s+(2|3|4|5|6|7|8|9|10)\s*$/  // Números arábigos al final (con cuidado)
    ];
    
    for (var i = 0; i < partPatterns.length; i++) {
      if (partPatterns[i].test(lower)) return true;
    }
    
    return false;
  }

  /**
   * Comprueba si un texto contiene términos de edición especial
   */
  function containsEditionTerms_(text) {
    if (!text) return false;
    var lower = String(text).toLowerCase();
    
    for (var i = 0; i < EDITION_TERMS.length; i++) {
      var term = EDITION_TERMS[i];
      var re = new RegExp('\\b' + term.replace(/[.*+?^${}()|[\]\\]/g, '\\$&') + '\\b', 'i');
      if (re.test(lower)) return true;
    }
    
    return false;
  }

  /**
   * Comprueba si un juego tiene la plataforma PS3
   */
  function hasPS3Platform_(game) {
    if (!game || !Array.isArray(game.platforms)) return false;
    return game.platforms.some(function(p) {
      return p === PS3_PLATFORM_ID || (p && p.id === PS3_PLATFORM_ID);
    });
  }

  /**
   * Convierte un objeto game de IGDB al formato de salida
   */
  function gameToResult_(game) {
    var gameYear = getYearFromGame_(game);
    var anio = '????';
    if (gameYear) {
      anio = String(gameYear);
    }

    var generoAnchors = [];
    if (Array.isArray(game.genres)) {
      game.genres.forEach(function(g) {
        if (g && g.name) generoAnchors.push({ text: g.name, href: '' });
      });
    }

    // Themes de IGDB → Subgénero
    var subgeneroAnchors = [];
    if (Array.isArray(game.themes)) {
      game.themes.forEach(function(t) {
        if (t && t.name) subgeneroAnchors.push({ text: t.name, href: '' });
      });
    }

    var jugadoresAnchors = [];
    if (Array.isArray(game.game_modes)) {
      game.game_modes.forEach(function(m) {
        if (m && m.name) jugadoresAnchors.push({ text: m.name, href: '' });
      });
    }

    var publisherAnchors = [];
    var desarrolladorAnchors = [];
    if (Array.isArray(game.involved_companies)) {
      game.involved_companies.forEach(function(ic) {
        if (ic && ic.company && ic.company.name) {
          var companyName = ic.company.name;
          if (ic.publisher) publisherAnchors.push({ text: companyName, href: '' });
          if (ic.developer) desarrolladorAnchors.push({ text: companyName, href: '' });
        }
      });
    }

    var caratula = '';
    if (game.cover && game.cover.image_id) {
      caratula = 'https://images.igdb.com/igdb/image/upload/t_1080p/' + game.cover.image_id + '.jpg';
    }

    var screenshots = [];
    if (Array.isArray(game.screenshots)) {
      game.screenshots.slice(0, 4).forEach(function(s) {
        if (s && s.image_id) {
          screenshots.push('https://images.igdb.com/igdb/image/upload/t_1080p/' + s.image_id + '.jpg');
        }
      });
    }

    // ====================================
    // PROCESAR VÍDEOS DE IGDB
    // ====================================
    // IGDB devuelve videos como array con video_id (ID de YouTube)
    // Convertimos a URLs de YouTube en texto plano
    var videoUrl = '';
    if (Array.isArray(game.videos) && game.videos.length > 0) {
      var videoUrls = [];
      game.videos.forEach(function(v) {
        if (v && v.video_id) {
          // IGDB almacena el ID de YouTube directamente
          videoUrls.push('https://www.youtube.com/watch?v=' + v.video_id);
        }
      });
      // Guardamos solo el primer vídeo (el más representativo, normalmente el trailer principal)
      // Si quieres todos, cambia a: videoUrl = videoUrls.join(', ');
      if (videoUrls.length > 0) {
        videoUrl = videoUrls[0];
      }
    }

    var sinopsis = game.summary || '';
    
    // Argumento (storyline de IGDB) - campo separado de la sinopsis
    var argumento = game.storyline || '';

    var ratingDisplay = '';
    if (typeof game.aggregated_rating === 'number' && !isNaN(game.aggregated_rating)) {
      ratingDisplay = Math.round(game.aggregated_rating) + '/100';
    }

    return {
      plataforma: 'PlayStation 3',
      titulo: game.name || titulo,
      anio: anio,
      generoAnchors: generoAnchors,
      subgeneroAnchors: subgeneroAnchors,
      publisherAnchors: publisherAnchors,
      desarrolladorAnchors: desarrolladorAnchors,
      autorAnchors: [],
      contributorsAnchors: [],
      jugadoresAnchors: jugadoresAnchors,
      controlesAnchors: [],
      versionAnchors: [],
      distribuidorasAnchors: [],
      ratingDisplay: ratingDisplay,
      caratula: caratula,
      screenshots: screenshots,
      imagenesAdicionales: [],
      mapa: '',
      instrucciones: '',
      video: videoUrl,
      revistas: [],
      sinopsis: sinopsis,
      argumento: argumento
    };
  }

  /**
   * Ejecuta una query a IGDB y devuelve los resultados
   */
function fetchRatingByName_(gameName) {
    if (!gameName) return null;
    var query = 'fields name, aggregated_rating, rating; search "' + gameName.replace(/"/g, '\\"') + '"; where aggregated_rating != null | rating != null; limit 5;';
    var endpoint = 'https://api.igdb.com/v4/games';
    var options = {
      method: 'post',
      headers: {
        'Client-ID': IGDB_CLIENT_ID,
        'Authorization': 'Bearer ' + IGDB_ACCESS_TOKEN,
        'Content-Type': 'text/plain'
      },
      payload: query,
      muteHttpExceptions: true
    };
    try {
      var response = UrlFetchApp.fetch(endpoint, options);
      if (response.getResponseCode() !== 200) return null;
      var results = JSON.parse(response.getContentText());
      if (Array.isArray(results) && results.length > 0) {
        for (var i = 0; i < results.length; i++) {
          var g = results[i];
          Logger.log('[IGDB] Fallback rating encontrado en "' + g.name + '": aggregated=' + g.aggregated_rating + ', user=' + g.rating);
          if (typeof g.aggregated_rating === 'number' && !isNaN(g.aggregated_rating)) {
            return Math.round(g.aggregated_rating);
          } else if (typeof g.rating === 'number' && !isNaN(g.rating)) {
            return Math.round(g.rating);
          }
        }
      }
    } catch (e) {
      Logger.log('[IGDB] Error buscando rating por nombre: ' + e);
    }
    return null;
  }
  function executeIgdbQuery_(query) {
    var endpoint = 'https://api.igdb.com/v4/games';
    var options = {
      method: 'post',
      headers: {
        'Client-ID': IGDB_CLIENT_ID,
        'Authorization': 'Bearer ' + IGDB_ACCESS_TOKEN,
        'Content-Type': 'text/plain'
      },
      payload: query,
      muteHttpExceptions: true
    };

    var response = UrlFetchApp.fetch(endpoint, options);
    var code = response.getResponseCode();

    if (code !== 200) {
      Logger.log('[IGDB-PS3] Error HTTP ' + code + ': ' + response.getContentText());
      return null;
    }

    var results = JSON.parse(response.getContentText());
    return Array.isArray(results) ? results : null;
  }

  // ============================================
  // LÓGICA PRINCIPAL
  // ============================================
  
  try {
    // Campos a solicitar de IGDB (incluimos platforms para filtrar y videos para trailers)
    var fieldsBlock =
      'fields name, slug, first_release_date, aggregated_rating, ' +
      'genres.name, ' +
      'themes.name, ' +
      'game_modes.name, ' +
      'involved_companies.company.name, ' +
      'involved_companies.developer, ' +
      'involved_companies.publisher, ' +
      'cover.image_id, ' +
      'screenshots.image_id, ' +
      'videos.video_id, ' +
      'videos.name, ' +
      'summary, ' +
      'storyline, ' +
      'platforms;';

    // ============================================
    // CASO 1: HAY URL IGDB → PRIORIDAD ABSOLUTA
    // ============================================
    if (linkStr) {
      var parsedLink = parseIgdbLink_(linkStr);
      var query = null;

      if (parsedLink.id) {
        query = fieldsBlock + ' where id = ' + parsedLink.id + '; limit 1;';
        Logger.log('[IGDB-PS3] 🔗 Usando URL por ID: ' + parsedLink.id);
      } else if (parsedLink.slug) {
        var safeSlug = parsedLink.slug.replace(/"/g, '\\"');
        query = fieldsBlock + ' where slug = "' + safeSlug + '"; limit 1;';
        Logger.log('[IGDB-PS3] 🔗 Usando URL por slug: ' + safeSlug);
      }

      if (query) {
        var results = executeIgdbQuery_(query);
        if (results && results.length > 0) {
          var game = results[0];
          Logger.log('[IGDB-PS3] ✅ Juego encontrado por URL: ' + (game.name || 'N/A'));
          return gameToResult_(game);
        }
        Logger.log('[IGDB-PS3] ⚠️ URL válida pero sin resultados. Intentando búsqueda por título...');
      } else {
        Logger.log('[IGDB-PS3] ⚠️ URL presente pero no parseable. Intentando búsqueda por título...');
      }
      // Si la URL no dio resultados, continuamos con búsqueda por título
    }

    // ============================================
    // CASO 2: BÚSQUEDA POR TÍTULO
    // ============================================
    if (!titleStr) {
      Logger.log('[IGDB-PS3] Sin título para buscar. Abortando.');
      return emptyResult;
    }

    var safeTitle = titleStr.replace(/"/g, '\\"');
    
    // Búsqueda amplia (limit 20 para tener más candidatos)
    var searchQuery = fieldsBlock + ' search "' + safeTitle + '"; limit 20;';
    
    Logger.log('[IGDB-PS3] 🔍 Buscando por título: "' + titleStr + '" (año hoja: ' + (hasDesiredYear ? desiredYear : 'N/A') + ')');
    
    var results = executeIgdbQuery_(searchQuery);
    
    if (!results || results.length === 0) {
      Logger.log('[IGDB-PS3] ❌ Sin resultados para: ' + titleStr);
      return emptyResult;
    }

    Logger.log('[IGDB-PS3] Encontrados ' + results.length + ' candidatos iniciales');

    // ============================================
    // FILTRADO INTELIGENTE DE CANDIDATOS
    // ============================================
    
    var candidates = results.slice(); // Copia del array
    var sheetBaseTitle = normalizeToBaseTitle_(titleStr);
    var sheetHasPartTerms = containsPartTerms_(titleStr);
    var sheetHasEditionTerms = containsEditionTerms_(titleStr);
    
    Logger.log('[IGDB-PS3] Título hoja base: "' + sheetBaseTitle + '"');
    Logger.log('[IGDB-PS3] Título hoja tiene Part terms: ' + sheetHasPartTerms);
    Logger.log('[IGDB-PS3] Título hoja tiene Edition terms: ' + sheetHasEditionTerms);

    // --------------------------------------------
    // PASO 3.1: Filtrar por "familia de título"
    // --------------------------------------------
    var familyFiltered = candidates.filter(function(g) {
      var gameBaseTitle = normalizeToBaseTitle_(g.name);
      return gameBaseTitle === sheetBaseTitle;
    });
    
    if (familyFiltered.length > 0) {
      Logger.log('[IGDB-PS3] Filtro familia: ' + familyFiltered.length + ' juegos coinciden con título base');
      candidates = familyFiltered;
    } else {
      Logger.log('[IGDB-PS3] Filtro familia: ninguno coincide exactamente, manteniendo todos');
    }

    // --------------------------------------------
    // PASO 3.2: Filtrar por año (si hay año en hoja)
    // --------------------------------------------
    if (hasDesiredYear && candidates.length > 1) {
      var yearFiltered = candidates.filter(function(g) {
        var gameYear = getYearFromGame_(g);
        return gameYear === desiredYear;
      });
      
      if (yearFiltered.length > 0) {
        Logger.log('[IGDB-PS3] Filtro año ' + desiredYear + ': ' + yearFiltered.length + ' juegos coinciden');
        candidates = yearFiltered;
      } else {
        Logger.log('[IGDB-PS3] Filtro año: ninguno coincide con ' + desiredYear + ', manteniendo anteriores');
      }
    }

    // --------------------------------------------
    // PASO 3.3: Filtrar por plataforma PS3
    // --------------------------------------------
    if (candidates.length > 1) {
      var ps3Filtered = candidates.filter(function(g) {
        return hasPS3Platform_(g);
      });
      
      if (ps3Filtered.length > 0) {
        Logger.log('[IGDB-PS3] Filtro PS3: ' + ps3Filtered.length + ' juegos tienen plataforma PS3');
        candidates = ps3Filtered;
      } else {
        Logger.log('[IGDB-PS3] Filtro PS3: ninguno tiene PS3 explícito, manteniendo anteriores');
      }
    }

    // --------------------------------------------
    // PASO 3.4: Descartar Part II / Remastered si el título de hoja no los tiene
    // --------------------------------------------
    var beforeVariantFilter = candidates.slice(); // Guardar por si el filtro es muy agresivo
    
    if (candidates.length > 1) {
      // Si el título de la hoja NO tiene "Part II", descartar juegos que sí lo tengan
      if (!sheetHasPartTerms) {
        var noPartFiltered = candidates.filter(function(g) {
          return !containsPartTerms_(g.name);
        });
        if (noPartFiltered.length > 0) {
          Logger.log('[IGDB-PS3] Descartando variantes "Part II": de ' + candidates.length + ' a ' + noPartFiltered.length);
          candidates = noPartFiltered;
        }
      }
      
      // Si el título de la hoja NO tiene términos de edición, descartar los que sí
      if (!sheetHasEditionTerms && candidates.length > 1) {
        var noEditionFiltered = candidates.filter(function(g) {
          return !containsEditionTerms_(g.name);
        });
        if (noEditionFiltered.length > 0) {
          Logger.log('[IGDB-PS3] Descartando variantes "Remastered/Edition": de ' + candidates.length + ' a ' + noEditionFiltered.length);
          candidates = noEditionFiltered;
        }
      }
    }
    
    // Si el filtro dejó vacío el array, volver al estado anterior
    if (candidates.length === 0) {
      Logger.log('[IGDB-PS3] Filtro de variantes demasiado agresivo, restaurando candidatos anteriores');
      candidates = beforeVariantFilter;
    }

    // --------------------------------------------
    // PASO 3.5: Desempate final (el más antiguo)
    // --------------------------------------------
    if (candidates.length > 1) {
      candidates.sort(function(a, b) {
        var yearA = getYearFromGame_(a) || 9999;
        var yearB = getYearFromGame_(b) || 9999;
        return yearA - yearB; // Más antiguo primero
      });
      Logger.log('[IGDB-PS3] Desempate por antigüedad: seleccionando el más antiguo');
    }

    // Seleccionar el primer candidato (el mejor según todos los filtros)
    var selectedGame = candidates[0];
    
    Logger.log('[IGDB-PS3] ✅ Seleccionado: "' + (selectedGame.name || 'N/A') + '" (' + (getYearFromGame_(selectedGame) || '????') + ')');
    
    return gameToResult_(selectedGame);

  } catch (e) {
    Logger.log('[IGDB-PS3] ❌ Excepción: ' + e);
    return emptyResult;
  }
}



// ============================================
// ESCRITURA EN HOJA PS3 (SOLO CELDAS VACÍAS)
// ============================================
// ⚠️ IMPORTANTE: Esta función NO toca las columnas manuales:
//    - PS3_UBICACION
//    - PS3_TIPO_FORMATO
//    - FAVORITO
//    - TERMINADO
//    - MAS_INFO
// Esas columnas se leen y muestran en la ficha, pero nunca se sobreescriben.
// ============================================
function writeBackPS3RowFromData_(sh, row, headers, data) {
  if (!data) return;

  // ---------- Helpers internos ----------
  function normalizeHeaderKey_(s) {
    let t = String(s || '').toLowerCase().trim();
    t = t
      .replace(/[áàäâ]/g, 'a')
      .replace(/[éèëê]/g, 'e')
      .replace(/[íìïî]/g, 'i')
      .replace(/[óòöô]/g, 'o')
      .replace(/[úùüû]/g, 'u')
      .replace(/ñ/g, 'n');
    t = t.replace(/\s+/g, ' ');
    return t;
  }

  function colIndex_(name) {
    const target = normalizeHeaderKey_((name || ''));
    for (let i = 0; i < headers.length; i++) {
      const hKey = normalizeHeaderKey_(headers[i]);
      if (hKey === target) return i + 1;
    }
    return 0;
  }

  function cleanValue_(v) {
    if (v == null) return '';
    let t = String(v).trim();
    if (!t) return '';
    if (t === '????') return '';                        // no escribimos placeholders
    if (/^dato no disponible$/i.test(t)) return '';     // tampoco este texto
    return t;
  }

 function writeIfEmpty_(colName, value) {
  const col = colIndex_(colName || '');
  const v = cleanValue_(value);
  if (!col || !v) return;

  const rng = sh.getRange(row, col);
  const current = String(rng.getValue() || '').trim();
  if (!current) {
    rng.setValue(v);
  }
}

  function anchorsToText_(arr) {
    return (Array.isArray(arr) ? arr : [])
      .map(a => (a && a.text) ? String(a.text) : '')
      .filter(Boolean)
      .join(', ');
  }

  // ---------- Aplanar datos ----------
  const anio = data.anio || '';
  const genero = anchorsToText_(data.generoAnchors);
  const subgenero = anchorsToText_(data.subgeneroAnchors);
  const publisher = anchorsToText_(data.publisherAnchors);
  const desarrollo = anchorsToText_(data.desarrolladorAnchors);
  const jugadores = anchorsToText_(data.jugadoresAnchors);
  const controles = anchorsToText_(data.controlesAnchors);
  const version = anchorsToText_(data.versionAnchors);
  const distrib = anchorsToText_(data.distribuidorasAnchors);
  const rating = data.ratingDisplay || '';
  const caratula = data.caratula || '';
  const screenshots = Array.isArray(data.screenshots) ? data.screenshots.join(', ') : '';
  const sinopsis = data.sinopsis || '';
  const video = data.video || '';
  const argumento = data.argumento || '';

  // ---------- Escritura en columnas PS3 ----------
  writeIfEmpty_('AÑO', anio);
  writeIfEmpty_('PUNTUACIÓN', rating);
  writeIfEmpty_('GÉNERO', genero);
  writeIfEmpty_('SUBGÉNERO', subgenero);
  writeIfEmpty_('PUBLISHER', publisher);
  writeIfEmpty_('DESARROLLO', desarrollo);
  writeIfEmpty_('JUGADORES', jugadores);
  writeIfEmpty_('CONTROLES', controles);
  writeIfEmpty_('VERSIÓN', version);
  writeIfEmpty_('DISTRIBUIDORAS', distrib);
  writeIfEmpty_('CARÁTULA', caratula);
  writeIfEmpty_('SCREENSHOTS', screenshots);
  writeIfEmpty_('SINOPSIS', sinopsis);
  writeIfEmpty_('VIDEO', video);
  writeIfEmpty_('ARGUMENTO', argumento);
}

// ============================================
// LAUNCHBOX: FUNCIONES DE SOPORTE
// ============================================

/**
 * Detecta la fuente de una URL (Lemon64, LaunchBox o desconocida)
 */
function detectarFuenteDeLink_(link) {
  if (!link) return 'NONE';
  
  const url = String(link).trim().toLowerCase();
  
  if (url.includes('lemon64.com')) {
    return 'LEMON64';
  }
  
  if (url.includes('gamesdb.launchbox-app.com') || url.includes('launchbox-app.com')) {
    return 'LAUNCHBOX';
  }
  
  return 'UNKNOWN';
}

/**
 * Extrae el ID de juego de una URL de LaunchBox
 * Ejemplo: https://gamesdb.launchbox-app.com/games/details/12345 → "12345"
 */
function extraerIdDeLaunchBoxUrl_(url) {
  if (!url) return null;
  
  const match = String(url).match(/\/games\/details\/(\d+)/i);
  return match ? match[1] : null;
}

/**
 * Verifica si un juego existe en Lemon64
 */
function verificarLemon64Disponible_(link) {
  if (!link) return false;
  
  try {
    const res = UrlFetchApp.fetch(link, { 
      muteHttpExceptions: true,
      followRedirects: false
    });
    
    const code = res.getResponseCode();
    
    if (code === 200) {
      // Verificar que no sea página de error
      const html = res.getContentText();
      const esError = html.includes('Game not found') || 
                     html.includes('No game found') ||
                     html.includes('404');
      return !esError;
    }
    
    return false;
    
  } catch (e) {
    Logger.log('[LEMON64] Error verificando disponibilidad: ' + e);
    return false;
  }
}

/**
 * Crea estructura de datos vacía con solo valores manuales (cuando no hay scraping)
 */
function crearDataC64Vacia_(titulo, overrides) {
  return {
    plataforma: 'Commodore 64',
    titulo: titulo,
    anio: (overrides && overrides.anio) || '????',
    generoAnchors: (overrides && overrides.genero) ? splitByCommaToAnchors_(overrides.genero, '') : [],
    subgeneroAnchors: (overrides && overrides.subgenero) ? splitByCommaToAnchors_(overrides.subgenero, '') : [],
    publisherAnchors: (overrides && overrides.publisher) ? splitByCommaToAnchors_(overrides.publisher, '') : [],
    desarrolladorAnchors: (overrides && overrides.desarrollador) ? splitByCommaToAnchors_(overrides.desarrollador, '') : [],
    autorAnchors: (overrides && overrides.autores) ? splitByCommaToAnchors_(overrides.autores, '') : [],
    contributorsAnchors: [],
    jugadoresAnchors: (overrides && overrides.jugadores) ? splitByCommaToAnchors_(overrides.jugadores, '') : [],
    controlesAnchors: (overrides && overrides.controles) ? splitByCommaToAnchors_(overrides.controles, '') : [],
    versionAnchors: [],
    distribuidorasAnchors: [],
    ratingDisplay: (overrides && overrides.puntuacion) || '',
    caratula: (overrides && overrides.caratula) || FALLBACK_COVER_URL_C64,
    screenshots: (overrides && overrides.screenshots) ? overrides.screenshots.split(/\s*,\s*/).map(x => x.trim()).filter(Boolean).slice(0, 2) : [],
    imagenesAdicionales: (overrides && overrides.imagenesExtra) ? overrides.imagenesExtra.split(/[\n,;]+/).map(s => s.trim()).filter(Boolean) : [],
    mapa: '',
    instrucciones: (overrides && overrides.instrucciones) || '',
    video: (overrides && overrides.video) || '',
    revistas: [],
    sinopsis: (overrides && overrides.sinopsis) || '',
    argumento: ''
  };
}

// ============================================
// LAUNCHBOX: BÚSQUEDA Y VERIFICACIÓN
// ============================================

/**
 * Busca un juego en LaunchBox por título SOLO en Commodore 64
 * Retorna el ID del juego o null si no se encuentra
 */
function buscarJuegoEnLaunchBox_(titulo) {
  try {
    // LaunchBox carga resultados con JavaScript, así que intentamos acceso directo
    Logger.log('[LAUNCHBOX] Intentando acceso directo para: ' + titulo);
    
    // Crear slug a partir del título
    const slug = titulo
      .toLowerCase()
      .replace(/[^a-z0-9\s]/g, '')  // Solo letras y números
      .replace(/\s+/g, '-')          // Espacios a guiones
      .trim();
    
    Logger.log('[LAUNCHBOX] Slug generado: ' + slug);
    
    // Intentar acceso directo sin ID (a veces funciona)
    const directUrl = 'https://gamesdb.launchbox-app.com/games/details/' + slug;
    Logger.log('[LAUNCHBOX] Probando URL directa: ' + directUrl);
    
    const res = UrlFetchApp.fetch(directUrl, { 
      muteHttpExceptions: true,
      followRedirects: true 
    });
    
    if (res.getResponseCode() === 200) {
      const html = res.getContentText();
      
      // Extraer ID de la URL final (después de redirecciones)
      const finalUrl = res.getResponseCode() === 200 ? directUrl : null;
      
      // Buscar el ID en el HTML de la página de detalles
      const idMatch = html.match(/\/games\/details\/(\d+)[-\w]*/);
      if (idMatch) {
        const gameId = idMatch[1];
        Logger.log('[LAUNCHBOX] Juego encontrado con acceso directo, ID: ' + gameId);
        
        // Verificar que sea C64
        if (verificarPlataformaEnDetalles_(gameId, 'Commodore 64')) {
          return gameId;
        } else {
          Logger.log('[LAUNCHBOX] El juego NO es de C64');
          return null;
        }
      }
    }
    
    Logger.log('[LAUNCHBOX] No se pudo acceder directamente al juego');
    return null;
    
  } catch (e) {
    Logger.log('[ERROR] buscarJuegoEnLaunchBox_: ' + e);
    return null;
  }
}

/**
 * Verifica que una página de juego pertenezca a la plataforma especificada
 * Esto evita confundir versiones de C64 con Amiga, Spectrum, etc.
 */
function verificarPlataformaEnDetalles_(gameId, plataformaEsperada) {
  try {
    const gameUrl = 'https://gamesdb.launchbox-app.com/games/details/' + gameId;
    const res = UrlFetchApp.fetch(gameUrl, { 
      muteHttpExceptions: true,
      followRedirects: true 
    });
    
    if (res.getResponseCode() !== 200) {
      Logger.log('[LAUNCHBOX] Error al verificar plataforma: ' + res.getResponseCode());
      return false;
    }
    
    const html = res.getContentText();
       // ===== LOGS TEMPORALES DE DEBUGGING =====
    Logger.log('[LAUNCHBOX DEBUG] Response code: ' + res.getResponseCode());
    Logger.log('[LAUNCHBOX DEBUG] HTML length: ' + html.length + ' caracteres');
    Logger.log('[LAUNCHBOX DEBUG] Primeros 1000 caracteres del HTML:');
    Logger.log(html.substring(0, 1000));
    
    // Buscar manualmente si existe "crillion" en el HTML
    const contieneJuego = html.toLowerCase().indexOf('crillion') > -1;
    Logger.log('[LAUNCHBOX DEBUG] ¿HTML contiene "crillion"? ' + contieneJuego);
    
    // Buscar si existe "games/details"
    const contieneDetails = html.indexOf('games/details') > -1;
    Logger.log('[LAUNCHBOX DEBUG] ¿HTML contiene "games/details"? ' + contieneDetails);
    
    // Buscar el ID específico de Crillion
    const contieneId = html.indexOf('94984') > -1;
    Logger.log('[LAUNCHBOX DEBUG] ¿HTML contiene ID "94984"? ' + contieneId);
    // ===== FIN LOGS TEMPORALES =====
    
    // Buscar el campo "Platform" en los detalles
    const platformMatch = html.match(/Platform\s*:\s*<dd[^>]*>[\s\S]*?>([^<]+)<\/a>/i);
    
    if (platformMatch && platformMatch[1]) {
      const plataformaEncontrada = platformMatch[1].trim();
      Logger.log('[LAUNCHBOX] Plataforma detectada: "' + plataformaEncontrada + '"');
      
      // Comparación flexible (acepta "Commodore 64" o "C64")
      const esCorrecta = plataformaEncontrada.toLowerCase().includes(plataformaEsperada.toLowerCase()) ||
                         (plataformaEsperada.toLowerCase().includes('commodore') && /\bC64\b/i.test(plataformaEncontrada));
      
      if (!esCorrecta) {
        Logger.log('[LAUNCHBOX] ⚠️ PLATAFORMA INCORRECTA: esperaba "' + plataformaEsperada + 
                   '", encontró "' + plataformaEncontrada + '"');
      }
      
      return esCorrecta;
    }
    
    // Si no encuentra el campo Platform, buscar en título
    const titleMatch = html.match(/<h1[^>]*>([^<]+)<\/h1>/i);
    if (titleMatch && titleMatch[1]) {
      const titulo = titleMatch[1].trim();
      const tieneC64 = /Commodore\s*64|C64/i.test(titulo);
      
      Logger.log('[LAUNCHBOX] Verificación por título: ' + (tieneC64 ? '✓ ES C64' : '✗ NO ES C64'));
      return tieneC64;
    }
    
    Logger.log('[LAUNCHBOX] ⚠️ No se pudo verificar la plataforma');
    return false;
    
  } catch (e) {
    Logger.log('[ERROR] verificarPlataformaEnDetalles_: ' + e);
    return false;
  }
}

// ============================================
// LAUNCHBOX: SCRAPING COMPLETO
// ============================================

/**
 * Extrae datos completos de un juego desde LaunchBox
 * Incluye traducción automática de sinopsis al castellano
 */
function fetchC64_fromLaunchBox_(titulo, overrides, gameIdDirecto) {
  try {
    // ====================================
    // PASO 1: OBTENER ID DEL JUEGO
    // ====================================
    let gameId = gameIdDirecto;
    
    if (!gameId) {
      gameId = buscarJuegoEnLaunchBox_(titulo);
      
      if (!gameId) {
        Logger.log('[LAUNCHBOX] Juego no encontrado en C64: ' + titulo);
        return { encontrado: false };
      }
    }
    
    Logger.log('[LAUNCHBOX] Juego C64 verificado, ID: ' + gameId);
    
    // ====================================
    // PASO 2: OBTENER PÁGINA DE DETALLES
    // ====================================
    const gameUrl = 'https://gamesdb.launchbox-app.com/games/details/' + gameId;
    const res = UrlFetchApp.fetch(gameUrl, { muteHttpExceptions: true });
    
    if (res.getResponseCode() !== 200) {
      Logger.log('[LAUNCHBOX] Error HTTP en detalles: ' + res.getResponseCode());
      return { encontrado: false };
    }
    
    const html = res.getContentText();
    
    // ====================================
    // VERIFICACIÓN FINAL DE PLATAFORMA
    // ====================================
    const platformCheck = html.match(/Platform\s*:\s*<dd[^>]*>[\s\S]*?>([^<]+)<\/a>/i);
    
    if (platformCheck && platformCheck[1]) {
      const plat = platformCheck[1].trim();
      if (!/Commodore\s*64|C64/i.test(plat)) {
        Logger.log('[LAUNCHBOX] ⚠️ ABORTANDO: La página es de "' + plat + '", no C64');
        return { encontrado: false };
      }
    }
    
    Logger.log('[LAUNCHBOX] ✓ Confirmado: página es de Commodore 64');
    
    const data = { 
      encontrado: true, 
      fuente: 'LaunchBox', 
      gameId: gameId,
      plataforma: 'Commodore 64',
      titulo: titulo
    };
    
    // ====================================
    // EXTRAER DATOS BÁSICOS
    // ====================================
    
    // Año
    const fechaMatch = html.match(/Release Date\s*:\s*<dd[^>]*>([^<]+)<\/dd>/i);
    if (fechaMatch) {
      const fecha = fechaMatch[1].trim();
      const anioMatch = fecha.match(/\b(19\d{2}|20\d{2})\b/);
      data.anio = anioMatch ? anioMatch[1] : fecha;
    } else {
      data.anio = '????';
    }
    
    // Max Players
    const playersMatch = html.match(/Max Players\s*:\s*<dd[^>]*>([^<]+)<\/dd>/i);
    if (playersMatch) {
      const maxPlayers = parseInt(playersMatch[1].trim());
      if (maxPlayers === 1) {
        data.jugadoresAnchors = [{ text: 'Single Player', href: '#' }];
      } else if (maxPlayers > 1) {
        data.jugadoresAnchors = [{ text: 'Multiple Players', href: '#' }];
      }
    } else {
      data.jugadoresAnchors = [];
    }
    
    // ====================================
    // DEVELOPERS
    // ====================================
    const devBlock = html.match(/Developers\s*:\s*<dd[^>]*>([\s\S]*?)<\/dd>/i);
    data.desarrolladorAnchors = [];
    
    if (devBlock) {
      const devLinks = devBlock[1].matchAll(/<a[^>]+>([^<]+)<\/a>/gi);
      for (const link of devLinks) {
        data.desarrolladorAnchors.push({ text: link[1].trim(), href: '#' });
      }
    }
    
    // ====================================
    // PUBLISHERS
    // ====================================
    const pubBlock = html.match(/Publishers\s*:\s*<dd[^>]*>([\s\S]*?)<\/dd>/i);
    data.publisherAnchors = [];
    
    if (pubBlock) {
      const pubLinks = pubBlock[1].matchAll(/<a[^>]+>([^<]+)<\/a>/gi);
      for (const link of pubLinks) {
        data.publisherAnchors.push({ text: link[1].trim(), href: '#' });
      }
    }
    
    // ====================================
    // GÉNEROS
    // ====================================
    const genreBlock = html.match(/Genre\s*:\s*<dd[^>]*>([\s\S]*?)<\/dd>/i);
    data.generoAnchors = [];
    
    if (genreBlock) {
      const genreLinks = genreBlock[1].matchAll(/<a[^>]+>([^<]+)<\/a>/gi);
      for (const link of genreLinks) {
        data.generoAnchors.push({ text: link[1].trim(), href: '#' });
      }
    }
    
    // ====================================
    // CARÁTULA (BOX - FRONT) - PRIORIZAR MAYOR RESOLUCIÓN
    // ====================================
    const boxFrontRegex = /###\s*Box\s*-\s*Front[\s\S]*?!\[([^\]]*)\]\(([^)]+)\)/gi;
    const covers = [];
    let coverMatch;
    
    while ((coverMatch = boxFrontRegex.exec(html)) !== null) {
      const altText = coverMatch[1];
      const url = coverMatch[2];
      
      const resMatch = altText.match(/(\d+)\s*x\s*(\d+)/);
      const width = resMatch ? parseInt(resMatch[1]) : 0;
      
      covers.push({ url: url, width: width });
    }
    
    // Ordenar por resolución descendente
    covers.sort(function(a, b) { return b.width - a.width; });
    data.caratula = covers.length > 0 ? covers[0].url : FALLBACK_COVER_URL_C64;
    
    Logger.log('[LAUNCHBOX] Carátula: ' + data.caratula);
    
    // ====================================
    // SCREENSHOTS
    // ====================================
    const screenshotRegex = /###\s*Screenshot\s*-\s*Gameplay[\s\S]*?!\[[^\]]*\]\(([^)]+)\)/gi;
    const screenshots = [];
    let ssMatch;
    
    while ((ssMatch = screenshotRegex.exec(html)) !== null) {
      screenshots.push(ssMatch[1]);
    }
    
    data.screenshots = screenshots.slice(0, 2);
    data.imagenesAdicionales = screenshots.slice(2);
    
    // ====================================
    // VIDEO (YOUTUBE)
    // ====================================
    const videoMatch = html.match(/Video\s*:\s*<(https?:\/\/(?:www\.)?youtube\.com\/watch\?v=[^>]+)>/i);
    data.video = videoMatch ? videoMatch[1] : '';
    
    // ====================================
    // OVERVIEW (SINOPSIS) - TRADUCIR AL CASTELLANO
    // ====================================
    const overviewMatch = html.match(/##\s*Overview[\s\S]{0,200}?<p[^>]*>([\s\S]*?)<\/p>/i);
    
    if (overviewMatch) {
      const overviewIngles = stripTags_(overviewMatch[1])
        .replace(/\s+/g, ' ')
        .trim();
      
      if (overviewIngles && overviewIngles.length > 20) {
        Logger.log('[LAUNCHBOX] Overview original (inglés): ' + overviewIngles.substring(0, 100) + '...');
        Logger.log('[LAUNCHBOX] Traduciendo Overview al castellano...');
        
        data.sinopsis = translateTextToSpanish_(overviewIngles);
        
        Logger.log('[LAUNCHBOX] Overview traducido: ' + data.sinopsis.substring(0, 100) + '...');
      } else {
        data.sinopsis = '';
      }
    } else {
      Logger.log('[LAUNCHBOX] No se encontró Overview');
      data.sinopsis = '';
    }
    
    // ====================================
    // CAMPOS VACÍOS (LaunchBox no los tiene)
    // ====================================
    data.autorAnchors = [];
    data.contributorsAnchors = [];
    data.subgeneroAnchors = [];
    data.controlesAnchors = [];
    data.versionAnchors = [];
    data.distribuidorasAnchors = [];
    data.ratingDisplay = '';
    data.revistas = [];
    data.instrucciones = '';
    data.mapa = '';
    data.argumento = '';
    
    // ====================================
    // APLICAR OVERRIDES MANUALES
    // ====================================
    if (overrides) {
      if (overrides.anio) data.anio = overrides.anio;
      if (overrides.caratula) data.caratula = overrides.caratula;
      if (overrides.video) data.video = overrides.video;
      
      if (overrides.genero) {
        data.generoAnchors = splitByCommaToAnchors_(overrides.genero, gameUrl);
      }
      if (overrides.subgenero) {
        data.subgeneroAnchors = splitByCommaToAnchors_(overrides.subgenero, gameUrl);
      }
      if (overrides.publisher) {
        data.publisherAnchors = splitByCommaToAnchors_(overrides.publisher, gameUrl);
      }
      if (overrides.desarrollador) {
        data.desarrolladorAnchors = splitByCommaToAnchors_(overrides.desarrollador, gameUrl);
      }
      if (overrides.autores) {
        data.autorAnchors = splitByCommaToAnchors_(overrides.autores, gameUrl);
      }
      if (overrides.jugadores) {
        data.jugadoresAnchors = splitByCommaToAnchors_(overrides.jugadores, gameUrl);
      }
      if (overrides.controles) {
        data.controlesAnchors = splitByCommaToAnchors_(overrides.controles, gameUrl);
      }
      if (overrides.screenshots) {
        const parts = overrides.screenshots.split(/\s*,\s*/).map(function(x) { return x.trim(); }).filter(Boolean);
        data.screenshots = parts.slice(0, 2);
        data.imagenesAdicionales = parts.slice(2);
      }
      if (overrides.imagenesExtra) {
        const extraUrls = overrides.imagenesExtra.split(/[\n,;]+/).map(function(s) { return s.trim(); }).filter(Boolean);
        data.imagenesAdicionales = Array.from(new Set(data.imagenesAdicionales.concat(extraUrls)));
      }
      if (overrides.instrucciones) {
        data.instrucciones = overrides.instrucciones;
      }
      if (overrides.puntuacion) {
        data.ratingDisplay = overrides.puntuacion;
      }
      if (overrides.sinopsis) {
        data.sinopsis = overrides.sinopsis;
        Logger.log('[LAUNCHBOX] Sinopsis manual respetada');
      }
    }
    
    Logger.log('[LAUNCHBOX] Datos extraídos exitosamente');
    return data;
    
  } catch (e) {
    Logger.log('[ERROR] fetchC64_fromLaunchBox_: ' + e);
    return { encontrado: false };
  }
}

// ============================================
// LAUNCHBOX: SINOPSIS COMPLEMENTARIA
// ============================================

/**
 * Obtiene SOLO la sinopsis de LaunchBox (sin hacer scraping completo)
 * Útil cuando Lemon64 fue la fuente principal pero no tiene sinopsis
 */
function fetchC64_fromLaunchBox_SOLO_SINOPSIS_(titulo) {
  try {
    const gameId = buscarJuegoEnLaunchBox_(titulo);
    
    if (!gameId) {
      Logger.log('[LAUNCHBOX-SINOPSIS] Juego no encontrado');
      return null;
    }
    
    const gameUrl = 'https://gamesdb.launchbox-app.com/games/details/' + gameId;
    const res = UrlFetchApp.fetch(gameUrl, { muteHttpExceptions: true });
    
    if (res.getResponseCode() !== 200) {
      Logger.log('[LAUNCHBOX-SINOPSIS] Error HTTP: ' + res.getResponseCode());
      return null;
    }
    
    const html = res.getContentText();
    
    // Verificar plataforma
    const platCheck = html.match(/Platform\s*:\s*<dd[^>]*>[\s\S]*?>([^<]+)<\/a>/i);
    if (!platCheck || !/Commodore\s*64|C64/i.test(platCheck[1])) {
      Logger.log('[LAUNCHBOX-SINOPSIS] No es C64, abortando');
      return null;
    }
    
    // Extraer Overview
    const overviewMatch = html.match(/##\s*Overview[\s\S]{0,200}?<p[^>]*>([\s\S]*?)<\/p>/i);
    
    if (overviewMatch) {
      const overviewIngles = stripTags_(overviewMatch[1])
        .replace(/\s+/g, ' ')
        .trim();
      
      if (overviewIngles && overviewIngles.length > 20) {
        Logger.log('[LAUNCHBOX-SINOPSIS] Traduciendo Overview complementario...');
        return {
          sinopsis: translateTextToSpanish_(overviewIngles)
        };
      }
    }
    
    Logger.log('[LAUNCHBOX-SINOPSIS] No se encontró Overview');
    return null;
    
  } catch (e) {
    Logger.log('[ERROR] fetchC64_fromLaunchBox_SOLO_SINOPSIS_: ' + e);
    return null;
  }
}
/**
 * Convierte un título en un slug válido para Lemon64
 * Ejemplo: "Boulder Dash" → "boulder-dash"
 */
function makeLemon64Slug_(titulo) {
  if (!titulo) return '';
  
  return String(titulo)
    .toLowerCase()
    .trim()
    .replace(/[^a-z0-9\s-]/g, '') // Quitar caracteres especiales
    .replace(/\s+/g, '-')          // Espacios a guiones
    .replace(/-+/g, '-')           // Múltiples guiones a uno solo
    .replace(/^-|-$/g, '');        // Quitar guiones al inicio/final
}

/**
 * Convierte el texto de la columna REVISTAS en array de objetos
 * Formato esperado: "CRASH N°48|https://..., Microhobby N°12|https://..."
 */
function parseSheetRevistas_(revistasText) {
  if (!revistasText || !String(revistasText).trim()) return [];
  
  const revistas = [];
  const lineas = String(revistasText).split(/[\n,;]+/);
  
  for (let i = 0; i < lineas.length; i++) {
    const linea = lineas[i].trim();
    if (!linea) continue;
    
    // Formato: "REVISTA|URL"
    const partes = linea.split('|');
    
    if (partes.length >= 2) {
      revistas.push({
        mag: partes[0].trim(),
        title: partes[0].trim(),
        href: partes[1].trim()
      });
    } else if (partes.length === 1 && partes[0].trim()) {
      // Solo nombre sin URL
      revistas.push({
        mag: partes[0].trim(),
        title: partes[0].trim(),
        href: ''
      });
    }
  }
  
  return revistas;
}
